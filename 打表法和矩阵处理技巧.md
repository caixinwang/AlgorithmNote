# 打表法

![image-20220512213852450](./image\image-20220512213852450.png)

## 买苹果问题

![image-20220512213910040](./image\image-20220512213910040.png)

- 分解质因数法 ---找两个数的最小公倍数

  分解质因数法就是先把要求最小公倍数的那几个数分别分解质因数，然后将原来几个数里所含该质因数的最多个数的每一个质因数相乘，所得的积就是要求的最小公倍数。 

  如：求60、42的最小公倍数。 

  解：60=2×2×3×5 42=2×3×7 

  60和42的最小公倍数=2×3×2×5×7=420 。 

  这种方法是把60和42分别质因数后，观察相同的质因数只取一个（如2，3），把各自独有的质因数全部乘进去，所得的积就是这两个数的最小公倍数。





## 吃草问题

![image-20220512214043443](./image\image-20220512214043443.png)

```java
// n份青草放在一堆
// 先手后手都绝顶聪明
// string "先手" "后手"
public static String winner1(int n) {
    if (n==0){
        return "后手";
    }
    int eat=1;
    while(true){
        if (winner1(n-eat).equals("后手")){
            return "先手";
        }
        if (eat>n/4){
            break;//退出条件放在这里是为了防止越界
        }
        eat*=4;
    }
    return "后手";
}

public static String winner2(int n) {
    if (n==0){
        return "后手";
    }
    return ((n-1)%5==2||(n-1)%5==4)?"后手":"先手";
}
```

## 连续累加数

![image-20220512214006417](./image\image-20220512214006417.png)

``` java
public static boolean isMSum1(int num) {
    if (num <= 1) {
        return false;
    }

    for (int i = 1; i <= num; i++) {//控制开头
        int sum = i;
        for (int j = i + 1; j <= num; j++) {
            sum += j;
            if (sum == num) {
                return true;
            } else if (sum > num) {
                break;
            }
        }
    }
    return false;
}

public static boolean isMSum2 ( int num){
    return (num & (num - 1)) != 0;
}
```



## 开灯关灯问题

- 有一个布尔类型的数组，有先手和后手之分。先手和后手和可以把i~0位的布尔值取反。谁率先把数组里面的数都变成true谁赢。

我们可以把布尔数组转发成int，然后打表找规律。



# 矩阵打印

1) zigzag打印矩阵
2) 转圈打印矩阵
3) 原地旋转正方形矩阵

- 核心技巧:找到coding上的宏观调度

## zigzag打印

![image-20220514135526482](./image\image-20220514135526482.png)

```java
public static void printMatrixZigZag(int[][] matrix) {
    int rEnd = matrix.length-1;//最大行数下标--有多少个一维数组
    int cEnd = matrix[0].length-1;//最大列数下标--每一个一维数组有多少个元素
    int a = 0;//(a,b)在上右边运动
    int b = 0;
    int c = 0;//(c,d)在左下边运动
    int d = 0;
    boolean up = true;
    while (a != rEnd+1) {
        printLevel(matrix, a, b, c, d, up);
        a = b == cEnd ? a + 1 : a;//a先更新，因为a的更新会收列的影响
        b = b == cEnd ? b : b + 1;
        d = c == rEnd ? d + 1 : d;
        c = c == rEnd ? c : c + 1;
        up = !up;
    }
    System.out.println();
}

/**
 * @param m:矩阵
 * @param a:(a,b)在上面和右面的边运动
 * @param b:
 * @param c:(c,d)在左边和下面的边运动
 * @param d:
 * @param up:如果up为true就自下往上打印
 */
public static void printLevel(int[][] m, int a, int b, int c, int d, boolean up) {
    if (m == null) {
        return;
    }
    if (up) {//自下往上打印
        while (c != a - 1) {
            System.out.print(m[c--][d++] + " ");
        }
    } else {//自上往下打印
        while (a!=c+1) {
            System.out.print(m[a++][b--] + " ");
        }
    }
}
```

## 转圈打印矩阵

![image-20220514135707977](./image\image-20220514135707977.png)

```java
public static void spiralOrderPrint(int[][] matrix) {
    int a=0;
    int b=0;
    int c=matrix.length-1;
    int d=matrix[0].length-1;
    while(a<=c){//直到他们碰上
        printEdge(matrix,a++,b++,c--,d--);
    }
}

public static void printEdge(int[][] m, int a, int b, int c, int d) {
    if(m==null){
        return;
    }
    if (a==c){//横线和单点的逻辑
        while(b!=d+1){
            System.out.print(m[a][b++]+" ");
        }
    }else if(b==d){//竖线的逻辑
        while(a!=c+1){
            System.out.print(m[a++][b]+" ");
        }
    }else{//长方形的逻辑
        //打印上面
        int b2=b;
        while (b2!=d){//不让碰上
            System.out.print(m[a][b2++]+" ");
        }
        //打印右边
        int a2=a;
        while (a2!=c){

            System.out.print(m[a2++][d]+" ");
        }
        //打印下边
        int d2=d;
        while (d2!=b){
            System.out.print(m[c][d2--]+" ");
        }
        //打印左边
        int c2=c;
        while(c2!=a){
            System.out.print(m[c2--][b]+" ");
        }
    }
}
```

## 原地旋转正方形矩阵

![image-20220514135754620](./image\image-20220514135754620.png)

```java
public static void rotate(int[][] matrix) {
    int a=0;
    int b=0;
    int rEnd=matrix.length-1;
    int cEnd=matrix[0].length-1;
    while(a<=rEnd){
        rotateEdge(matrix,a++,b++,rEnd--,cEnd--);
    }
}

public static void rotateEdge(int[][] m, int a, int b, int c, int d) {
    if(m==null||d-b!=c-a){
        return;
    }
    for (int i=0;i<c-a;i++){//一共有c-a组
        int temp=m[a][i+b];//第i组的一号
        m[a][i+b]=m[c-i][b];//第i组的4号赋值给第i组的1号
        m[c-i][b]=m[c][d-i];//第i组的3号赋值给第i组的4号
        m[c][d-i]=m[a+i][d];
        m[a+i][d]=temp;
    }
}

public static void printMatrix(int[][] matrix) {
    for (int i = 0; i != matrix.length; i++) {
        for (int j = 0; j != matrix[0].length; j++) {
            System.out.printf("%3d",matrix[i][j]);
        }
        System.out.println();
    }
}
```
