# 斐波那契数列

- 斐波那契数列的递推式，F(N)=F(N-1)+F(N-2)，f(0)=1,f(2)=1.

斐波那契数列是由严格递推式的，不随条件转移。不是说在某些情况下才等于这个递推式，而是在任何情况下都满足这个式子。

![image-20220912213129224](image/image-20220912213129224.png)

![image-20220912213134578](image/image-20220912213134578.png)

```java
//普通递归
private static int f1(int n){
    if (n<1)return 0;
    if (n==1||n==2)return 1;
    return f1(n-1)+f1(n-2);
}

/**
 * 利用动态规划
 * @param n:返回斐波那契数列的第n项
 * @return :
 */
private static int f2(int n){
    if (n<1)return 0;
    if (n==1||n==2)return 1;
    int res=0;
    int n1=1;
    int n2=1;
    for (int i = 0; i < n - 2; i++) {//res迭代n-2次就是答案
        res=n1+n2;
        n1=n2;
        n2=res;
    }
    return res;
}

private static int f3(int n){
    if (n<1)return 0;
    if (n==1||n==2)return 1;
    int[][] m=new int[][]{{1,1},{1,0}};
    m=matrixPower(m,n-2);
    return m[0][0]+m[1][0];
}

/**
 *
 * @param a:矩阵
 * @param n:矩阵a的n次方
 * @return :返回结果
 */
private static int[][] matrixPower(int[][] a,int n){
    if (n<=0) return null;
    int[][] res=new int[a.length][a[0].length];
    for (int i = 0; i < res.length; i++) {//初始化为单位矩阵
        res[i][i]=1;
    }
    int [][]m=a;//一次方
    for (;n!=0;n>>=1){
        if ((n&1)==1) res=mulMatrix(res,m);
        m=mulMatrix(m,m);//m平方
    }
    return res;
}


private static int[][] mulMatrix(int[][]a,int[][]b){
    int[][] res=new int[a.length][b[0].length];
    for (int i = 0; i < a.length; i++) {
        for (int j = 0; j < b.length; j++) {
            for (int k = 0; k < b[0].length; k++) {
                res[i][j]+=a[i][k]*b[k][j];
            }
        }
    }
    return res;
}
```

## 达标字符串问题

![image-20220912213210450](image/image-20220912213210450.png)

 ![image-20220913192648236](image/image-20220913192648236.png)

```java
public static int getNum1(int n) {
    if (n < 1) {
        return 0;
    }
    return process(1, n);
}

/**
 * fi,如果i+1位置是1，那么就变成fi+1.如果i+1位置是0，那么fi+2位置就是1，就变成fi+2
 * @param i:从str[i,n]假设i位置是1，有多少种方法
 * @param n:01序列的长度
 * @return
 */
public static int process(int i, int n) {
    if (i == n - 1) {//n位置分别取1和2
        return 2;
    }
    if (i == n) {//n位置直接就是1，只有一种方法
        return 1;
    }
    return process(i + 1, n) + process(i + 2, n);
}

public static int getNum2(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    int pre = 1;
    int cur = 1;
    int tmp = 0;
    for (int i = 2; i < n + 1; i++) {
        tmp = cur;
        cur += pre;
        pre = tmp;
    }
    return cur;
}

public static int getNum3(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return n;
    }
    int[][] base = { { 1, 1 }, { 1, 0 } };
    int[][] res = matrixPower(base, n - 2);
    return 2 * res[0][0] + res[1][0];
}

public static int fi(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return 1;
    }
    int[][] base = { { 1, 1 },
            { 1, 0 } };
    int[][] res = matrixPower(base, n - 2);
    return res[0][0] + res[1][0];
}

public static int[][] matrixPower(int[][] m, int p) {
    int[][] res = new int[m.length][m[0].length];
    for (int i = 0; i < res.length; i++) {
        res[i][i] = 1;
    }
    int[][] tmp = m;
    for (; p != 0; p >>= 1) {
        if ((p & 1) != 0) {
            res = muliMatrix(res, tmp);
        }
        tmp = muliMatrix(tmp, tmp);
    }
    return res;
}

public static int[][] muliMatrix(int[][] m1, int[][] m2) {
    int[][] res = new int[m1.length][m2[0].length];
    for (int i = 0; i < m1.length; i++) {
        for (int j = 0; j < m2[0].length; j++) {
            for (int k = 0; k < m2.length; k++) {
                res[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
    return res;
}
```