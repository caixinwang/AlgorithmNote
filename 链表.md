# 链表

## 利用链表实现队列和栈

### 代码

```java
public static class Node<V>{
   public V value;
   public Node<V> next;

   public Node(V value){
      this.value=value;
   }
}

public static class MyQueue<V>{
   public Node<V> head;//从头出
   public Node<V> tail;//从尾进
   public int size;

   public MyQueue(){
      head=null;
      tail=null;
      size=0;
   }

   public int size(){
      return size;
   }

   public boolean isEmpty(){
      return size==0;
   }

   public void EnQueue(V value){
      Node<V> node=new Node<>(value);
      if (tail==null){
         head=node;
         tail=node;
      }else {
         tail.next=node;
         tail=node;
      }
      size++;
   }

   public V DeQueue(){
      V ans=null;
      if (head!=null){
         ans=head.value;
         head=head.next;
         size--;
      }
      if (head==null){
         tail=null;
      }
      return ans;
   }

   public V peek(){
      V ans=null;
      if (head!=null){
         ans=head.value;
      }
      return ans;
   }
}

/**
 * 栈用头插来实现。从头部出
 * @param <V>
 */
public static class MyStack<V>{
   Node<V> head;
   int size;

   public MyStack(){
      head=null;
      size=0;
   }

   public boolean isEmpty(){
      return 0==size;
   }

   public int size() {
      return size;
   }

   public void push(V value){
      Node<V> node=new Node<>(value);
      if (head==null){
         head=node;
      }else {
         node.next=head;
         head=node;
      }
      size++;
   }

   public V pop(){
      V value=null;
      if (head!=null){
         value=head.value;
         head=head.next;
         size--;
      }
      return value;
   }

   public V peek(){
      return head!=null?head.value:null;
   }

}
```

## 利用双向链表实现双向入队出队的队列

### 代码

```java
public static class Node<V> {
   public V value;
   public Node<V> last;
   public Node<V> next;

   public Node(V v) {
      value = v;
      last = null;
      next = null;
   }
}

public static class MyDeque<V> {
   private Node<V> head;
   private Node<V> tail;
   private int size;

   public MyDeque() {
      head = null;
      tail = null;
      size = 0;
   }

   public boolean isEmpty() {
      return size == 0;
   }

   public int size() {
      return size;
   }

   public void pushHead(V value) {
      Node<V> node = new Node<>(value);
      if (head == null) {
         head = node;
         tail = node;
      } else {
         node.next = head;
         head.last = node;
         head=head.last;
      }
      size++;
   }

   public void pushTail(V value) {
      Node<V> node=new Node<>(value);
      if (head==null){
         head=node;
         tail=node;
      }else{
         tail.next=node;
         node.last=tail;
         tail= tail.next;
      }
      size++;
   }

   public V pollHead() {
      V value=null;
      if (head!=null){//至少有1个元素
         value= head.value;//把值存下来
         head= head.next;//head后移
         if (head==null){//防止下面出现空指针异常，进入这个if语句说明只有一个元素
            tail=null;
         }else {//能执行这一段代码说明至少有两个元素。确保前面的next不指向任何结点，让JVM释放
            head.last=null;
         }
         size--;
      }
      return value;
   }

   public V pollTail() {
      V value=null;
      if (tail!=null){
         value=tail.value;
         tail= tail.last;
         if (tail==null){
            head=null;
         }else{
            tail.next=null;
         }
         size--;
      }
      return value;
   }

   public V peekHead() {
      return head!=null?head.value:null;
   }

   public V peekTail() {
      return tail!=null? tail.value:null;
   }

}
```

## K个节点组内逆序调整

题目：链表分组，每组k个节点，组内逆序，不够k个的不管。也就是1->2->3->4->5->6->7->8->9->10，如果k为3，结果为3->2->1->6->5->4->9->8->7->10。

可以看到，这个函数一定是一个换头函数。因为头变了，变成了3。

![image-20220507134522616](./image\image-20220507134522616.png)

### 代码

```java
// 测试链接：https://leetcode.com/problems/reverse-nodes-in-k-group/
public class Code04_ReverseNodesInKGroup {

   // 不要提交这个类
   public static class ListNode {
      public int val;
      public ListNode next;

      public ListNode(int value){
         this.val=value;
         this.next=null;
      }
   }

   public static ListNode reverseKGroup(ListNode head, int k) {
      ListNode start=head;
      ListNode end=countK(head,k);
      head=end;
      ListNode last=null;//记录上一组的最后一个结点

      if (end==null){
         return head;
      }

      reverse(start,end);
      last=start;
      while(start.next!=null){
         start=start.next;
         end=countK(start,k);
         if (end==null){
            break;
         }
         reverse(start,end);
         last.next=end;
         last=start;
      }


      return head;
   }

   /**
    * 这个函数的功能就是从start结点开始（第一个结点），返回第k个节点。
    * @param start
    * @param k
    * @return
    */
   public static ListNode countK(ListNode start, int k) {
      while(start!=null&&k!=1){
         start= start.next;
         k--;
      }
      return start;
   }

   public static void reverse(ListNode start, ListNode end) {
      ListNode pre=end.next;
      end=end.next;
      ListNode next=null;
      while(start!=end){
         next=start.next;
         start.next=pre;
         pre=start;
         start=next;
      }
   }
}
```

reverse函数写成下面这个是不对的，因为start指针最后会运动到和end一样的地方，然后把end的next指针给改了。这样会导致end.next就不是原本的最后一个结点的下一个了，而是原本最后一个结点的前一个了。会导致start停不下来，一直往后走，导致空指针异常

```java
public static void reverse(ListNode start, ListNode end) {
      ListNode pre=end.next;
      end=end.next;
      ListNode next=null;
      while(start!=end){
         next=start.next;
         start.next=pre;
         pre=start;
         start=next;
      }
   }

public static void reverse(ListNode start, ListNode end) {
      ListNode pre=end.next;
      ListNode next=null;
      while(start!=end.next){
         next=start.next;
         start.next=pre;
         pre=start;
         start=next;
      }
   }
```

## 两个链表相加

- 题目：给定两个链表的头节点head1和head2,认为从左到右是某个数字从低位到高位，返回相加之后的链表例子：

  4 ->3-> 6		2->5-> 3

  返回6-> 8->9

思路：先选出比较长的那一个链表，然后逐位相加，直接改在长链表上。短链表不为空是第一个逻辑分支--long.value+short.value+carry，长链表不为空是第二个逻辑分支---long.value+carry。长短链表都结束了，检查是否有进位是第三个逻辑分支--carry。

### 代码

```java
// 测试链接：https://leetcode.com/problems/add-two-numbers/
public class Code05_AddTwoNumbers {

    // 不要提交这个类
    public static class ListNode {
        public int val;
        public ListNode next;

        public ListNode(int val) {
            this.val = val;
        }

        public ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    public static ListNode addTwoNumbers(ListNode head1, ListNode head2) {
        int len1 = listLength(head1);
        int len2 = listLength(head2);
        ListNode longList = len1 >= len2 ? head1 : head2;//longList为head1和head2中比较长的那个
        ListNode shortList = longList == head1 ? head2 : head1;//shortList为另外一个比较短的
        ListNode head = longList;//返回它
        ListNode longPre = longList;//指向长链表指针的前一个位置

        int carry = 0;
        int sum = 0;
        while (shortList != null) {
            sum = shortList.val + longList.val + carry;
            longList.val = sum % 10;
            carry = sum / 10;
            longPre = longList;
            longList = longList.next;
            shortList = shortList.next;
        }

        while (longList != null) {
            sum = longList.val + carry;
            longList.val = sum % 10;
            carry = sum / 10;
            longPre = longList;
            longList = longList.next;
        }

        if (carry != 0) {
            longPre.next = new ListNode(1);
        }

        return head;

    }

    // 求链表长度
    public static int listLength(ListNode head) {
        int len = 0;
         while (head != null) {
            len++;
            head = head.next;
        }
        return len;
    }
```



## 合并有序链表

- 题目：给定两个有序链表的头节点head1和head2,返回合并之后的大链表，要求依然有序

  例子：1->3 ->3->5 ->7			2 -> 2 -> 3->3->7

  返回：1->2 ->2->3->3->3->3->5->7->7

#### 代码

```java
// 测试链接：https://leetcode.com/problems/merge-two-sorted-lists
public class Code06_MergeTwoSortedLinkedList {

   // 不要提交这个类
   public static class ListNode {
      public int val;
      public ListNode next;
   }

   public static ListNode mergeTwoLists(ListNode head1, ListNode head2) {
      if (head1==null||head2==null){
         return head1!=null?head1:head2;
      }
      ListNode head=null;
      ListNode cur=null;
      if (head1.val<= head2.val){
          head=head1;
          head1= head1.next;
      }else {
         head=head2;
         head2= head2.next;
      }
      cur=head;
      while(head1!=null&& head2!=null){
         if (head1.val<= head2.val){
            cur.next=head1;
            head1= head1.next;
         }else {
            cur.next=head2;
            head2= head2.next;
         }
         cur= cur.next;
      }
      cur.next=head1!=null?head1:head2;
      return head;
   }

}
```

## 翻转链表

如果链表中不涉及到换头的操作就可以定义成void类型，如果涉及到了换头的操作，那么就需要有返回值。比如下面，123变成321返回的应该是以三为头。

![image-20220331132750894](./image\image-20220331132750894.png)

![image-20220331124446766](./image\image-20220331124446766.png)

### 代码

```JAVA
private static class Node {//单向链表
        public int value;
        public Node next;

        public Node(int data) {
            value = data;
        }
    }

    /**
     * 翻转单链表
     * @param head:单链表的头节点
     * @return
     */
    private static Node reverseList(Node head){
        Node pre=null,next=null;
        while(head!=null){//从第一个结点遍历到最后一个结点
            next=head.next;//保存下一个结点，以便于next迭代
            head.next=pre;//改变当前结点的next指针的指向，指向前一个结点pre.
            pre=head;//当前结点head在一次迭代之后就变成了pre。pre一开始是null
            head=next;//head迭代
        }
        return pre;//head迭代成null之后pre正好指向的就是原来链表最后一个结点，也就是现在的头节点
    }

    private static class DoubleNode {//双向链表结点
        public int value;
        public DoubleNode last;
        public DoubleNode next;

        public DoubleNode(int data) {
            value = data;
        }
    }

    /**
     * 翻转双向链表
     * @param head :双向链表的头节点
     * @return
     */
    private static DoubleNode reverseList(DoubleNode head){
        DoubleNode pre=null,next=null;//两个辅助指针，分别保存下一个结点和前一个结点
        while(head!=null){//从第一个结点遍历到最后一个结点
            next=head.next;//保存下一个结点，以便于next迭代
            //翻转当前结点的两个指针
            head.next=pre;
            head.last=next;

            pre=head;//迭代pre
            head=next;//迭代next
        }
        return pre;
    }
```



## 打印两个有序链表的公共部分

两个指针，谁小谁移动，相等打印，打印完成之后一起移动。有越界就停。

![image-20220331124452466](./image\image-20220331124452466.png)

### 代码

```JAVA
public static class Node {
        public int value;
        public Node next;
        public Node(int data) {
            this.value = data;
        }
    }

    /**
     * 打印两个链表的相同值
     * @param head1：链表1的头节点
     * @param head2：链表2的头节点
     */
    private static void printCommonPart(Node head1,Node head2){
        System.out.print("common part is ");
        while(head1!=null&&head2!=null){
            if (head1.value<head2.value)
                head1= head1.next;//谁小谁动
            else if (head2.value< head1.value)
                head2= head2.next;//谁小谁动
            else {//相等一起动
                System.out.print(head1.value+" ");
                head1= head1.next;
                head2= head2.next;
            }
        }
        System.out.println();
    }
```



## 链表方法论



![image-20220331124459052](./image\image-20220331124459052.png)

## 判断回文

![image-20220331124504468](./image\image-20220331124504468.png)

以node为最小单位判断回文。

笔试：把链表的值放到栈里面，然后从头遍历链表依次从栈中弹出比对。

现在问题是能不能省一点空间，我只把右半部分放进栈里？现在的问题是我怎么只把右半部分放入栈？单链表有一个缺点，就是我不能知道后面的情况，我只能一个一个往下走，所以这里我们只用一个指针是不能知道我指针到底处在链表的什么位置。这里有一个技巧----快慢指针。快指针一次走两步，慢指针一次走一步。快指针走完的时候慢指针会来到中点的位置，然后我们就可以把慢指针后面的东西都放入到栈里面去了。

要根据实际的需求自己去定制快慢指针，这只和边界条件的控制有关，和算法无关。实现这样的差别可能只需要快慢指针分别多走几步或者少走几步就可以实现，但是一定要写熟练。尤其在链表的规模在比较小的时候比如1,2,3个节点，这样的情况要分析是否需要特殊处理。

![image-20220331134743135](./image\image-20220331134743135.png)

利用格外的空间可以实现，但是这样一来就太简单了。如果不使用额外的空间要实现这样的功能怎么办？如何用有限几个变量去做到这点。慢指针指向中间的时候，把后面的指针全部改了，然后一个从头开始，一个从尾开始，一个一个比对，如果中间有其中一个不一样，那么就结束，如果有一个走到头了，那么就成功。完成之后再把链表再改回来。

![image-20220331135711966](./image\image-20220331135711966.png)

### 代码

```java
public static class Node {
        public int value;
        public Node next;

        public Node(int data) {
            this.value = data;
        }
    }

    private static boolean isPalindrome1(Node head){//暴力解法。利用栈逆序
        Stack<Node> stack=new Stack<>();
        Node temp=head;
        while(temp!=null){//压栈实现逆序
            stack.push(temp);
            temp= temp.next;
        }
        while(!stack.isEmpty()){//从栈中弹出比对
            if (stack.pop().value!=head.value)
                return false;
            head= head.next;
        }
        return true;
    }

    private static boolean isPalindrome2(Node head){
        if (head==null||head.next==null)// 确定至少有两个元素
            return true;
        Node n1=head.next;//定制快慢指针返回中和中右(2,2)
        Node n2=head.next;
        while(n2.next!=null&&n2.next.next!=null){//返回中和右中
            n2=n2.next.next;
            n1=n1.next;
        }
        //出循环，现在n1在对称轴右边
        Stack<Node>stack=new Stack<>();
        while(n1!=null){
            stack.push(n1);
            n1=n1.next;
        }
        while(!stack.isEmpty()){
            if (stack.pop().value!=head.value)
                return false;
            head=head.next;
        }
        return true;
    }

    private static boolean isPalindrome3(Node head){
        if (head==null||head.next==null)//0~1个结点直接返回true
            return true;
        Node fast=head.next;
        Node slow= head.next;//返回中和中右(2,2)
        while(fast.next!=null&&fast.next.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        Node tail=reverse(slow);//从尾巴出发，副作用为翻转slow以后的链表
        Node tail2=tail;
        Node h=head;//从头出发
        boolean res=true;
        while(tail!=null){//从n1这里开始因为偶数的时候右边比较短
            if (tail.value!= h.value){
                res= false;
                break;
            }
            tail=tail.next;
            h=h.next;
        }
        //恢复链表
        reverse(tail2);
        return res;
    }

    /**
     * 翻转以head为头节点的链表，并最终返回新的链表的头节点
     * @param head
     * @return
     */
    private static Node reverse(Node head){
        if (head==null||head.next==null) return head;
        Node pre=null,next=null;
        while(head!=null){
            next=head.next;
            head.next=pre;
            pre=head;
            head=next;
        }
        return pre;
    }
```



## 划分单链表

![image-20220331124512014](./image\image-20220331124512014.png)

笔试：把这一个一个结点放入到一个结点数组里面，然后在数组里面partition，然后再把数组里面的节点重新串起来。

面试：如果不用额外的空间呢？单链表的移动没有这么重，还可以保证稳定性。我们需要六个变量。![image-20220331141002416](./image\image-20220331141002416.png)

然后从链表的头开始遍历，一个一个和num进行比较，然后看对应区域的头和尾，如果两个都是空，那么说明这是第一个发现的结点，让头也指向这个结点尾也指向这个结点。然后如果再发现一个，就让尾结点指向这个结点，然后尾结点更新成这个结点。最后这三堆结点尾串头全部连起来就行。

### 代码

```java
public static class Node {
    public int value;
    public Node next;

    public Node(int data) {
        this.value = data;
    }
}

public static Node listPartition1(Node head, int pivot){
    Node temp=head;
    int num=0;
    while (temp!=null){//遍历统计链表的大小
        num++;
        temp=temp.next;
    }
    Node[] arr=new Node[num];
    temp=head;
    int i=0;
    while(temp!=null){
        arr[i++]=temp;
        temp=temp.next;
    }
    partition(arr,pivot);
    for (i=0;i<arr.length-1;i++){
        arr[i].next=arr[i+1];
    }
    arr[i].next=null;
    return arr[0];
}

private static void partition(Node[] arr, int pivot) {
    int less=-1;
    int more=arr.length;
    int index=0;
    while(index<more){
        if (arr[index].value<pivot){
            swap(arr,++less,index++);
        }else if (arr[index].value>pivot){
            swap(arr,--more,index);
        }else {
            index++;
        }
    }
}

private static void swap(Node[] arr, int a, int b) {
    Node temp=arr[a];
    arr[a]=arr[b];
    arr[b]=temp;
}

public static Node listPartition2(Node head, int pivot) {
    Node ss=null;
    Node se=null;
    Node es=null;
    Node ee=null;
    Node bs=null;
    Node be=null;
    while(head!=null){
        Node next=head.next;
        head.next=null;//如果不置空，可能会导大于链的最后一个结点和某一个其它结点连接形成闭环，导致无限循环
        if (head.value<pivot){
            if (ss==null){
                ss=head;
                se=head;
            }else{
                se.next=head;
                se=head;
            }
        }else if (head.value==pivot){
            if (es==null){
                es=head;
                ee=head;
            }else{
                ee.next=head;
                ee=head;
            }
        }else {
            if (bs==null){
                bs=head;
                be=head;
            }else {
                be.next=head;
                be=head;
            }
        }
        head=next;
    }
    //开始连接这三个链
    if (se!=null){//要对尾巴进行判断
        se.next=es;
        ee=ee==null?se:ee;
    }
    if (ee!=null){//都是对尾巴进行判断，因为是尾巴的next
        ee.next=bs;
    }
    return ss!=null?ss:es!=null?es:bs;
}
```

## 复制随机指针节点的链表

![image-20220331124518794](./image\image-20220331124518794.png)

利用hashmap，把老结点作为key，新的结点作为value。然后遍历老链表，利用老结点和新节点的对应关系可以拷贝过来。

如果不用hashmap？哈希表是通过结构来实现一一对应，让我们通过老结点可以找到对应的新节点。如果我们就把新节点放到老结点的next上，那么也可以实现一一对应。也就是我们遍历老链表，生成一个新节点，老的next指向新的。接着就再一次遍历，我们一对一对的调整新结点的random，调整完成再分离开。

<img src="./image\image-20220331143719079.png" alt="image-20220331143719079" style="zoom:50%;" />

### 代码

```java
public static class Node {
    public int value;
    public Node next;
    public Node rand;

    public Node(int data) {
        this.value = data;
    }
}

public static Node copyListWithRand1(Node head){
    Node p=head;
    HashMap<Node,Node> map=new HashMap<>();
    while(p!=null){
        map.put(p,new Node(p.value));
        p=p.next;
    }
    p=head;
    Node res=map.get(head);
    while(p!=null){
        map.get(p).next=map.get(p.next);
        map.get(p).rand=map.get(p.rand);
        p=p.next;
    }
    return res;
}

public static Node copyListWithRand2(Node head){
    if (head==null)
        return null;
    Node p=head;
    Node next;
    while(p!=null){
        next=p.next;//把p的后继存起来，后面要迭代
        p.next=new Node(p.value);
        p.next.next=next;
        p=next;
    }
    p=head;
    while(p!=null){//不涉及到破坏next链，一个p变量就可以搞定
        p.next.rand=p.rand==null?null:p.rand.next;
        p=p.next.next;//偶数个节点数，不会报错
    }
    p=head;
    Node p2,res;
    res=head.next;//保存新链头节点
    while(p!=null){
        next=p.next.next;//偶数个结点跳不出去
        p2=p.next;
        p.next=next;
        p2.next=next==null?null:next.next;
        p=next;
    }
    return res;
}
```

## 单链表相交

![image-20220331124524746](./image\image-20220331124524746.png)

这题不仅可以标记有没有相交，还有返回第一个相交的结点。相交的意思就是两个链表中有两个结点各自的内存地址是同一个。

这题首先要判断有环和无环，因为有环和无环处理起来应该是不一样的。怎么判断有环无环？我们想要实现这样一个函数，如果有环的话就返回第一个入环结点，如果无环就返回空。这样设计的话函数的含义要比返回布尔类型的函数含义要丰富一些。框起来的是第一个入环结点。<img src="./image\image-20220407134003558.png" alt="image-20220407134003558" style="zoom:50%;" />

如果我们使用额外的数据结构来做这件事情，那么我们只需要一个hashset，也就是一个集合。从头遍历链表，我们每到一个结点就先查一下set里面有没有这个元素，没有这个元素就放进去，如果集合里面有了这个元素，那么这个结点就是第一个入环结点。有环的结点一个是一个6的形状，因为链表一旦入环就不可能再出来了。

让快慢指针从head开始走，如果相遇了那么就说明有环，如果快指针走到头了就说明没有环。如果相遇了重置其中一个指针到head，再一个指针走一步，再次相遇的点就是第一个入环结点，证明如下。

![image-20220331124524746](./image\webwxgetmsgimg.jpg)

现在我们解决了链表是否有环的情况，现在我们解决相交问题。如果是两个无环单链表相交的话，那么就说明这两个链表**共有**从相交的结点到结尾的部分。![image-20220407145457253](./image\image-20220407145457253.png)

这样我们就分别遍历两个链表，分别记录两个链表的长度和最后一个结点，如果两个链表的最后一个结点相同那么说明他们相交了，如果不同就说明他们没有相交。然后我们让长链表的指针先走差值步，然后两个链表的指针一起走，最后一定会在相交的结点相遇。

如果一个链表有环一个链表无环的话，那么这两个链表一定不会相交！相交就代表公用，公用就一定会有环。

最后一种情况就是两个链表都有环。一个是不相交。相交分两种情况，一种是入环结点相同，一种是入环结点不同。但是相交的话有一个可以肯定，就是他们一定是同一个环。

第二种情况（loop1==loop2）可以归结为无环结点的相交问题。因为我们可以把loop1和loop2看成是终止结点，后面的环我们不管了。loop1和loop2分别是链表1和链表2的入环结点。（思考我们是否可以直接把loop.next=null，然后直接用前面写的函数。最后再接回来）。

情况1和情况3怎么办？1和3最大的区别就是环是不是公用的。如果环是公用的，那么loop1转一圈一定可以遇到loop2。这个时候返回loop1或者loop2都对。

<img src="./image\image-20220407151909441.png" alt="image-20220407151909441" style="zoom:50%;" />

### 代码

```java
public static class Node {
    public int value;
    public Node next;

    public Node(int data) {
        this.value = data;
    }
}

/**
 * 传进来两个链表要判断他们两个是否相交，由于这两个链表可能是循环链表也可能不是。所以我们要写一个函数来判断
 * 他们的类型。由于无环链表只能和无环链表相交，循环链表只能和循环链表相交，其中无环链表和循环链表不可能相交。
 * 所以我们这里就分成两种情况就行。
 *
 * @param head1
 * @param head2
 * @return
 */
public static Node getIntersectNode(Node head1, Node head2) {
    Node in1=getLoopNode(head1);//入环结点1
    Node in2=getLoopNode(head2);//入环结点2
    if (in1==null&&in2==null){
        return noLoop(head1,head2);
    }else if (in1!=null&&in2!=null){
        return bothLoop(head1,in1,head2,in2);
    }else {
        return null;
    }
}

public static Node getLoopNode(Node head) {
    if (head==null||head.next==null){
        return null;
    }
    Node p1=head.next.next;//快
    Node p2=head.next;//慢，都从下标为0的位置开始
    while(p1.next!=null&&p1.next.next!=null){
        if (p1==p2) {
            break;//说明是循环链表
        }
        p1=p1.next.next;
        p2=p2.next;
    }
    //判断是从哪一个分支出来
    if (p1==p2){
        p1=head;
        while(p1!=p2){
            p1=p1.next;
            p2=p2.next;
        }
        return p1;
    }else{//不是循环链表
        return null;
    }
}

public static Node noLoop(Node head1, Node head2) {
    if (head1==null||head2==null){
        return null;
    }
    Node p1=head1;
    Node p2=head2;
    int len=0;
    while(p1.next!=null){
        len++;
        p1=p1.next;
    }
    while(p2.next!=null){
        len--;
        p2=p2.next;
    }
    if (p1==p2){//说明有相交
        p1=head1;
        p2=head2;
        if(len>0){
            while(len>0){
                p1=p1.next;
                len--;
            }
        }else if (len<0){
            while(len<0){
                p2=p2.next;
                len++;
            }
        }
        while(p1!=p2){
            p1=p1.next;
            p2=p2.next;
        }
        return p1;
    }else{
        return null;
    }

}

public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
    Node p1=loop1;
    Node p2=loop2;
    if (p1==p2){//转化成两个单链的情况
        //把后面循环的部分拆掉最后再复原
        p1=loop1.next;
        p2=loop2.next;
        loop1.next=null;
        loop2.next=null;
        //调用之前写的函数算出res的值
        Node res=null;
        res=noLoop(head1,head2);
        //恢复后面的循环部分
        loop1.next=p1;
        loop2.next=p2;
        return res;
    }else{
        p1=loop1.next;
        while(p1!=loop1){
            if (p1==loop2){
                break;
            }
            p1=p1.next;
        }
        if (p1==loop2){//说明相交了
            return loop1;
        }else{//说明没有相交
            return null;
        }
    }

}
```

## 删除给定值

- 题目：给你一个链表和一个值val，删除这个链表里面所有值为val的结点

  例如：1->1->1->2->3->1->2->4->1,如果要删除的val为1

  结果：2->3->2->4

思路：先让head跳到第一个不等于val的位置，也就是2位置，然后利用cur指针向后一个一个遍历，利用pre记住上一个不等于val的结点。如果cur不等于val那么就往后跳。如果cur为val那么pre的next就指向cur的下一个结点，然后cur往后跳。

```java
public static class Node {
    public int value;
    public Node next;

    public Node(int data) {
        this.value = data;
    }
}

public static Node removeValue(Node head, int num) {
    while(head!=null){
        if (head.value!=num){
            break;
        }
        head= head.next;
    }
    //现在来到了第一个不用删除的非空结点
    Node pre=head;//记录前一个不用删除的结点
    Node cur=head;
    while(cur!=null){
        if (cur.value==num){
            pre.next=cur.next;
        }else {
            pre=cur;
        }
        cur=cur.next;
    }
    return head;
}
```



## 返回最小值的特殊栈

- 实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能
  1. pop、push、getMin操作的时间复杂度都是O(1)。
  2. 设计的栈类型可以使用现成的栈结构。

方法1：准备两个栈，第一个栈data就是正常的栈。第二个栈min，当前data栈的栈顶和min栈的栈顶，谁小加谁。data栈的最小栈同步上升。最小栈就记录着每一个高度，栈的最小值是什么。

方法2：也是两个栈，但是我只有在当前数比最小栈的栈顶小的时候才压入最小栈，大于的时候不压入。弹出的时候只有data栈和min栈的栈顶相等的时候才弹出。、

```java
public static class MyStack1 {
   private Stack<Integer> stackData;
   private Stack<Integer> stackMin;

   public MyStack1() {
      this.stackData = new Stack<Integer>();
      this.stackMin = new Stack<Integer>();
   }

   public void push(int newNum) {
      if (this.stackMin.isEmpty()) {
         this.stackMin.push(newNum);
      } else if (newNum <= this.getmin()) {
         this.stackMin.push(newNum);
      }
      this.stackData.push(newNum);
   }

   public int pop() {
      if (this.stackData.isEmpty()) {
         throw new RuntimeException("Your stack is empty.");
      }
      int value = this.stackData.pop();
      if (value == this.getmin()) {
         this.stackMin.pop();
      }
      return value;
   }

   public int getmin() {
      if (this.stackMin.isEmpty()) {
         throw new RuntimeException("Your stack is empty.");
      }
      return this.stackMin.peek();
   }
}

public static class MyStack2 {
   private Stack<Integer> stackData;
   private Stack<Integer> stackMin;

   public MyStack2() {
      this.stackData = new Stack<Integer>();
      this.stackMin = new Stack<Integer>();
   }

   public void push(int newNum) {
      if (this.stackMin.isEmpty()) {
         this.stackMin.push(newNum);
      } else if (newNum < this.getmin()) {
         this.stackMin.push(newNum);
      } else {
         int newMin = this.stackMin.peek();
         this.stackMin.push(newMin);
      }
      this.stackData.push(newNum);
   }

   public int pop() {
      if (this.stackData.isEmpty()) {
         throw new RuntimeException("Your stack is empty.");
      }
      this.stackMin.pop();
      return this.stackData.pop();
   }

   public int getmin() {
      if (this.stackMin.isEmpty()) {
         throw new RuntimeException("Your stack is empty.");
      }
      return this.stackMin.peek();
   }
}
```

## 使用栈结构实现队列

准备两个栈，一个栈是pop栈一个栈是push栈。我们把push栈里面的数导到pop栈里面，再从pop栈中弹出就实现了逆序。但是从push栈导入到pop栈要遵循几个原则：第一个原则就是只有pop栈为空的时候才能倒入pop栈。第二个原则，每次push栈往pop栈里面导数据的时候要一次性倒完。

```java
public static class TwoStacksQueue {
   public Stack<Integer> stackPush;
   public Stack<Integer> stackPop;

   public TwoStacksQueue() {
      stackPush = new Stack<Integer>();
      stackPop = new Stack<Integer>();
   }

   // push栈向pop栈倒入数据
   private void pushToPop() {
      if (stackPop.empty()) {
         while (!stackPush.empty()) {
            stackPop.push(stackPush.pop());
         }
      }
   }

   public void add(int pushInt) {
      stackPush.push(pushInt);
      pushToPop();
   }

   public int poll() {
      if (stackPop.empty() && stackPush.empty()) {
         throw new RuntimeException("Queue is empty!");
      }
      pushToPop();
      return stackPop.pop();
   }

   public int peek() {
      if (stackPop.empty() && stackPush.empty()) {
         throw new RuntimeException("Queue is empty!");
      }
      pushToPop();
      return stackPop.peek();
   }
}
```

## 使用队列实现栈

准备两个队列，一个队列data一个队列help。把前n-1个数导到help队列里面，打印第n个。下一次help和data身份互换就行。

```java
public static class TwoQueueStack<T> {
   public Queue<T> queue;
   public Queue<T> help;

   public TwoQueueStack() {
      queue = new LinkedList<>();
      help = new LinkedList<>();
   }

   public void push(T value) {
      queue.offer(value);
   }

   public T poll() {
      while (queue.size() > 1) {
         help.offer(queue.poll());
      }
      T ans = queue.poll();
      Queue<T> tmp = queue;
      queue = help;
      help = tmp;
      return ans;
   }

   public T peek() {
      while (queue.size() > 1) {
         help.offer(queue.poll());
      }
      T ans = queue.poll();
      help.offer(ans);
      Queue<T> tmp = queue;
      queue = help;
      help = tmp;
      return ans;
   }

   public boolean isEmpty() {
      return queue.isEmpty();
   }

}
```

## 定制快慢指针

奇数情况按照3个节点来看，偶数情况按照4个结点来看。从1开始计数

1. 奇数返回中点，偶数返回中右。这里奇数返回中点，所以我们一开始先把slow指向中间的结点（奇定慢）。因为在奇数的时候slow就要在2位置，所以fast只能在2或3位置。因为如果fast在1位置会跳到3位置，这样一来slow就到了3位置了。所以现在是slow在2位置，fast只能在2和3之中选一个。由于偶数返回中右，偶数的情况我们就想象有四个结点，此时slow要移动到3位置，也就意味着fast只能在2位置，这样fast从2移动到4，slow才有机会移动到3位置。(2,2)

2. 奇数返回中，所以slow起始位置在2。偶数返回左中（2位置），所以fast放在3位置影响不到slow。(2,3)
3. 奇数返回中前（1位置），所以slow起始位置为1。偶数返回右中前（也就是左中2），所以fast为2来影响slow移动.(1,2)
4. 奇数返回中前，所以slow起始位置为1.偶数返回左中前（1），所以fast在3位置，影响不了slow。(1,3)

在3个结点和4个结点的情况下设定好了slow和fast的位置之后，slow和fast可以同时退后，那么就同时退后。退后完了之后，fast在的位置就是至少要有的节点数。

1. (2,2)，至少要有两个结点，0~1个结点的情况要自己返回值。
2. (1,1)，至少要有一个结点，0个结点的情况要自己返回值。
3. (1,2)，至少要有两个结点，0~1个结点的情况要自己返回值。
4. (1,3)，至少要有三个结点，0~2个结点的情况要自己返回值。

![image-20220522145808532](./image\image-20220522145808532.png)

![image-20220915212828160](image/image-20220915212828160.png)

```java
public static class Node {
        public int value;
        public Node next;

        public Node(int value) {
            this.value = value;
        }
    }

    /**
     * 奇数返回中点，偶数返回左中。例如：1,2,3,4返回2  1,2,3,4,5返回3
     * slow放在2位置（从1开始计），fast放在3位置。通过if来手动返回节点数小于3的情况
     * @param head
     * @return
     */
    public static Node MidOrLeftMid(Node head) {//（2,3）-->(1,1)
        Node slow=head;
        Node fast=head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    /**
     * 奇数返回中点，偶数返回右中。例如：1,2,3,4返回3  1,2,3,4,5返回3
     * @param head
     * @return
     */
    public static Node MidOrRightMid(Node head) {//(2,2)-->(2,2)
        if (head==null||head.next==null) return head;//0~1个结点自己判断返回，有1个结点是有意义的
        Node slow=head.next;
        Node fast=head.next;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    /**
     * 奇数返回中点的前一个，偶数返回左中的前一个。例如：1,2,3,4返回1  1,2,3,4,5返回2
     * 至少要有3个结点，因为2结点的时候没有左中前
     * @param head
     * @return
     */
    public static Node MidPreOrLeftMidPre(Node head) {//(1,3)-->(1,3)
        if (head == null || head.next == null || head.next.next == null) {//保证了至少有三台结点,少于3个都是没有意义的。
            return null;
        }
        Node slow = head;//1位置
        Node fast = head.next.next;//slow最后要在左中前，fast不能影响slow，放在3位置
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    /**
     * 奇数返回中点的前一个，偶数返回右中的前一个。例如：1,2,3,4返回2  1,2,3,4,5返回2
     * @param head
     * @return
     */
    public static Node MidPreOrRightMidPre(Node head) {//(1,2)-->(1,2)
        if (head == null || head.next == null) {//至少要有两个结点,少于两个结点都是没有意义的
            return null;
        }
        Node slow = head;//1位置
        Node fast = head.next;//slow要动，fast要在2位置
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
```
