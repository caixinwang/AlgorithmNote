# 算法和数据结构体系学习

## 时间复杂度、空间复杂度、对数器和二分法

### 位运算

- **题目：打印一个数（可正可负）在底层的二进制存储形式。**

  **例如：-1打印1111···1111，总共32个1.**

根据下图可知，总体的思想就是利用1左移i位来得到掩码，利用掩码判断第i为是0还是1.利用for循环，循环32次就可以把一个int类型的数的二进制表示打印出来。

![image-20220504181522434](./image\image-20220504181522434.png)

### 代码

```java
public static void print(int num){
        for (int i=31;i>=0;i--){//i等于31，因为从高位开始
            System.out.print((num&(1<<i))==0?"0":"1");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        print(4165454);
    }
```

### 算法

所谓的算法就是解决一个具体问题的具体流程，还有一些评价这些流程的可量化的指标。

算法的分类：1. 明确知道怎么算的流程，比如3+4。 2. 明确知道怎么尝试的流程，比如求一个数的所有的因子。

- **题目：给定一个数N，返回1!+2!+...+N!**

看下面的代码可以很明显的看出两种不同的算法的优劣。

### 代码

```java
	/**
	 * 返回1！+2！+...+N!
	 * @param N
	 * @return
	 */
	public static long f1(int N) {
		int res=0;
		for (int i=N;i>=1;i--){
			res+=factorial(i);
		}
		return res;
	}

	/**
	 * 求N!
	 * @param N:求N！，也就是返回n*(n-1)*(n-2)*...*1
	 * @return
	 */
	public static long factorial(int N) {
		int res=1;
		for (int i=N;i>=1;i--){
			res*=i;
		}
		return res;
	}

	public static long f2(int N) {
		int res=0;
		int cur=1;
		for (int i=1;i<=N;i++){
			cur*=i;//cur每次都乘上i
			res+=cur;
		}
		return res;
	}

	public static void main(String[] args) {
		int N = 10;
		System.out.println(f1(N));
		System.out.println(f2(N));
	}
```

### Java中的Math.random()

1. 首先要知道Math.random()返回的是[0,1)范围中的一个double类型的数，因为double类型是有精度的，所以Math.random()的值域是一个有限集。
2. 显而易见，Math.random()* k，其中k是一个整数，那么Math.random() *k就返回一个[0,k)范围内的double类型的数
3. 在2的基础上如果我们对Math.random()* k取整，(int)(Math.random()* k)返回的就是一个[0,k-1]范围内的一个整数。
4. 因而我们如果需要随机返回一个[0,k]上的整数，我们只需要(int)(Math.random()* (k+1))

代码如下：

```java
int ans = (int) (Math.random() * K); // [0,K-1]
```

---

**题目：现在我们要写一个函数，使得任意的x∈[0,1)，[0,x)上的数出现的概率变为x²。**

解析一下为什么，如果现在要返回的数<0.3，那么说明两个Math.random()都要<0.3才行，也就是说这是两个独立的事件。也就是说最终的数要小于0.3的概率是0.3²。

```java
public static double xToXPower2() {
   return Math.max(Math.random(), Math.random());
}
```

同理，如果我们现在要让概率变成x³，那么就调用三次Math.random()，他们的最大值要<x。



---

**题目：现在我们有一个函数f，它可以在1-5上等概率返回一个整数，也就是1,2,3,4,5中等概率返回一个。现在我们要你只使用这个f函数，实现一个另一个函数g，这个函数可以从1-7上等概率返回一个。**

分析：如果我们可以实现一个01等概率发生器，那么我们可以利用01等概率发生器，等概率产生2的k次方个数---这个01等概率发生器调用k次即可。然后我们让范围之外的数回卷，让概率均摊在我们想要的数的范围上。如何实现这个01等概率发生器呢？我们只需要让12返回0,45返回1，如果是3那么就重新调用一遍f。

```java
// lib里的，不能改！
public static int f1() {
   return (int) (Math.random() * 5) + 1;
}

// 随机机制，只能用f1，
// 等概率返回0和1
public static int f2() {
   int ans = 0;
   do {//利用do-while循环进行赋值可以保证赋值的结果一定不等于3
      ans = f1();
   } while (ans == 3);
   return ans < 3 ? 0 : 1;
}

// 得到000 ~ 111 做到等概率 0 ~ 7等概率返回一个
public static int f3() {//调用三次01等概率发生器，产生的三个数分别作为二进制的第1-3位
   return (f2() << 2) + (f2() << 1) + f2();
}

// 0 ~ 6等概率返回一个
public static int f4() {
   int ans = 0;
   do {//利用do-while循环进行赋值可以保证赋值的结果一定不等于7，返回结果为0-6
      ans = f3();
   } while (ans == 7);
   return ans;
}

public static int g() {+1返回1-7
   return f4() + 1;
}
```



---

**通过上面那题，我们能不能实现由a-b的等概率发生器实现c-d的等概率发生器？**

可以的。我们假设a-b一共有奇数个数。那么我们就让中间的那个数重来。例如9-19的话就让(9+19)/2=14重来。然后do-while返回一个不等于14的数。接着如果ans<14就返回0，>14就返回1。这样我们就得到了一个01等概率发生器。然后我们实现一个0-(d-c)的等概率发生器，我们找到大于d-c的最大2次方。然后让大于d-c的数全部重算即可。

```java
/**
 * 这个函数23-43随机返回一个整数，先从0-20返回一个整数，再加上23
 * @return
 */
public static int randomInt23to43(){
   return (int)(Math.random()*(20+1))+23;
}

/**
 * 只利用randomInt23to43()函数，实现从16-39中随机返回一个整数.先实现0-23随机返回一个
 * @return
 */
public static int randomInt16to39(){
   int ans=0;
   do {
      ans=(generate01UsingRandomInt23to43()<<4)
            +(generate01UsingRandomInt23to43()<<3)
            +(generate01UsingRandomInt23to43()<<2)
            +(generate01UsingRandomInt23to43()<<1)
            +generate01UsingRandomInt23to43();
   }while(ans>23);
   return ans+16;
}

/**
 * 利用randomInt23to43实现01等概率发生器
 * @return
 */
public static int generate01UsingRandomInt23to43(){
   int ans=0;
   do {
      ans=randomInt23to43();
   }while(ans==(23+43)/2);//最终出来的ans一定不等于33
   return ans<33?0:1;
}
```



---

现在我们给你一个x函数，这个x函数不等概率的返回01，如何只利用这个x函数来构造一个y函数01等概率发生器？

我们现在调用两次，返回00和返回11的概率是不一样的。但是返回01和10的概率是一样的。所以我们只要是00或者11就重做，让概率均摊到10和01上就能实现01等概率发生器。

```java
// 你只能知道，x会以固定概率返回0和1，但是x的内容，你看不到！
public static int x() {
   return Math.random() < 0.84 ? 0 : 1;
}

// 等概率返回0和1
public static int y() {
   int ans = 0;
   do {
      ans = x();
   } while (ans == x());
   return ans;
}
```



### 动态数组

- 是什么？

规定长度不变的数组叫做固定数组。在java中有一个arrayList是一个动态数组，它也是数组。但是arraylist如果超出长度了就会进行扩容。会新开拓一个比之前长一倍的数组，然后把老数组里面的值拷贝下来。

- 扩容行为的代价？

扩容行为会不会影响ArrayList整体的表现？假设我们现在放入了n个数。那么在这期间扩容的代价是1+2+4+...+(2^k)，其中2^k是接近n的。所以整体的代价就是O(N)的。均摊到n个数，每个数放入的时候时间复杂度还是O(1).所以扩容行为对整体的性能影响不大。

### 异或运算

- 面试题（异或）：（1）在一个整型数组中只有一种数出现了奇数次，其它的所有数都出现了偶数次，怎么找到出现了奇数次的数？(2)在这个数组中如果有两种数出现了奇数次其它所有的数都出现了偶数次，怎么样找到这两种数？

> 要求时间复杂度O(N)，额外空间复杂度O(1).

- 第一问

很简单，把数组上的数从头异或到尾的结果就是唯一的出现奇数次的那个数。

```JAVA
public static void printOddTimesOneNumber(int[] arr){
        int eor=0;
        for(int i:arr)  eor^=i;//出来之后eor就是我们要的
        System.out.println(eor);
    }
```

- 第二问

```JAVA
public static void printOddTimesTwoNumber(int[] arr){
        int eor=0;
        for(int i:arr)  eor^=i;//出来之后eor=a^b
        /**
         * 我们异或了所有的数得到了eor=a^b，现在要分别得到a和b还缺少一个条件。
         * 一个思路就是不去异或所有的数，我们只异或一部分的数，并且这一部分只包含 a和b的其中一个
         * 方法是找出a与b不同的那一位，利用掩码将a和b划分成两个子集，每个子集异或进去可以达到a或者是b。
         * 问题关键来到如何找出a和b不同的那一位，事实上a^b为1的那些位都是a和b不同的位，这里我们找a^b最右边的1
         * 小结论：一个数和它的补码的与运算得到的就是最右边的那一位---想想补码是怎么求的
         */
        int mask=eor&(~eor+1);//得到了掩码
        int aORb=0,another=0 ;
        for(int i:arr)  {
            if((i&mask)==mask) aORb^=i;
        }
        another=eor^aORb;
        System.out.println(another+" "+aORb);
    }
```



### 二分法的详解与扩展

> 1）在一个有序数组中，找某个数是否存在
>
> 2）在一个有序数组中，找>=某个数最左侧的位置
>
> 3）局部最小值问题

#### 1）在一个有序数组中，找某个数是否存在

```java
public static boolean exist(int [] sortedArr,int num){
    if (sortedArr.length==0||sortedArr==null)
        return false;
    int left=0,right= sortedArr.length-1,mid;
    while(left <= right){
        mid=((right-left)>>1)+left;
        if (sortedArr[mid]>num)
            right=mid-1;
        else if (sortedArr[mid] < num)
            left=mid+1;
        else
            return true;
    }
    return false;
}
```

#### 2）在一个有序数组中，找>=某个数最左侧的位置

这一题和第一题的区别就是1第一题它找到了这个数（也就是满足==条件了）就返回。但是这一题当它找到了一个数>=满足条件了，还是不返回，还是接着去二分，总之一定会**二分到底**，一直到某个范围已经没有数了。

不是只有找一个数可以二分，找>=最左侧的数或者是<=最右侧的位置也可以二分

```java
private static int nearestIndex(int[] sortedArray,int num){//大于num的最小数字
    if (sortedArray==null&&sortedArray.length==0)
        return -1;
    int left=0,right=sortedArray.length-1,mid=0,index=-1;
     while(left<=right){
         mid=((right-left)>>1)+left;
         if (sortedArray[mid]>num){
             index=mid;
             right=mid-1;
         }
         else
             left=mid+1;
     }
     return index;//如果没有找到那么index就是等于-1
}
```



#### 3）局部最小值问题

局部最小值说的是这样一件事：在一个数组中，arr无序，但是告诉你任何两个相邻的数不相等。要求局部最小，局部最小就是比两边小（端点只要比一个小就行）。在这样的数组中我只求一个局部最小的位置。要求时间复杂度好于O(N)。

先判断首尾是不是局部最小，如果有其中一个是局部最小那么就直接返回。如果都不是局部最小，那么0位置处导数小于0，N-1位置的导数大于0，这里说导数不科学，但是方便理解。0-1是减的趋势，N-2~N-1是增加的趋势，中间一定有一个地方会从一开始减的趋势过渡到增的趋势。然后我从中间找一个位置，假设是M，如果M不是局部最小，那么就至少比左右两边其中一边要大，比左边大就递归左边，比右边大就递归右边。最终就可以找到局部最小。并不一定只有有序才能二分，要根据具体的数据状况，二分之后能不能归结到同一类问题来求解。

优化有两种情况：一种是数据状况、一种是问题流程。数据特殊你可以优化，问题特殊你也可以优化。当构建出排他性的时候就可以二分了，当你确定左右两边和你求的问题有关，并且确定可以甩掉一边（另一边一定有）。

```java
    private static int getLessIndex(int[] arr) {//这边的数组不要求是有序数组
        if (arr.length < 2 || arr == null)
            return -1;
        if (arr[0] < arr[1])
            return 0;
        if (arr[arr.length - 1] < arr[arr.length - 2])
            return arr.length - 1;
        //left和right设为1和len-2是为了防止后面判断局部最小的时候防止越界
        int left = 1, right = arr.length - 2, mid = 0;
        while (left <= right) {
            mid = ((right - left) >> 1) + left;
            if (arr[mid] > arr[mid + 1])
                left = mid + 1;
            else if (arr[mid] > arr[mid - 1])
                right = mid - 1;
            else
                return mid;
        }
        return -1;
    }
```

### 对数器

你实现了一个想测的方法a，有一个暴力的好实现的 方法b。生成一个随机样本产生器给你产生随机数据，产生的样本分别在a和b里面跑，比对结果。具体就是两段代码拿来对数器里面一直跑，跑个几万几十万次，两个结果一定要一样。如果跑出来都是一样的，那么就说明两个方法都对了。如果不对我可以调小范围， 在对数器里面增加打印来进行调试排除错误。

这种方法可以不依赖线上测试平台就能知道写的对不对

> 对数器的概念和使用
> 1，有一个你想要测的方法a
> 2，实现复杂度不好但是容易实现的方法b3，实现一个随机样本产生器
> 4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
> 5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b
> 6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

### Master公式

子问题 等规模的递归可以用master公式。

> 剖析递归行为和递归行为时间复杂度的估算 
>
> 用递归方法找一个数组中的最大值，系统上到底是怎么做的？ 
>
> master公式的使用 
>
> T(N) = a*T(N/b) + O(N^d) 
>
> log(b,a) > d -> 复杂度为O(N^log(b,a)) 
>
> log(b,a) = d -> 复杂度为O(N^d * logN)
>
> log(b,a) < d -> 复杂度为O(N^d) 
>
> 补充阅读:www.gocalf.com/blog/algorithm-complexity-and-master- theorem.html

![image-20220806174648529](image/image-20220806174648529.png)

返回数组某一个范围上的最大值的递归算法。

```java
public static int getMax(int[] arr) {
		return process(arr, 0, arr.length - 1);
	}
public static int process(int[] arr, int L, int R) {
   if (L == R) {
      return arr[L];
   }
   int mid = L + ((R - L) >> 1);
   int leftMax = process(arr, L, mid);
   int rightMax = process(arr, mid + 1, R);
   return Math.max(leftMax, rightMax);
}
```

### 认识复杂度

#### 常数操作

常数操作：数组的寻址，a=arr[i]。数组是随机存取，这边时间和数据规模无关，不管你ar有多大，算一个偏移就把数组里面的数拿出来了；加减乘除；位运算；

什么时候不是常数操作，假如有一个链表，我要得到链表i位置的值，int a=list.get(i)，那么这个就不是一个常数操作。链表要遍历去找。虽然逻辑上是线性结构，但是实际在物理上不是连续的。所以这是一个和数据量有关的操作。

和数据量无关的就是常数操作，否则就不是。

时间复杂度估计的指标在数学上就是上限。当数据量很大的时候，这个上限就成为了一个流程速度快慢的瓶颈。例如n²+99999999n+80，假如常数操作的表达式是这个，时间复杂度依然是O（n²）。

如果两个算法都是On的话就要拼常数项，但是不能只按照常数项来估计，因为同样是常熟操作，乘法操作和加法操作的时间是不一样的。所以用理论值无法估计，要实际去运行来确定哪个更好。虽然你估计出明确的常数数量，但是每一种常数操作的时间还是有差别的。

> 认识时间复杂度
>
> 常数时间的操作
>
> 一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。
>
> **时间复杂度为一个算法流程中，常数操作数量的一个指标**。常用0(读作big 0)来表示。具体来说，先要对一个算法流程非常熟悉，然后去**写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式**。
>
> 在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为0(f(N))。
>
> **评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。**

---

当你只需要有限几个变量就能完成算法，那么这个算法的额外空间复杂度就是O（1）。如果你需要申请一个和数据量等规模的数组的时候，那么这个算法的额外空间复杂度就是O(N)。

> 选择排序、冒泡排序细节的讲解与复杂度分析时间复杂度O(N^2)，额外空间复杂度0(1)



### 比较器

Java有一个比较器接口，我们可以去完成这个接口来设计一个比较器的对象。把比较器对象传进java自带的排序函数里面即可。返回负数第一个排前面，正数第二个排前面，0的话无所谓先后。Java的比较器等同于cpp的重载运算符。

这是降序。如果是O1在前面就是升序了。传a，b------如果return b-a那么堆就变成了最大堆了。

![image-20220327154954100](./image\image-20220327154954100.png)

> 1）比较器的实质就是重载比较运算符 
>
> 2）比较器可以很好的应用在特殊标准的排序上 
>
> 3）比较器可以很好的应用在根据特殊标准排序的结构上



### 哈希表

hashmap的put方法可以是增加也可以是更新，更新的是value。同样的hashmap也可以remove一个key，把key连同它的value一起删掉。哈希表在使用的时候认为时间复杂度都是常数级别---但是这个常数比较大。哈希表map和set都是一个东西，无非就是带不带value。

java里面是按值传递，你往里面放一个key，它会拷贝一份放进去。你自己创建的对象就是拷贝它的引用--内存地址进去。

![image-20220331124412199](./image\image-20220331124412199.png)

### 有序表

在Java里面叫做，treemap和treeset。map和set的区别就在于key带不带伴随。有序表的意思就是内部按照key来组织有序的。也就是哈希表能实现的功能有序表都能实现，而且有序表还能根据key有序这件事有新的功能--增加了一些新的API。性能上比哈希表要差一点，哈希表不管是什么数据量，增删改查都是常数级别的。但是有序表增删改查都是logN级别的。

放入有序表的东西，如果不是基础类型，必须要提供比较器，因为有序表需要利用到比较。

![image-20220331124419872](./image\image-20220331124419872.png)

### 有序表的操作

![image-20220331124427586](./image\image-20220331124427586.png)

## 链表

#### 利用链表实现队列和栈

###### 代码

```java
public static class Node<V>{
   public V value;
   public Node<V> next;

   public Node(V value){
      this.value=value;
   }
}

public static class MyQueue<V>{
   public Node<V> head;//从头出
   public Node<V> tail;//从尾进
   public int size;

   public MyQueue(){
      head=null;
      tail=null;
      size=0;
   }

   public int size(){
      return size;
   }

   public boolean isEmpty(){
      return size==0;
   }

   public void EnQueue(V value){
      Node<V> node=new Node<>(value);
      if (tail==null){
         head=node;
         tail=node;
      }else {
         tail.next=node;
         tail=node;
      }
      size++;
   }

   public V DeQueue(){
      V ans=null;
      if (head!=null){
         ans=head.value;
         head=head.next;
         size--;
      }
      if (head==null){
         tail=null;
      }
      return ans;
   }

   public V peek(){
      V ans=null;
      if (head!=null){
         ans=head.value;
      }
      return ans;
   }
}

/**
 * 栈用头插来实现。从头部出
 * @param <V>
 */
public static class MyStack<V>{
   Node<V> head;
   int size;

   public MyStack(){
      head=null;
      size=0;
   }

   public boolean isEmpty(){
      return 0==size;
   }

   public int size() {
      return size;
   }

   public void push(V value){
      Node<V> node=new Node<>(value);
      if (head==null){
         head=node;
      }else {
         node.next=head;
         head=node;
      }
      size++;
   }

   public V pop(){
      V value=null;
      if (head!=null){
         value=head.value;
         head=head.next;
         size--;
      }
      return value;
   }

   public V peek(){
      return head!=null?head.value:null;
   }

}
```

#### 利用双向链表实现双向入队出队的队列

###### 代码

```java
public static class Node<V> {
   public V value;
   public Node<V> last;
   public Node<V> next;

   public Node(V v) {
      value = v;
      last = null;
      next = null;
   }
}

public static class MyDeque<V> {
   private Node<V> head;
   private Node<V> tail;
   private int size;

   public MyDeque() {
      head = null;
      tail = null;
      size = 0;
   }

   public boolean isEmpty() {
      return size == 0;
   }

   public int size() {
      return size;
   }

   public void pushHead(V value) {
      Node<V> node = new Node<>(value);
      if (head == null) {
         head = node;
         tail = node;
      } else {
         node.next = head;
         head.last = node;
         head=head.last;
      }
      size++;
   }

   public void pushTail(V value) {
      Node<V> node=new Node<>(value);
      if (head==null){
         head=node;
         tail=node;
      }else{
         tail.next=node;
         node.last=tail;
         tail= tail.next;
      }
      size++;
   }

   public V pollHead() {
      V value=null;
      if (head!=null){//至少有1个元素
         value= head.value;//把值存下来
         head= head.next;//head后移
         if (head==null){//防止下面出现空指针异常，进入这个if语句说明只有一个元素
            tail=null;
         }else {//能执行这一段代码说明至少有两个元素。确保前面的next不指向任何结点，让JVM释放
            head.last=null;
         }
         size--;
      }
      return value;
   }

   public V pollTail() {
      V value=null;
      if (tail!=null){
         value=tail.value;
         tail= tail.last;
         if (tail==null){
            head=null;
         }else{
            tail.next=null;
         }
         size--;
      }
      return value;
   }

   public V peekHead() {
      return head!=null?head.value:null;
   }

   public V peekTail() {
      return tail!=null? tail.value:null;
   }

}
```

#### K个节点组内逆序调整

题目：链表分组，每组k个节点，组内逆序，不够k个的不管。也就是1->2->3->4->5->6->7->8->9->10，如果k为3，结果为3->2->1->6->5->4->9->8->7->10。

可以看到，这个函数一定是一个换头函数。因为头变了，变成了3。

![image-20220507134522616](./image\image-20220507134522616.png)

![image-20220920150847056](image/image-20220920150847056.png)

###### 代码

```java
// 测试链接：https://leetcode.com/problems/reverse-nodes-in-k-group/
public class Code04_ReverseNodesInKGroup {

   // 不要提交这个类
   public static class ListNode {
      public int val;
      public ListNode next;

      public ListNode(int value){
         this.val=value;
         this.next=null;
      }
   }

   public static ListNode reverseKGroup(ListNode head, int k) {
      ListNode start=head;
      ListNode end=countK(head,k);
      head=end;
      ListNode last=null;//记录上一组的最后一个结点

      if (end==null){
         return head;
      }

      reverse(start,end);
      last=start;
      while(start.next!=null){
         start=start.next;
         end=countK(start,k);
         if (end==null){
            break;
         }
         reverse(start,end);
         last.next=end;
         last=start;
      }


      return head;
   }

   /**
    * 这个函数的功能就是从start结点开始（第一个结点），返回第k个节点。
    * @param start
    * @param k
    * @return
    */
   public static ListNode countK(ListNode start, int k) {
      while(start!=null&&k!=1){
         start= start.next;
         k--;
      }
      return start;
   }

   public static void reverse(ListNode start, ListNode end) {
      ListNode pre=end.next;
      end=end.next;
      ListNode next=null;
      while(start!=end){
         next=start.next;
         start.next=pre;
         pre=start;
         start=next;
      }
   }
}
```

reverse函数写成下面这个是不对的，因为start指针最后会运动到和end一样的地方，然后把end的next指针给改了。这样会导致end.next就不是原本的最后一个结点的下一个了，而是原本最后一个结点的前一个了。会导致start停不下来，一直往后走，导致空指针异常

```java
public static void reverse(ListNode start, ListNode end) {
      ListNode pre=end.next;
      end=end.next;
      ListNode next=null;
      while(start!=end){
         next=start.next;
         start.next=pre;
         pre=start;
         start=next;
      }
   }

public static void reverse(ListNode start, ListNode end) {
      ListNode pre=end.next;
      ListNode next=null;
      while(start!=end.next){
         next=start.next;
         start.next=pre;
         pre=start;
         start=next;
      }
   }
```

#### 两个链表相加

- 题目：给定两个链表的头节点head1和head2,认为从左到右是某个数字从低位到高位，返回相加之后的链表例子：

  4 ->3-> 6		2->5-> 3

  返回6-> 8->9

思路：先选出比较长的那一个链表，然后逐位相加，直接改在长链表上。短链表不为空是第一个逻辑分支--long.value+short.value+carry，长链表不为空是第二个逻辑分支---long.value+carry。长短链表都结束了，检查是否有进位是第三个逻辑分支--carry。

###### 代码

```java
// 测试链接：https://leetcode.com/problems/add-two-numbers/
public class Code05_AddTwoNumbers {

    // 不要提交这个类
    public static class ListNode {
        public int val;
        public ListNode next;

        public ListNode(int val) {
            this.val = val;
        }

        public ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    public static ListNode addTwoNumbers(ListNode head1, ListNode head2) {
        int len1 = listLength(head1);
        int len2 = listLength(head2);
        ListNode longList = len1 >= len2 ? head1 : head2;//longList为head1和head2中比较长的那个
        ListNode shortList = longList == head1 ? head2 : head1;//shortList为另外一个比较短的
        ListNode head = longList;//返回它
        ListNode longPre = longList;//指向长链表指针的前一个位置

        int carry = 0;
        int sum = 0;
        while (shortList != null) {
            sum = shortList.val + longList.val + carry;
            longList.val = sum % 10;
            carry = sum / 10;
            longPre = longList;
            longList = longList.next;
            shortList = shortList.next;
        }

        while (longList != null) {
            sum = longList.val + carry;
            longList.val = sum % 10;
            carry = sum / 10;
            longPre = longList;
            longList = longList.next;
        }

        if (carry != 0) {
            longPre.next = new ListNode(1);
        }

        return head;

    }

    // 求链表长度
    public static int listLength(ListNode head) {
        int len = 0;
         while (head != null) {
            len++;
            head = head.next;
        }
        return len;
    }
```



#### 合并有序链表

- 题目：给定两个有序链表的头节点head1和head2,返回合并之后的大链表，要求依然有序

  例子：1->3 ->3->5 ->7			2 -> 2 -> 3->3->7

  返回：1->2 ->2->3->3->3->3->5->7->7

######## 代码

```java
// 测试链接：https://leetcode.com/problems/merge-two-sorted-lists
public class Code06_MergeTwoSortedLinkedList {

   // 不要提交这个类
   public static class ListNode {
      public int val;
      public ListNode next;
   }

   public static ListNode mergeTwoLists(ListNode head1, ListNode head2) {
      if (head1==null||head2==null){
         return head1!=null?head1:head2;
      }
      ListNode head=null;
      ListNode cur=null;
      if (head1.val<= head2.val){
          head=head1;
          head1= head1.next;
      }else {
         head=head2;
         head2= head2.next;
      }
      cur=head;
      while(head1!=null&& head2!=null){
         if (head1.val<= head2.val){
            cur.next=head1;
            head1= head1.next;
         }else {
            cur.next=head2;
            head2= head2.next;
         }
         cur= cur.next;
      }
      cur.next=head1!=null?head1:head2;
      return head;
   }

}
```

#### 翻转链表

如果链表中不涉及到换头的操作就可以定义成void类型，如果涉及到了换头的操作，那么就需要有返回值。比如下面，123变成321返回的应该是以三为头。

![image-20220331132750894](./image\image-20220331132750894.png)

![image-20220331124446766](./image\image-20220331124446766.png)

###### 代码

```JAVA
private static class Node {//单向链表
        public int value;
        public Node next;

        public Node(int data) {
            value = data;
        }
    }

    /**
     * 翻转单链表
     * @param head:单链表的头节点
     * @return
     */
    private static Node reverseList(Node head){
        Node pre=null,next=null;
        while(head!=null){//从第一个结点遍历到最后一个结点
            next=head.next;//保存下一个结点，以便于next迭代
            head.next=pre;//改变当前结点的next指针的指向，指向前一个结点pre.
            pre=head;//当前结点head在一次迭代之后就变成了pre。pre一开始是null
            head=next;//head迭代
        }
        return pre;//head迭代成null之后pre正好指向的就是原来链表最后一个结点，也就是现在的头节点
    }

    private static class DoubleNode {//双向链表结点
        public int value;
        public DoubleNode last;
        public DoubleNode next;

        public DoubleNode(int data) {
            value = data;
        }
    }

    /**
     * 翻转双向链表
     * @param head :双向链表的头节点
     * @return
     */
    private static DoubleNode reverseList(DoubleNode head){
        DoubleNode pre=null,next=null;//两个辅助指针，分别保存下一个结点和前一个结点
        while(head!=null){//从第一个结点遍历到最后一个结点
            next=head.next;//保存下一个结点，以便于next迭代
            //翻转当前结点的两个指针
            head.next=pre;
            head.last=next;

            pre=head;//迭代pre
            head=next;//迭代next
        }
        return pre;
    }
```



#### 打印两个有序链表的公共部分

两个指针，谁小谁移动，相等打印，打印完成之后一起移动。有越界就停。

![image-20220331124452466](./image\image-20220331124452466.png)

###### 代码

```JAVA
public static class Node {
        public int value;
        public Node next;
        public Node(int data) {
            this.value = data;
        }
    }

    /**
     * 打印两个链表的相同值
     * @param head1：链表1的头节点
     * @param head2：链表2的头节点
     */
    private static void printCommonPart(Node head1,Node head2){
        System.out.print("common part is ");
        while(head1!=null&&head2!=null){
            if (head1.value<head2.value)
                head1= head1.next;//谁小谁动
            else if (head2.value< head1.value)
                head2= head2.next;//谁小谁动
            else {//相等一起动
                System.out.print(head1.value+" ");
                head1= head1.next;
                head2= head2.next;
            }
        }
        System.out.println();
    }
```



#### 链表方法论



![image-20220331124459052](./image\image-20220331124459052.png)

#### 判断回文

![image-20220331124504468](./image\image-20220331124504468.png)

以node为最小单位判断回文。

笔试：把链表的值放到栈里面，然后从头遍历链表依次从栈中弹出比对。

现在问题是能不能省一点空间，我只把右半部分放进栈里？现在的问题是我怎么只把右半部分放入栈？单链表有一个缺点，就是我不能知道后面的情况，我只能一个一个往下走，所以这里我们只用一个指针是不能知道我指针到底处在链表的什么位置。这里有一个技巧----快慢指针。快指针一次走两步，慢指针一次走一步。快指针走完的时候慢指针会来到中点的位置，然后我们就可以把慢指针后面的东西都放入到栈里面去了。

要根据实际的需求自己去定制快慢指针，这只和边界条件的控制有关，和算法无关。实现这样的差别可能只需要快慢指针分别多走几步或者少走几步就可以实现，但是一定要写熟练。尤其在链表的规模在比较小的时候比如1,2,3个节点，这样的情况要分析是否需要特殊处理。

![image-20220331134743135](./image\image-20220331134743135.png)

利用格外的空间可以实现，但是这样一来就太简单了。如果不使用额外的空间要实现这样的功能怎么办？如何用有限几个变量去做到这点。慢指针指向中间的时候，把后面的指针全部改了，然后一个从头开始，一个从尾开始，一个一个比对，如果中间有其中一个不一样，那么就结束，如果有一个走到头了，那么就成功。完成之后再把链表再改回来。

![image-20220331135711966](./image\image-20220331135711966.png)

###### 代码

```java
public static class Node {
        public int value;
        public Node next;

        public Node(int data) {
            this.value = data;
        }
    }

    private static boolean isPalindrome1(Node head){//暴力解法。利用栈逆序
        Stack<Node> stack=new Stack<>();
        Node temp=head;
        while(temp!=null){//压栈实现逆序
            stack.push(temp);
            temp= temp.next;
        }
        while(!stack.isEmpty()){//从栈中弹出比对
            if (stack.pop().value!=head.value)
                return false;
            head= head.next;
        }
        return true;
    }

    private static boolean isPalindrome2(Node head){
        if (head==null||head.next==null)// 确定至少有两个元素
            return true;
        Node n1=head.next;//定制快慢指针返回中和中右(2,2)
        Node n2=head.next;
        while(n2.next!=null&&n2.next.next!=null){//返回中和右中
            n2=n2.next.next;
            n1=n1.next;
        }
        //出循环，现在n1在对称轴右边
        Stack<Node>stack=new Stack<>();
        while(n1!=null){
            stack.push(n1);
            n1=n1.next;
        }
        while(!stack.isEmpty()){
            if (stack.pop().value!=head.value)
                return false;
            head=head.next;
        }
        return true;
    }

    private static boolean isPalindrome3(Node head){
        if (head==null||head.next==null)//0~1个结点直接返回true
            return true;
        Node fast=head.next;
        Node slow= head.next;//返回中和中右(2,2)
        while(fast.next!=null&&fast.next.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        Node tail=reverse(slow);//从尾巴出发，副作用为翻转slow以后的链表
        Node tail2=tail;
        Node h=head;//从头出发
        boolean res=true;
        while(tail!=null){//从n1这里开始因为偶数的时候右边比较短
            if (tail.value!= h.value){
                res= false;
                break;
            }
            tail=tail.next;
            h=h.next;
        }
        //恢复链表
        reverse(tail2);
        return res;
    }

    /**
     * 翻转以head为头节点的链表，并最终返回新的链表的头节点
     * @param head
     * @return
     */
    private static Node reverse(Node head){
        if (head==null||head.next==null) return head;
        Node pre=null,next=null;
        while(head!=null){
            next=head.next;
            head.next=pre;
            pre=head;
            head=next;
        }
        return pre;
    }
```



#### 划分单链表（左边小、中间相等、右边大）

![image-20220331124512014](./image\image-20220331124512014.png)

笔试：把这一个一个结点放入到一个结点数组里面，然后在数组里面partition，然后再把数组里面的节点重新串起来。

面试：如果不用额外的空间呢？单链表的移动没有这么重，还可以保证稳定性。我们需要六个变量。![image-20220331141002416](./image\image-20220331141002416.png)

然后从链表的头开始遍历，一个一个和num进行比较，然后看对应区域的头和尾，如果两个都是空，那么说明这是第一个发现的结点，让头也指向这个结点尾也指向这个结点。然后如果再发现一个，就让尾结点指向这个结点，然后尾结点更新成这个结点。最后这三堆结点尾串头全部连起来就行。

###### 代码

```java
public static class Node {
        public int value;
        public Node next;

        public Node(int data) {
            this.value = data;
        }
    }

    public static Node listPartition1(Node head, int pivot){
        Node temp=head;
        int num=0;
        while (temp!=null){//遍历统计链表的大小
            num++;
            temp=temp.next;
        }
        Node[] arr=new Node[num];
        temp=head;
        int i=0;
        while(temp!=null){
            arr[i++]=temp;
            temp=temp.next;
        }
        for (i=0;i<arr.length-1;i++){
            arr[i].next=arr[i+1];
        }
        arr[i].next=null;
        return arr[0];
    }

    private static void partition(Node[] arr, int pivot) {
        int less=-1;
        int more=arr.length;
        int index=0;
        while(index<more){
            if (arr[index].value<pivot){
                swap(arr,++less,index++);
            }else if (arr[index].value>pivot){
                swap(arr,--more,index);
            }else {
                index++;
            }
        }
    }

    private static void swap(Node[] arr, int a, int b) {
        Node temp=arr[a];
        arr[a]=arr[b];
        arr[b]=temp;
    }

    /**
     *思路：创建三个单向链表，分别用来存储小于、等于、大于的。这样一来就要三个头节点，但是为了速度更快，不需要每次都遍历到尾结点，所以
     *     我们对于每个单向链表还额外增加了一个尾结点。这样一来最后拼接三个链表就很容易，而且中途增加新节点也很容易。创建完了三个单链表
     *     以后，我们从头遍历链表，每次孤立一个结点。孤立一个结点指的是让这个结点和后面的结点脱离联系，也就是让这个结点的next指针置为null
     * @param head:head为头的单向链表
     * @param pivot:以pivot作为划分值，把单向链表划分成三段
     * @return
     */
    public static Node listPartition2(Node head, int pivot) {
        Node ss=null,se=null,es=null,ee=null,bs=null,be=null;
        while(head!=null){
            Node next=head.next;
            head.next=null;//孤立这个结点。如果不置空，可能会导致大于链的最后一个结点和某一个其它结点连接形成闭环，导致无限循环。
            if (head.value<pivot){
                add(ss,se,head);//重新写成一个方法
            }else if (head.value==pivot){
                add(es,ee,head);
            }else {
                add(bs,be,head);
            }
            head=next;
        }
        //开始连接这三个链。如果小于链有东西，就让小于链的末尾连接等于链，然后更新小于链的尾结点，因为最后我们是返回小于链、等于链，大于链
        //中第一个非空链的头节点。
        if (ss!=null){//小于链有东西，最后肯定返回小于链---我们在小于链的我们串上东西
            se.next=es;//小于链末尾连上等于链的头。
            se=es==null?se:ee;//如果等于链为空小于链的尾就不更新，而如果等于链不为空就换成等于链的尾
            se.next=bs;//接着连上大于链的头，现在可以返回了
            return ss;
        }
        if (es!=null){//潜台词是小于链已经为空了，最后直接返回等于链的头
            ee.next=bs;
            return es;
        }
        return bs;
    }

    /**
     *
     * @param head:
     * @param tail:
     * @param val:将val结点加到以head为头，tail为尾的单链表上
     */
    private static void add(Node head,Node tail,Node val){
        if (head==null){//蕴含着tail也为null
            head=val;
            tail=val;
        }else {
            tail.next=val;
            tail=tail.next;
        }
    }
```

#### 复制随机指针节点的链表

![image-20220331124518794](./image\image-20220331124518794.png)

利用hashmap，把老结点作为key，新的结点作为value。然后遍历老链表，利用老结点和新节点的对应关系可以拷贝过来。

如果不用hashmap？哈希表是通过结构来实现一一对应，让我们通过老结点可以找到对应的新节点。如果我们就把新节点放到老结点的next上，那么也可以实现一一对应。也就是我们遍历老链表，生成一个新节点，老的next指向新的。接着就再一次遍历，我们一对一对的调整新结点的random，调整完成再分离开。

<img src="./image\image-20220331143719079.png" alt="image-20220331143719079" style="zoom:50%;" />

###### 代码

```java
public static class Node {
        public int value;
        public Node next;
        public Node rand;

        public Node(int data) {
            this.value = data;
        }
    }

    public static Node copyListWithRand1(Node head){
        Node p=head;
        HashMap<Node,Node> map=new HashMap<>();
        while(p!=null){
            map.put(p,new Node(p.value));
            p=p.next;
        }
        p=head;
        Node res=map.get(head);
        while(p!=null){
            map.get(p).next=map.get(p.next);
            map.get(p).rand=map.get(p.rand);
            p=p.next;
        }
        return res;
    }

    public static Node copyListWithRand2(Node head){
        if (head==null)
            return null;
        Node p=head;
        Node next;
        while(p!=null){//在每一个老结点的后面插上对应的新结点，插入完成以后链表的长度一定为偶数，2N
            next=p.next;//把p的后继存起来，后面要迭代
            p.next=new Node(p.value);
            p.next.next=next;//让新节点指向老结点的下一个
            p=next;
        }
        p=head;
        while(p!=null){//不涉及到破坏next链，一个p变量就可以搞定
            p.next.rand=p.rand==null?null:p.rand.next;//p.next代表新结点x，老结点的random指向另一个老结点y，y.next就是对应的新结点
            p=p.next.next;//下一个老结点。偶数个节点数，不会报错
        }
        p=head;
        Node p2,res;
        res=head.next;//保存新链头节点
        while(p!=null){//分离新老结点。奇偶结点分离
            next=p.next.next;//老结点。偶数个结点跳不出去
            p2=p.next;//新结点
            p.next=next;//老结点和老结点相连
            p2.next=next==null?null:next.next;
            p=next;
        }
        return res;
    }
```

#### 单链表相交

![image-20220331124524746](./image\image-20220331124524746.png)

这题不仅可以标记有没有相交，还有返回第一个相交的结点。相交的意思就是两个链表中有两个结点各自的内存地址是同一个。

这题首先要判断有环和无环，因为有环和无环处理起来应该是不一样的。怎么判断有环无环？我们想要实现这样一个函数，如果有环的话就返回第一个入环结点，如果无环就返回空。这样设计的话函数的含义要比返回布尔类型的函数含义要丰富一些。框起来的是第一个入环结点。<img src="./image\image-20220407134003558.png" alt="image-20220407134003558" style="zoom:50%;" />

如果我们使用额外的数据结构来做这件事情，那么我们只需要一个hashset，也就是一个集合。从头遍历链表，我们每到一个结点就先查一下set里面有没有这个元素，没有这个元素就放进去，如果集合里面有了这个元素，那么这个结点就是第一个入环结点。有环的结点一个是一个6的形状，因为链表一旦入环就不可能再出来了。

让快慢指针从head开始走，如果相遇了那么就说明有环，如果快指针走到头了就说明没有环。如果相遇了重置其中一个指针到head，再一个指针走一步，再次相遇的点就是第一个入环结点，证明如下。

![image-20220331124524746](./image\webwxgetmsgimg.jpg)

现在我们解决了链表是否有环的情况，现在我们解决相交问题。如果是两个无环单链表相交的话，那么就说明这两个链表**共有**从相交的结点到结尾的部分。![image-20220407145457253](./image\image-20220407145457253.png)

这样我们就分别遍历两个链表，分别记录两个链表的长度和最后一个结点，如果两个链表的最后一个结点相同那么说明他们相交了，如果不同就说明他们没有相交。然后我们让长链表的指针先走差值步，然后两个链表的指针一起走，最后一定会在相交的结点相遇。

如果一个链表有环一个链表无环的话，那么这两个链表一定不会相交！相交就代表公用，公用就一定会有环。

最后一种情况就是两个链表都有环。一个是不相交。相交分两种情况，一种是入环结点相同，一种是入环结点不同。但是相交的话有一个可以肯定，就是他们一定是同一个环。

第二种情况（loop1==loop2）可以归结为无环结点的相交问题。因为我们可以把loop1和loop2看成是终止结点，后面的环我们不管了。loop1和loop2分别是链表1和链表2的入环结点。（思考我们是否可以直接把loop.next=null，然后直接用前面写的函数。最后再接回来）。

情况1和情况3怎么办？1和3最大的区别就是环是不是公用的。如果环是公用的，那么loop1转一圈一定可以遇到loop2。这个时候返回loop1或者loop2都对。

<img src="./image\image-20220407151909441.png" alt="image-20220407151909441" style="zoom:50%;" />

###### 代码

```java
public static class Node {
        public int value;
        public Node next;

        public Node(int data) {
            this.value = data;
        }
    }

    /**
     * 传进来两个链表要判断他们两个是否相交，由于这两个链表可能是循环链表也可能不是。所以我们要写一个函数来判断
     * 他们的类型。由于无环链表只能和无环链表相交，循环链表只能和循环链表相交，其中无环链表和循环链表不可能相交。
     * 所以我们这里就分成两种情况就行。
     *
     * @param head1
     * @param head2
     * @return
     */
    public static Node getIntersectNode(Node head1, Node head2) {
        Node in1=getLoopNode(head1);//入环结点1
        Node in2=getLoopNode(head2);//入环结点2
        if (in1==null&&in2==null){
            return noLoop(head1,head2);
        }else if (in1!=null&&in2!=null){
            return bothLoop(head1,in1,head2,in2);
        }else {
            return null;
        }
    }

    /**
     * @param head:判断以head为头的链表是不是循环链表
     * @return :是循环链表返回第一个入环结点，否则返回null
     */
    public static Node getLoopNode(Node head) {
        if (head==null||head.next==null){//可能有单节点自己循环,head.next==head
            return null;
        }
        Node p1=head.next.next;//快，这里不能设置成head，因为有p1与p2的判断
        Node p2=head.next;//慢，都从下标为0的位置开始
        while(p1.next!=null&&p1.next.next!=null&&p1!=p2){//要么是到头了，要么是相交了
            p1=p1.next.next;
            p2=p2.next;
        }
        if (p1==p2){//是循环链表
            p1=head;//p1从头开始跑
            while(p1!=p2){//p1、p2一人走一步，相遇的结点就是第一个入环结点
                p1=p1.next;
                p2=p2.next;
            }
            return p1;
        }else{//不是循环链表
            return null;
        }
    }

    /**
     * @param head1:链表1，不是循环链表
     * @param head2:链表2，不是循环链表
     * @return :如果两个都是非循环链表，如果相交返回相交结点，如果不相交，返回null
     */
    public static Node noLoop(Node head1, Node head2) {
        if (head1==null||head2==null){
            return null;
        }
        Node p1=head1;
        Node p2=head2;
        int len=0;//最终len代表两链表相差的结点个数。len并不是链表长度，他比长度少1
        while(p1.next!=null){//p.next!=null的形式是返回最后一个节点
            len++;
            p1=p1.next;
        }
        while(p2.next!=null){
            len--;
            p2=p2.next;
        }
        if (p1==p2){//说明有相交
            p1=head1;
            p2=head2;
            if(len>0){//让长的链表多走相差的节点数
                while(len>0){
                    p1=p1.next;
                    len--;
                }
            }else if (len<0){
                while(len<0){
                    p2=p2.next;
                    len++;
                }
            }
            while(p1!=p2){//p1和p2相遇的地方一定是相交结点
                p1=p1.next;
                p2=p2.next;
            }
            return p1;
        }else{
            return null;
        }
    }

    /**
     *
     * @param head1:链表1的头节点，是循环链表
     * @param loop1:链表1的第一个入环结点
     * @param head2:链表2的头节点，是循环链表
     * @param loop2:链表2的第一个入环结点
     * @return ：如果两链表有相交则返回相交结点，否则返回null。
     */
    public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
        Node p1=loop1;
        Node p2=loop2;
        if (p1==p2){//转化成两个单链的情况
            p2=p1.next;//记住p1的后继结点，方便后面复原
            p1.next=null;//把循环的部分拆掉最后再复原
            Node res=noLoop(head1,head2);
            p1.next=p2;//恢复后面的循环部分
            return res;
        }else{
            p1=loop1.next;
            while(p1!=loop1&&p1!=loop2){
                p1=p1.next;
            }
            if (p1==loop2){//说明相交了
                return loop1;
            }else{//说明没有相交
                return null;
            }
        }

    }
```

#### 删除给定值

- 题目：给你一个链表和一个值val，删除这个链表里面所有值为val的结点

  例如：1->1->1->2->3->1->2->4->1,如果要删除的val为1

  结果：2->3->2->4

思路：先让head跳到第一个不等于val的位置，也就是2位置，然后利用cur指针向后一个一个遍历，利用pre记住上一个不等于val的结点。如果cur不等于val那么就往后跳。如果cur为val那么pre的next就指向cur的下一个结点，然后cur往后跳。

```java
public static class Node {
        public int value;
        public Node next;

        public Node(int data) {
            this.value = data;
        }
    }

    public static Node removeValue(Node head, int num) {
        while(head!=null&&head.value==num) head= head.next;
        //现在来到了第一个不用删除的非空结点
        Node pre=head;//记录离cur最近的不用删除的结点
        Node cur=head;
        while(cur!=null){
            if (cur.value==num){//如果cur结点要删除，就让pre指向cur的下一个
                pre.next=cur.next;
            }else {//cur不需要删除，更新pre
                pre=cur;
            }
            cur=cur.next;
        }
        return head;
    }
```



#### 返回最小值的特殊栈

- 实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能
  1. pop、push、getMin操作的时间复杂度都是O(1)。
  2. 方法1：准备两个栈，第一个栈data就是正常的栈。第二个栈min，当前data栈的栈顶和min栈的栈顶，谁小加谁。data栈和最小栈同步上升。最小栈就记录着每一个高度，栈的最小值是什么。

方法2：也是两个栈，但是我只有在当前数比最小栈的栈顶小的时候才压入最小栈，大于的时候不压入。弹出的时候只有data栈和min栈的栈顶相等的时候才弹出。

![image-20220920184204343](image/image-20220920184204343.png)

```java
public static class MyStack1 {
   private Stack<Integer> stackData;
   private Stack<Integer> stackMin;

   public MyStack1() {
      this.stackData = new Stack<Integer>();
      this.stackMin = new Stack<Integer>();
   }

   public void push(int newNum) {
      if (this.stackMin.isEmpty()) {
         this.stackMin.push(newNum);
      } else if (newNum <= this.getmin()) {
         this.stackMin.push(newNum);
      }
      this.stackData.push(newNum);
   }

   public int pop() {
      if (this.stackData.isEmpty()) {
         throw new RuntimeException("Your stack is empty.");
      }
      int value = this.stackData.pop();
      if (value == this.getmin()) {
         this.stackMin.pop();
      }
      return value;
   }

   public int getmin() {
      if (this.stackMin.isEmpty()) {
         throw new RuntimeException("Your stack is empty.");
      }
      return this.stackMin.peek();
   }
}

public static class MyStack2 {
   private Stack<Integer> stackData;
   private Stack<Integer> stackMin;

   public MyStack2() {
      this.stackData = new Stack<Integer>();
      this.stackMin = new Stack<Integer>();
   }

   public void push(int newNum) {
      if (this.stackMin.isEmpty()) {
         this.stackMin.push(newNum);
      } else if (newNum < this.getmin()) {
         this.stackMin.push(newNum);
      } else {
         int newMin = this.stackMin.peek();
         this.stackMin.push(newMin);
      }
      this.stackData.push(newNum);
   }

   public int pop() {
      if (this.stackData.isEmpty()) {
         throw new RuntimeException("Your stack is empty.");
      }
      this.stackMin.pop();
      return this.stackData.pop();
   }

   public int getmin() {
      if (this.stackMin.isEmpty()) {
         throw new RuntimeException("Your stack is empty.");
      }
      return this.stackMin.peek();
   }
}
```

#### 使用栈结构实现队列

准备两个栈，一个栈是pop栈一个栈是push栈。我们把push栈里面的数导到pop栈里面，再从pop栈中弹出就实现了逆序。但是从push栈导入到pop栈要遵循几个原则：第一个原则就是只有pop栈为空的时候才能倒入pop栈。第二个原则，每次push栈往pop栈里面导数据的时候要一次性倒完。

```java
public static class TwoStacksQueue {
   public Stack<Integer> stackPush;
   public Stack<Integer> stackPop;

   public TwoStacksQueue() {
      stackPush = new Stack<Integer>();
      stackPop = new Stack<Integer>();
   }

   // push栈向pop栈倒入数据
   private void pushToPop() {
      if (stackPop.empty()) {
         while (!stackPush.empty()) {
            stackPop.push(stackPush.pop());
         }
      }
   }

   public void add(int pushInt) {
      stackPush.push(pushInt);
      pushToPop();
   }

   public int poll() {
      if (stackPop.empty() && stackPush.empty()) {
         throw new RuntimeException("Queue is empty!");
      }
      pushToPop();
      return stackPop.pop();
   }

   public int peek() {
      if (stackPop.empty() && stackPush.empty()) {
         throw new RuntimeException("Queue is empty!");
      }
      pushToPop();
      return stackPop.peek();
   }
}
```

#### 使用队列实现栈

准备两个队列，一个队列data一个队列help。把前n-1个数导到help队列里面，打印第n个。下一次help和data身份互换就行。

```java
public static class TwoQueueStack<T> {
   public Queue<T> queue;
   public Queue<T> help;

   public TwoQueueStack() {
      queue = new LinkedList<>();
      help = new LinkedList<>();
   }

   public void push(T value) {
      queue.offer(value);
   }

   public T poll() {
      while (queue.size() > 1) {
         help.offer(queue.poll());
      }
      T ans = queue.poll();
      Queue<T> tmp = queue;
      queue = help;
      help = tmp;
      return ans;
   }

   public T peek() {
      while (queue.size() > 1) {
         help.offer(queue.poll());
      }
      T ans = queue.poll();
      help.offer(ans);
      Queue<T> tmp = queue;
      queue = help;
      help = tmp;
      return ans;
   }

   public boolean isEmpty() {
      return queue.isEmpty();
   }

}
```

#### 定制快慢指针

奇数情况按照3个节点来看，偶数情况按照4个结点来看。从1开始计数

1. 奇数返回中点，偶数返回中右。这里奇数返回中点，所以我们一开始先把slow指向中间的结点（奇定慢）。因为在奇数的时候slow就要在2位置，所以fast只能在2或3位置。因为如果fast在1位置会跳到3位置，这样一来slow就到了3位置了。所以现在是slow在2位置，fast只能在2和3之中选一个。由于偶数返回中右，偶数的情况我们就想象有四个结点，此时slow要移动到3位置，也就意味着fast只能在2位置，这样fast从2移动到4，slow才有机会移动到3位置。(2,2)

2. 奇数返回中，所以slow起始位置在2。偶数返回左中（2位置），所以fast放在3位置影响不到slow。(2,3)
3. 奇数返回中前（1位置），所以slow起始位置为1。偶数返回右中前（也就是左中2），所以fast为2来影响slow移动.(1,2)
4. 奇数返回中前，所以slow起始位置为1.偶数返回左中前（1），所以fast在3位置，影响不了slow。(1,3)

在3个结点和4个结点的情况下设定好了slow和fast的位置之后，slow和fast可以同时退后，那么就同时退后。退后完了之后，fast在的位置就是至少要有的节点数。

1. (2,2)，至少要有两个结点，0~1个结点的情况要自己返回值。
2. (1,1)，至少要有一个结点，0个结点的情况要自己返回值。
3. (1,2)，至少要有两个结点，0~1个结点的情况要自己返回值。
4. (1,3)，至少要有三个结点，0~2个结点的情况要自己返回值。

![image-20220522145808532](./image\image-20220522145808532.png)

![image-20220915212828160](image/image-20220915212828160.png)

```java
public static class Node {
        public int value;
        public Node next;

        public Node(int value) {
            this.value = value;
        }
    }

    /**
     * 奇数返回中点，偶数返回左中。例如：1,2,3,4返回2  1,2,3,4,5返回3
     * slow放在2位置（从1开始计），fast放在3位置。通过if来手动返回节点数小于3的情况
     * @param head
     * @return
     */
    public static Node MidOrLeftMid(Node head) {//（2,3）-->(1,1)
        Node slow=head;
        Node fast=head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    /**
     * 奇数返回中点，偶数返回右中。例如：1,2,3,4返回3  1,2,3,4,5返回3
     * @param head
     * @return
     */
    public static Node MidOrRightMid(Node head) {//(2,2)-->(2,2)
        if (head==null||head.next==null) return head;//0~1个结点自己判断返回，有1个结点是有意义的
        Node slow=head.next;
        Node fast=head.next;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    /**
     * 奇数返回中点的前一个，偶数返回左中的前一个。例如：1,2,3,4返回1  1,2,3,4,5返回2
     * 至少要有3个结点，因为2结点的时候没有左中前
     * @param head
     * @return
     */
    public static Node MidPreOrLeftMidPre(Node head) {//(1,3)-->(1,3)
        if (head == null || head.next == null || head.next.next == null) {//保证了至少有三台结点,少于3个都是没有意义的。
            return null;
        }
        Node slow = head;//1位置
        Node fast = head.next.next;//slow最后要在左中前，fast不能影响slow，放在3位置
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    /**
     * 奇数返回中点的前一个，偶数返回右中的前一个。例如：1,2,3,4返回2  1,2,3,4,5返回2
     * @param head
     * @return
     */
    public static Node MidPreOrRightMidPre(Node head) {//(1,2)-->(1,2)
        if (head == null || head.next == null) {//至少要有两个结点,少于两个结点都是没有意义的
            return null;
        }
        Node slow = head;//1位置
        Node fast = head.next;//slow要动，fast要在2位置
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
```

## 排序算法

### 选择排序

第一步先把捣乱的数组剔除，没法排或者直接就有序。

for循环要做的就是从i到n-1上选一个最小值，并且把最小值放到i上去。我们先假设最小值的指针是minIndex（数组的下标），然后如果j位置上的值比minIndex位置上的小那么我就把j赋值给minIndex。出了for循环之后，我们就把minIndex位置上的值和i位置上的值做交换，这样完成了一趟选择。完成n-1趟选择之后数组就有序了。

外层for循环控制第几趟，内层for循环控制每一趟。

```java
public static void selectionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 0 ~ N-1  找到最小值，在哪，放到0位置上
		// 1 ~ n-1  找到最小值，在哪，放到1 位置上
		// 2 ~ n-1  找到最小值，在哪，放到2 位置上
		for (int i = 0; i < arr.length - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j < arr.length; j++) { // i ~ N-1 上找最小值的下标 
				minIndex = arr[j] < arr[minIndex] ? j : minIndex;
			}
			swap(arr, i, minIndex);
		}
	}
```

### 冒泡排序

想象一堆水下的泡泡，我从最底下开始，两两比较，小的上移，这样一来完成一趟 之后最小的就在最上面了。然后循环往复，最终实现有序。

这边的交换利用异或来实现，因为利用异或运算的交换律和结合律即可轻松证明，异或运算就是不进位相加，既然是不进位相加，那么最终某一位的结果和某一位上1的个数(奇偶)有关，所以当然满足交换和结合。可以得到一个结论：同一批数异或在一起不所谓谁先谁后，结果一定一样。**但是这边的交换要注意：i和j一定不能相等，因为这是在数组里面，如果相等那么就是在同一块内存空间来做这件事情，会把这片内存空间的数据抹成0。**

```JAVA
public static void bubbleSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 0 ~ N-1
		// 0 ~ N-2
		// 0 ~ N-3
		for (int e = arr.length - 1; e > 0; e--) { // 0 ~ e
			for (int i = 0; i < e; i++) {
				if (arr[i] > arr[i + 1]) {
					swap(arr, i, i + 1);
				}
			}
		}
	}

	// 交换arr的i和j位置上的值
	public static void swap(int[] arr, int i, int j) {
		arr[i] = arr[i] ^ arr[j];
		arr[j] = arr[i] ^ arr[j];
		arr[i] = arr[i] ^ arr[j];
	}
```

### 插入排序

> 插入排序细节的讲解与复杂度分析
> 时间复杂度O(N^2)，额外空间复杂度0(1)算法流程按照最差情况来估计时间复杂度

插入排序在完全逆序的情况下，时间复杂度是O(N²)。在完全有序的情况下，时间复杂度是O(N)。所以我们所说的时间复杂度是最差情况下的时间复杂度。大θ是平均时间复杂度，大Ω是最好时间复杂度。大O是最差。

选择排序和冒泡排序是严格的O(N²)，而插入排序在某些数据状况下并不用严格的O(N²)。

```JAVA
public class Code03_InsertionSort {

	public static void insertionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 不只1个数
		for (int i = 1; i < arr.length; i++) { // 0 ~ i 做到有序
			for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
				swap(arr, j, j + 1);
			}
		}
	}
```

第二种方法是浙江大学插牌法，而非交换。

```JAVA
public static void insertionSort_02(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int p,i;
		for (p=1;p<arr.length;p++){
			int temp = arr[p];
			for (i=p;i>0&&temp<arr[i-1];i--){
				arr[i]=arr[i-1];
			}
			arr[i]=temp;
		}
	}
```



### 归并排序 

#### 代码

###### 递归

```java
    private static void mergeSort(int[] arr){
        if (arr==null||arr.length<2)
            return;
        mergeSort(arr,0,arr.length-1);
    }

    private static void mergeSort(int[] arr, int l, int r) {
        if (l>=r)return;
        int mid=l+((r-l)>>1);
        mergeSort(arr,l,mid);
        mergeSort(arr,mid+1,r);
        merge(arr,l,mid+1,r);
    }

    /**
     *
     * @param arr:在arr数组的相应下标进行merge
     * @param ls:merge的左边数组的开始下标
     * @param rs:merge的右边数组的开始下标
     * @param re：merge的右边数组的结束下标
     */
    private static void merge(int[] arr, int ls, int rs, int re) {
        int[] help =new int[re-ls+1];
        int p1=ls;
        int p2=rs;
        int i=0;//help的辅助指针
        while(p1<=rs-1&&p2<=re){
            help[i++]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];
        }
        //出来就是p1和p2有其中一个越界了，下面的两个while循环只会进入一个
        while(p1<=rs-1)
            help[i++]=arr[p1++];
        while(p2<=re)
            help[i++]=arr[p2++];
        for (i=0;i<help.length;i++){
            arr[ls+i]=help[i];
        }
    }
```



#### 非递归

这个版本会对数组频繁的创建销毁

```java
 //先给用户提供一个接口
    private static void mergeSort(int [] arr){
        if (arr==null||arr.length<2)
            return;
        mergeSort(arr,0,arr.length-1);
    }
    //arr在[l,r]范围上排好序
    private static void mergeSort(int[] arr, int l, int r) {
        /**
         * 两两合并子列，子列长度一开始是1
         */
        for (int len=1;len<=arr.length;len*=2){
            mergePass(arr,l,r,len);
        }
    }

    private static void mergePass(int[] arr, int l, int r, int len) {
        /**
         * i是merge的左边的起点，rs就是i+len是merge的右边的起点，l+2len-1是右边的终点
         */
        int i=0;
        for(;i<=arr.length-2*len;i+=2*len){
            int rs=i+len;
            merge(arr,i,i+len,i+2*len-1);
        }
        if(i+len<arr.length){//说明还有两个子列
            merge(arr,i,i+len,arr.length-1);
        }
    }

    /**
     * 直接把arr中的[l,rs-1]和[rs,r]merge起来。要注意的是这里我们是的help数组是建立在merge函数里面的。
     * @param arr，数组
     * @param l ，merge的左边的起点
     * @param rs ，merge的右边的起点
     * @param r ，merge的右边的终点
     */
    private static void merge(int[] arr, int l, int rs, int r) {
        int help[]=new int[r-l+1];
        int p1=l,p2=rs;//定义2个指针一个指向左边数组的头，一个指向右边数组的头
        int i=0;//指向help数组的头
        while(p1<=rs-1&&p2<=r){
            help[i++]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];
        }
        //退出while说明有其中一个越界了
        while(p1<=rs-1){//如果左边没有越界
            help[i++]=arr[p1++];
        }
        while(p2<=r){
            help[i++]=arr[p2++];
        }
        for(i=0;i<help.length;i++){
            arr[l+i]=help[i];
        }
    }
```



这个版本不会对数组频繁销毁

```java
/**
 * 这里的while里面拷贝了两次是因为我们在merge中为了节约时间，没有把help数组里面的数组拷贝回arr
 * 所以这里反过来调用，让help的数组再传输回arr
 * @param arr
 */
private static void mergeSort(int [] arr){
    if (arr==null||arr.length<2)
        return;
    int help[] =new int[arr.length];
    int len=1;
    while(len<arr.length){
        mergePass(arr,help,len);
        len*=2;
        mergePass(help,arr,len);
        len*=2;
    }
}

private static void mergePass(int[] arr, int[] help, int len) {
    int i=0;
    for(;i<=arr.length-2*len;i+=2*len){
        merge(arr,help,i,i+len,i+2*len-1);
    }
    if (i+len<arr.length){
        merge(arr,help,i,i+len,arr.length-1);
    }else{
        while(i<arr.length){
            help[i]=arr[i++];
        }
    }
}

private static void merge(int[] arr, int[] help, int l, int rs, int r) {
    int p1=l,p2=rs;//定义2个指针一个指向左边数组的头，一个指向右边数组的头
    int i=0;
    while(p1<=rs-1&&p2<=r){
        help[i+l]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];
        i++;
    }
    //退出while说明有其中一个越界了
    while(p1<=rs-1){//如果左边没有越界
        help[i+l]=arr[p1++];
        i++;
    }
    while(p2<=r){
        help[i+l]=arr[p2++];
        i++;
    }
}
```

#### 归并排序的扩展 

- 归并排序的扩展 

  小和问题和逆序对问题

  小和问题

  在一个数组中，数组中每一个数的左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和

  例子: [1,3,4,2,5] 1左边比1小的数，没有; 3左边比3小的数，1; 4左 边比4小的数，1、3; 2左边比2小的数，1; 5左边比5小的数，1、3、4、 2; 所以小和为1+1+3+1+1+3+4+2=16 

  逆序对问题  ： 在一个数组中，左边的数如果比右边的数大，则这两个数 构成一个逆序对，请打印所有逆序 对或找到逆序对的数量。

###### 分析

这道题原本是要求所有数左边比它小的数的和，既然左边的数比右边的数小，那么对于左边这个数来说，右边的数就比左边的数大。所以这个问题就变成求每一个数在右边有多少个比它大，假设这个数是n，右边有m个比它大，那么整个数组的小和的一部分就是nm。

我在归并排序merge的时候，左右指针的值比较，左侧小的时候就产生了一个小和。也就是在归并排序的merge中增加一个功能，就是当左侧的数往help数组里面放的时候就产生了一个小和，因为这时候右边指针的值比左侧的大。为什么这样不会遗漏呢？因为我在merge的过程中一定会把右侧范围扩大到整体的。为什么不重复？因为经过merge之后右侧的数已经被纳入了整体，在内部是不会重复产生小和的。只是因为左组和右组merge的时候因为左组的某一些数比右组的小才会产生新的小和。

来看3的经过：3和1merge的时候因为它是以右组的姿态参与merge，所以一定不会产生3的小和。但是merge完之后1,3会进一步和4去merge，这个时候就求出有一个数比3大了。然后1,3,4又和2，5去merge，又求出有一个数比3大，所以求解谁比3大也是不遗漏不重算的。

同理一开始1,3和4merge，4是以右组的姿态，所以不会产生关于4的小和。接下来1,3,4和2,5merge，产生了一个关于4的小和。

另外，merge的过程中是通过R-j+1来直接计算出右边有多少数比左边的这个数大。这种算法是建立在merge的两组是有序的情况下。

<img src="./image\image-20220324220939418-16521057085641.png" alt="image-20220324220939418" style="zoom:80%;" />

这道题的merge的原来归并的merge有不同的地方，也就是当i和j指向的值相等的时候我一定是拷贝右边的，因为如果我拷贝了左边了，那么我就会丢失左边的这个数的小和---我不知道右边有多少个数比它大，我还不能拷贝左边。原本的归并排序先拷贝左边是因为要保证这个排序是稳定的，但是现在我们在只需要算出小和就行，所以先拷贝右边。只有当右边的数严格的比左边的数小，我才能够算出右边有多少个数比左边这个数小。

- 我们随便拿一个数，看看它的心路历程，无论他在哪里，merge的时候只有它是属于左边的那一组才有可能产生它的小和，在一步步的merge中，求它的小和的范围是不断的往右边扩展的。所以右边一定会拓展到头，所以这个数一定不会漏算。而为什么不会漏算，因为一旦这个数和一个组合并了（也就是因为这个组产生小和了），一个组内部是不会产生小和的。只有做左组和右组PK的时候才会产生小和。对于所有的数来说都是这个过程

###### 代码

```java
private static int smallSum(int[] arr) {
    if (arr == null || arr.length < 2)
        return 0;
    return mergeSort(arr, 0, arr.length - 1);
}

private static int mergeSort(int[] arr, int l, int r) {
    if (r == l)
        return 0;
    int mid = l + ((r - l) >> 1);
    return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r);
}

private static int merge(int[] arr, int l, int mid, int r) {
    int[] help = new int[r - l + 1];
    int p1 = l;
    int p2 = mid + 1;
    int i = 0;
    int res = 0;
    while (p1 <= mid && p2 <= r) {
        res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= mid)
        help[i++] = arr[p1++];
    while (p2 <= r)
        help[i++] = arr[p2++];
    for (i = 0; i < help.length; i++) {
        arr[i + l] = help[i];
    }
    return res;
}
```

#### 逆序对

右边的数比左边的数小就是一个逆序对。小和问题是求右边有多少个数比左边的数大，现在的问题就是要求右边有多少数比左边的数要小。也就是merge的时候右边的数往help数组里面放的时候，逆序对就要增加了。





### 堆排序

#### 堆结构

堆排序远没有堆结构重要。我们用heapsize来描述完全二叉树的大小。如果是从数组的0位置开始连续放置，i结点的左孩子是2i+1，右孩子是2i+2，父亲结点是i-1/2.如果是从1位置开始连续放置，那么左孩子就是2i，右孩子就是2i+1.父节点是i/2.

堆是特殊的完全二叉树。分为最大堆和最小堆。现在问题来了，我可以把数组连续出发的一段理解成完全二叉树，但是我怎么把数组连续出发的一段弄成堆？用户给的第一个数本身自己是最大堆，然后后面每次来一个数我就顺着放在完全二叉树的下一个结点，往上去比，调整成一个最大堆。

如果现在用户要叫你给它一个最大值，并且把最大值从堆中去掉。因为这个时候我们的size要减小，并且第一个数要删掉，所以一个很自然的想法就是把最后一个数放到0位置，我们用一个变量把0位置的数先记住--后面是要返回给用户的。现在的问题就是要把现在完全二叉树再次调整成最大堆。从头节点开始，找它的左右孩子中最大的---如果有的话，如果2i+1<=heapsieze-1的话说明至少有一个左孩子。只要向下比较，知道我没有左孩子了，或者说左孩子和右孩子中最大的都比我的小就停。

所以现在我们知道了，insert操作就是向上比较。delete操作就是把最后一个调上去然后往下比较。那么现在我们要直接把中的某一个i位置的值改变，叫你再把它调整成最大堆，我们只要知道它是变大了还是变小了就行，变大了就向上去比较，变小了就往下比较就行。

- 左程云的代码的insert就是向上调整。heapify就是向下调整。

如果用户已经给了N个数，现在要再给一个数，那么调整的代价就是logN。

> 堆
>
> 1，堆结构就是用数组实现的**完全二叉树**结构 
>
> 2，完全二叉树中如果每棵子树的最大值都在顶部就是大根堆 
>
> 3，完全二叉树中如果每棵子树的最小值都在顶部就是小根堆 
>
> 4，堆结构的heapInsert与heapify操作 
>
> 5，堆结构的增大和减少 
>
> 6，优先级队列结构，就是堆结构



---

#### 分析

堆排序无非就是用户给你一个数组。你先认为堆大小就是1，也就是0下标位置的数自己构成堆。然后1~N-1位置的数一个一个insert，让堆的大小慢慢变大。这样一来就完成了堆的构建，代价是NlogN。这样一来我们构建成了最大堆，接下来我们只需要一个一个删除最大值即可，因为最大值删除之后按照我们的思路最大值是可以保存在原本的堆的最后的，而我们要的排序是从小到大，这正好符合我们的要求，随后size--让现在这个排好的最大值断掉和最大堆的联系，删除之后调整成最大堆，然后继续刚刚的操作----删掉最大值然后继续调整size--。

整个过程没有递归，没有生成大的数组结构，insert和delete方法也都是O(1)的。所以整个的堆排序的空间复杂度是O(1)。在时间复杂度是NlogN的排序里面只有堆排序能做到。

其实如果用户一次性给你一个数组，你的目标就是把这个数组调整成最大堆的结构，那么这一步有更好的方法，不需要一个一个去调整。相当于给你一个完全二叉树叫你去调整成堆的结构。我们可以把堆看成是一个根节点和子堆构成的。那么我们可以从下面开始，从最小的子堆开始，往下调整。最终整体有序。就类似于删除操作把最后一个换到第一个的往下调整的过程，因为你把最后一个换到第一个，第一个的左右两边都是子堆，都是调整好的。所以是一个思想。第一种方法就是insert的向上调整，这种方法就是delete的向下调整。

这种方法好，因为这种方法只需要一个线性的时间复杂度。叶子结点有N/2个看一眼......。快的根本原因就是向下调整的话完全二叉树的越下面结点越多，这种方法就是把更多的结点用更少的步骤解决了。

所以我们从数组的右边开始，也就是尾部开始，一个一个的向下调整。后面的操作没有变，只是把一个数组调整成一个堆的速度变快了。

![image-20220327145108284](./image\image-20220327145108284.png)

> 堆排序 
>
> 1，先让整个数组都变成大根堆结构，建立堆的过程: 1)从上到下的方法，时间复杂度为O(N*logN) 2)从下到上的方法，时间复杂度为O(N) *
>
> *2，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调 整堆，一直周而复始，时间复杂度为O(N*logN) 
>
> 3，堆的大小减小成0之后，排序完成

#### 代码

```java
private static void heapSort(int[] arr){
    if (arr==null||arr.length<2)
        return;
    for (int i=arr.length-1;i>=0;i--){
        percDown(arr,i,arr.length);
    }
    for (int i=arr.length-1;i>=1;i--){
        swap(arr,0,i);//这边的i代表下标
        percDown(arr,0,i);//这边的i代表大小
    }
}

/**
 * 从i的地方开始向上调整成最大堆。不需要知道size因为向上的边界自动是0
 * @param arr
 * @param i
 */
private static void insert(int[] arr, int i) {
    int child=i,temp=arr[i];
    for (;child>0&&arr[(child-1)/2]<temp;child=(child-1)/2)
        arr[child]=arr[(child-1)/2];
    arr[child]=temp;
}

/**
 * 从index的地方向下调整成最大堆，堆的大小为size。这里需要知道size，因为我们需要确定
 * 向下调整时候的边界。
 * @param arr
 * @param index
 * @param size
 */
private static void percDown(int[] arr, int index, int size) {
    int child,parent=index,temp=arr[index];
    for (;parent*2+1<size;parent=child){//迭代如果不是唯一的，那么就需要额外变量
        child=parent*2+2<size&&arr[parent*2+2]>arr[parent*2+1]?parent*2+2:parent*2+1;
        if (temp<arr[child])
            arr[parent]=arr[child];
        else
            break;//如果temp>=arr.[child]说明找到了，退出
    }
    arr[parent]=temp;
}

private static void swap(int[] arr, int a, int b) {
    int temp=arr[a];
    arr[a]=arr[b];
    arr[b]=temp;
}
```

#### 堆排序扩展

> 堆排序扩展题目 
>
> 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元 素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的 排序算法针对这个数据进行排序。

因为每个元素移动的距离不超过k，所以数组的最小值一定在0-6的下标范围上。那么我就建立一个最小堆，每一次弹出最小的元素，放到数组的前面去，然后再从后面新增加一个数，再调整成最小堆。周而复始。时间复杂度为NlogK，因为这个k很小，甚至我们可以认为是一个O(N)的算法。

![image-20220327151043594](./image\image-20220327151043594.png)

在java中优先级队列就是最小堆---PriorityQueue，甚至都不用自己实现。这里有一个问题是扩容代价，我一共有N个数，总的扩容代价是NlogN,但是如果均摊到每一次的代价就是logN了。扩容这件事并不会影响最终的表现。

另外一点如果你使用了系统提供的对结构，那么你就只能用它给你的add和pull方法，添加一个值或者是给你弹出一个最小值并且删除它。你不能指望系统的已经在内部调整好的堆结构你给它中间某一个值改了还要他用很轻的代价像我们手写的堆结构一样去看看向上insert还是向下heapify。你就把系统的heap看成是一个黑盒，你给一个数，它给你一个数，你不要到内部去搞，这会让它搞乱，或者是调整回来的代价高。如果你自己有需求，那么就自己写一个堆。这就是为什么在很多面试场合必须要手写堆，因为在有些情景下必须要手写堆才能做到高效。

但是对于我们这道题来说，我们不涉及到要手写堆的需求，所以我们用这个黑盒就行了。

###### 代码

```java
private static void sort(int[]arr ,int k){

    PriorityQueue<Integer>heap=new PriorityQueue<>();
    int index=0;//用来放进堆
    for (;index<Math.min(arr.length,k+1);index++){
        heap.add(arr[index]);
    }
    int i=0;//用来指示排序的进度
    for (;index<arr.length;i++,index++){
        arr[i]=heap.poll();
        heap.add(arr[index]);
    }
    while(i<arr.length){
        arr[i++]=heap.poll();
    }

}
```



### 快排

#### 荷兰国旗问题

问题一 

- 给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的 数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N) 

思想就是小于等于区域推着大于等于区域一直往右边走，在i和小于等于区域中间的就是大于区域，当i越界了，也就是大于等于区域到数组的头了，那么我们就完成了划分。

情况1：如果arr[i]<=num，那么arr[i]和小于等于区域的下一个数做交换，小于等于区域往外扩，i++.

情况2：如果arr[i]>num，那么i++，相当于大于等于区域直接往外扩。

<img src="./image\image-20220327103302411.png" alt="image-20220327103302411" style="zoom: 25%;" />

```java
private static void twoArea(int []arr,int num){
    int less=-1;
    for (int i=0;i<arr.length;i++){
        if (arr[i]<=num){
            swap(arr,less+1,i);
            less++;
        }
    }
}
```

根据上面的算法，可以得到一种快排的实现方法



---



问题二(荷兰国旗问题) 

- 给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放 在数组的中间，大于num的数放在数组的 右边。要求额外空间复杂度O(1)，时间复杂度 O(N)

原本小于等于区域是不分家的，现在我要把小于等于区域再分为小于区域和等于区域。小于和大于区域不要求有序但是要让数组的严格分成三块----这就是荷兰国旗问题。

思想就是在原本的基础上多一个大于区域---大于区域从数组的右边开始，小于区域从数组的左边开始。夹在中间的就是等与区域。大于区域和小于区域分别用一个变量，相等于比问题一多用了一个变量。让i从数组的头开始走，表示当前数的下标。

情况1：如果当前数arr-i比num小，那么和小于区域的下一个数交换，小于区域往右扩，i++

情况2：如果当前数arr-i与num相等，i++

情况3：如果当前数arr-i比num大，那么和大于区域的前一个数交换，大于区域往左扩，i不动。

i不动的原因是大于区域前面的数我还没有看过，i不能++。

i根据现在自己来到的数，如果等于num，那么就让等于区域直接扩充。如果i是小于区域的，那么就把i放到小于区域的下一个，把等于区域的第一个拿过来，然后扩充小于区域。相当于小于区域推着等于区域往右边走。如果这个i是大于区域的，那么就把i换到大于区域的前一个，让大于区域左扩，新来的谁重新来到i的位置，继续看。当你小于区域推着等于区域和大于区域撞上的时候就完成了。要么i左走，小于区域推着等于区域右走，要么i右走，大于区域左扩。

![image-20220327121219637](./image\image-20220327121219637.png)

```java
private static int [] flag(int []arr,int l,int r,int num){
    int less=l-1;
    int more=r+1;
    while(l<more){
        if (arr[l]<num){
            swap(arr,++less,l++);
        }else if (arr[l]>num){
            swap(arr,--more,l);
        }else {
            l++;
        }
    }
    return new int[]{less+1,more-1};
}
```



#### 不改进的快速排序

> 不改进的快速排序 : 
>
> 1）把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部 分： 左侧<划分值、中间==划分值、右侧>划分值 
>
> 2）对左侧范围和右侧范围，递归执行 
>
> 分析 :
>
> 1）划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低 
>
> 2）可以轻而易举的举出最差的例子，所以不改进的快速排序时间复杂度为O(N^2)

快排1.0是说，在整个数组中，我拿最后一个值做划分值。最后这个数就是我们前面的num。0-n-2位置划分成<=和>区域，划分完成之后最后这个数和>区域的第一个数做交换即可。然后让左侧和右侧重复这个行为---递归。我每次划分的时候都会有一个数被排好，所以递归下去总有有序的时候。

![image-20220327122309910](./image\image-20220327122309910.png)

快排2.0就是利用了荷兰国旗问题。一开始在整个范围上拿最后一个数num做划分，让前面的范围做到</=/>，这样让num和>num的第一个数做划分，那么我等于的区域就可以不用动了，在<和>的区域继续做递归。这种方法一次可以搞定一批数---一批等于NUN的数。

不管是快排1.0还是快排2.0时间复杂度都是O(N²)。因为我们可以举出最差的例子，在数组完全逆序或者是完全有序的时候，一次的划分只搞定了一个数。所以必然有一个快排3.0.

划分值打的很偏会产生差情况。最好的情况是划分值打在几乎中间的位置，因为这样一来左右两侧递归的规模差不多。这时候T(N)=2T(N/2)+O(N).划分值如果打偏，就会退化成N²的算法。

快排3.0，在数组l-r的范围上，我拿谁做划分？随机选一个数做划分，随机选了一个数之后我把它和最后一个数做交换，然后拿最后的这个数做划分，现在这个最后的数和1.0和2.0的最后一个数可不一样，它是我们随机选出来的数。既然是随机选的，那么好情况和坏情况就被分摊了---好坏都是概率事件。这个时候就不能构建出最坏情况了。

快排的1.0版本和2.0版本的空间复杂度是O(N)级别的，因为如果我的数据完全有序。我每次的patition之后num的位置要告诉quickSort，所以要为这个num的位置开一个int。这种情况下就要开N个int给num----开了N层。如果加了随机行为那么就退化到O(logN)。左侧递归使用的空间可以给右侧递归使用，所以主要就是看开了几层。

现在的问题就是如果我是用非递归来写的话，能不能省掉这个空间？不行！因为这个位置是我具体算出来的，我去解决子问题的时候，我先要记住母问题的这个位置，回到母问题的时候才能根据这个位置继续去解决右边的问题。所以即便改成迭代了，这个中点的位置也是要记录的，无非就是在递归里面是递归帮你压栈的，改成迭代的话就是要自己做一个栈，然后自己压栈，所以无论如何空间都没有办法省略。写递归只是因为好理解。所以这个问题变成了我划分值的位置决定了我额外空间的多少，最差是N，最好是logN，由于随机，还是一个概率的累加，最终还是收敛到logN的水平。



#### 随机快速排序

> 随机快速排序（改进的快速排序） 
>
> 1）在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分 成三个部分： 左侧<划分值、中间==划分值、右侧>划分值 
>
> 2）对左侧范围和右侧范围，递归执行 
>
> 3）时间复杂度为O(N*logN)

#### 代码

```java
public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}

	// arr[L..R]上，以arr[R]位置的数做划分值
	// <= X > X
	// <= X X
	public static int partition(int[] arr, int L, int R) {
		if (L > R) {
			return -1;
		}
		if (L == R) {
			return L;
		}
		int lessEqual = L - 1;
		int index = L;
		while (index < R) {
			if (arr[index] <= arr[R]) {
				swap(arr, index, ++lessEqual);
			}
			index++;
		}
		swap(arr, ++lessEqual, R);
		return lessEqual;
	}

	// arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值
	// <arr[R] ==arr[R] > arr[R]
	public static int[] netherlandsFlag(int[] arr, int L, int R) {
		if (L > R) { // L...R L>R
			return new int[] { -1, -1 };
		}
		if (L == R) {
			return new int[] { L, R };
		}
		int less = L - 1; // < 区 右边界
		int more = R; // > 区 左边界
		int index = L;
		while (index < more) { // 当前位置，不能和 >区的左边界撞上
			if (arr[index] == arr[R]) {
				index++;
			} else if (arr[index] < arr[R]) {
//				swap(arr, less + 1, index);
//				less++;
//				index++;						
				swap(arr, index++, ++less);
			} else { // >
				swap(arr, index, --more);
			}
		}
		swap(arr, more, R); // <[R]   =[R]   >[R]
		return new int[] { less + 1, more };
	}

	public static void quickSort1(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process1(arr, 0, arr.length - 1);
	}

	public static void process1(int[] arr, int L, int R) {
		if (L >= R) {
			return;
		}
		// L..R partition arr[R] [ <=arr[R] arr[R] >arr[R] ]
		int M = partition(arr, L, R);
		process1(arr, L, M - 1);
		process1(arr, M + 1, R);
	}

	
	
	
	
	
	public static void quickSort2(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process2(arr, 0, arr.length - 1);
	}

	// arr[L...R] 排有序，快排2.0方式
	public static void process2(int[] arr, int L, int R) {
		if (L >= R) {
			return;
		}
		// [ equalArea[0]  ,  equalArea[0]]
		int[] equalArea = netherlandsFlag(arr, L, R);
		process2(arr, L, equalArea[0] - 1);
		process2(arr, equalArea[1] + 1, R);
	}

	
	
	
	
	
	
	public static void quickSort3(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process3(arr, 0, arr.length - 1);
	}

	public static void process3(int[] arr, int L, int R) {
		if (L >= R) {
			return;
		}
		swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
		int[] equalArea = netherlandsFlag(arr, L, R);
		process3(arr, L, equalArea[0] - 1);
		process3(arr, equalArea[1] + 1, R);
	}
```



### 桶排序(计数和基数)

桶排序是一个思想

#### 计数排序

我们前面说的归并排序、插入排序、选择排序、冒泡排序、快速排序这些排序都是基于比较的排序。如果我现在有一个数组，数组里面是员工的年龄，年龄的话最多0-150.那么就开一个151大小的数组，下标代表年龄，数组的值代表这个年龄的员工有多少人。遇到一个员工是几岁，对应下标的位置就++。然后再把这个统计年龄的数组还原到原数组即可。但是这种排序只有在待比较的的数的范围在一个可以接受的范围内我才能做

所以说不基于比较的排序都是根据数据状况做的排序，他没有基于比较的排序有那么广的运用范围。不管是人对象还是动物对象，只要我告诉它两个对象怎么比大小就可以很自然的实现比较的排序。 不基于比较的排序路很窄，一定要根据数据状况来定制。

```java
//0~200
private static void countSort(int[] arr){
    int max=arr[0];
    for (int a:arr){
        max=a>max?a:max;
    }
    int count[]=new int[max+1];
    for (int a:arr)
        count[a]++;
    for (int i=0,j=0;i<count.length;i++){
        while(count[i]!=0){
            arr[j++]=i;
            count[i]--;
        }
    }
}
```

#### 基数排序

先看最大数的位数，其它数补齐位数。是几进制就准备几个桶。然后从个位数到高位数进出进出。这种排序依然要基于数据状况，因为你要排序的东西要和进制有关系。

实际上再代码实现的时候没有真的弄了很多个桶。我只需要一个数组，利用前面计数排序先得到每一个数有多少个，然后和前面的累加，变成<=某个数的数有多少个。因为进桶的顺序是从左到右，所以出桶的顺序是从右往左（假设12,22,32,42这几个数在原来数组的相对顺序是这样的，那么它们在出2这个桶的时候就是42,32,22,12这样的顺序出桶的，这样出桶是因为我们假设是队列出桶，这样可以保证不交换，稳定）。现在我们假设<=2的数有9个，那么也就是说包括了12,22,32,42这几个数，那么这几个数只能排在数组的[5,8]，就让42排在9位置上，然后修改这个累加数组2下标的值，让它--。也就是对于任何一个数n，我去找到对应的累加数组arr[N]然后它的前一个也就是help[arr[n-1]]上就可以放数值了。

从右往左是因为我们要满足先入桶的先出，保证顺序相对位置不变。可以理解成累加之后的数组提供了某个位数是n的那一堆数的右边界，我知道右边界我当然是从原数组的右边开始遍历，这样我的相对位置才不会变。



```jAVA
private static void radixSort(int [] arr){
    if (arr==null||arr.length<2)
        return;
    int maxDigit=maxDigit(arr);
    radixSort(arr,0,arr.length-1,maxDigit);
}

private static int maxDigit(int[] arr) {
    int max=arr[0];
    boolean flag=false;
    for (int a:arr){//找arr中最大
        if (a<0) flag=true;
        if (a>max) max=a;
    }
    if (flag) return -1;//如果有小于零
    int res=0;
    while(max!=0){
        res++;
        max/=10;
    }
    return res;
}

/**
 *
 * @param arr
 * @param l
 * @param r
 * @param maxDigit:确定要出入桶几次，maxDigit是arr数组中最大的位数，个位数是1，十位是2....
 */
private static void radixSort(int[] arr, int l, int r, int maxDigit) {
    final int radix=10;
    int i,j;
    int[] help=new int[r-l+1];
    for (i=1;i<=maxDigit;i++){//进出桶的轮数控制
        int[] count=new int[radix];//十进制0-9
        for (j=l;j<=r;j++){
            count[getDigit(arr[j],i)]++;
        }
        for (j=1;j<count.length;j++){
            count[j]+= count[j-1];
        }
        for (j=r;j>=l;j--){
            help[--count[getDigit(arr[j],i)]]=arr[j];
        }
        for (j=0;j< help.length;j++){
            arr[l+j]=help[j];
        }
    }
}
```



### 排序算法的稳定性及其汇总

![image-20220331114418338](./image\image-20220331114418338.png)

### 常见的坑

归并排序变成了额外空间复杂度为1但是它会因此丧失稳定性，还不如直接用堆排序。

快排可以改成稳定的，但是会让时间复杂度变成N²，不如直接用归并。

![image-20220331114427919](./image\image-20220331114427919.png)

- 面试大坑

  我们在快排的时候是把<=左边，>的放右边，这是01标准，一个数不是小于一个划分值就是大于一个划分值。这就等同于把奇数放左边偶数放右边。也就是说这道题是要做到01标准的stable sort，快排都做不到，这是论文级别的难度。

- 稳定性

  在基础数组中稳定性没有什么用。在什么地方有用呢---非基础类型。

  有很多学生，先按照年龄排序，然后按照班级号进行排序。最后进行的班级号的排序如果是稳定的，那么在一个班级内部，也就是班级号相同的学生中是按照年龄大小来排序的，也就是说不会打乱之前的排序结果。

  <img src="./image\image-20220331115342195.png" alt="image-20220331115342195" style="zoom: 33%;" />

  1. 选择排序不是稳定的。

     <img src="./image\image-20220331115951385.png" alt="image-20220331115951385" style="zoom:33%;" />

  2. 冒泡是稳定的

  3. 插入也是稳定的。

  4. 归并也是稳定的，关键就是mege的时候，左右两边相等先拷贝左边的。我们在做小和问题的时候，右边是先拷贝，所以小和问题的时候修改过的merge就没有稳定性了，但是整个排序是对的。

  5. 快排不是稳定的。两种类型的partition都做不到稳定。patition中i位置在和小于区的下一个做交换的时候就已经做不到稳定了，和选择排序道理一样。

  6. 堆排序在调整成最大堆的时候已经不能做到稳定了。堆中的结点只和自己和父亲和孩子玩，很轻易就能破坏 稳定。

  7. 计数排序和基数排序是稳定的，因为可以做到先入桶的先出桶。他们不是基于比较的排序，是一个萝卜一个坑，我只要这个桶内部次序维持好就能做到稳定。

  一般来说使用快速排序，因为通过实验，快排的常数项指标是最低的。

  如果你要稳定性，那么势必要N的空间。如果你要速度快，那么势必会失去稳定性。

  <img src="./image\image-20220331121611526.png" alt="image-20220331121611526" style="zoom:50%;" />

  



### 工程上对排序的改进

我们可以在小样本量是利用插入排序常数项低的优势，在大样本量上利用快速排序调度上的优势，综合两个排序算法，这叫做综合排序。

Java系统内部给你的排序，Arrays.Sort它发现如果你是基础类型就给你用快速排序。如果它 发现你是自己定义的非基础类型，就会给你用归并。原因就是因为稳定性。各个语言内部的排序都很复杂，因为他在利用各个排序算法的优势往一起拼装。但是一般来说都是往下面这两个角度来做优化。

![image-20220331114436721](./image\image-20220331114436721.png)

## 树

- 递归序

递归序，每一个结点都回到自己三次。前中后序遍历本质上就是选择在第几次回到自己才打印。

非递归先序：1-从栈中弹出一个结点cur 2-弹出就打印 3-右左子树按顺序进栈，没有就什么也不做、

非递归后序：1-从栈中弹出一个结点cur 2-弹出就放到另外一个栈里面 3-左右子树按顺序进栈，没有就什么也不做、4- 打印所有另外一个栈里面的结点。（这里是利用栈的逆序把根右左变成了左右根）

非递归中序：1-整个树的左边界全部进栈 2-弹出就打印 3-对弹出结点的右子树重复流程。（整棵树的按照左边界分解掉了，但是右树的左边界后做）



对于二叉树来说它的**先序遍历就是它的深度优先遍历**。现在要看看二叉树的广度优先遍历怎么写，也就是按层来打印。这里把上面的栈换成队列就行了，头先进，弹出就打印，先放左后放右，弹出就打印。



题目求一颗二叉树的最大宽度---也就是同层结点的最大个数。需要知道这一层是第几层，还要知道这一层有多少个结点。可以利用hashmap将每一个结点和层数对应起来。分别用一个变量来记录当前在第几层。另外一个变量记录这一层有多少个结点。再来一个变量记录所有层中的最大结点数。如果当前的层和之前记录的层不一样了就说明之前那个层要和max去结算了。从新的这个层开始算。

也有不用哈希表的。我们设置三个变量，当前节点所在层的最后一个结点curEnd和下一层的最后一个结点nextEnd，还有当前层。一开始当前层的最后一个结点设置为根节点，下一层的最后一个结点设置为null。根节点先进队，出来的时候先让左孩子进队，然后看看nextEnd为不为空，如果是空，就把它设置成当前入队的结点，再让右孩子进队，**永远把当前入队的结点让它等于nextEnd**。都入队之后，当前的结点的层就多发现了一个结点。然后看看当前结点是不是本层的最后一个结点curEnd,如果是,max就更新。然后迭代curend和nextend。

![image-20220409151640335](./image\image-20220409151640335.png)

代码-前中后序遍历

- 递归和非递归实现

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

public static void preOrderRecur(Node head) {
    if (head==null)
        return;
    System.out.print(head.value+" ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}

public static void inOrderRecur(Node head) {
    if (head==null)
        return;
    inOrderRecur(head.left);
    System.out.print(head.value+" ");
    inOrderRecur(head.right);
}

public static void posOrderRecur(Node head) {
    if (head==null)
        return;
    posOrderRecur(head.left);
    posOrderRecur(head.right);
    System.out.print(head.value+" ");
}

public static void preOrderUnRecur(Node head){
    System.out.print("preorder unrecur:");
    if (head==null)
        return;
    Stack<Node> stack =new Stack<>();
    stack.push(head);
    while(!stack.isEmpty()){
        head=stack.pop();
        System.out.print(head.value+" ");
        if (head.right!=null){
            stack.push(head.right);
        }
        if (head.left!=null){
            stack.push(head.left);
        }
    }
    System.out.println();
}

public static void preOrderUnRecur2(Node head){//ZheJiang
    if (head==null)
        return;
    Stack<Node> stack =new Stack<>();
    while(!stack.isEmpty()||head!=null){
        while(head!=null){
            stack.push(head);
            System.out.print(head.value+" ");
            head= head.left;
        }
        head= stack.pop();
        head=head.right;
    }
    System.out.println();
}

public static void inOrderUnRecur(Node head) {
    if (head==null)
        return;
    System.out.print("inorder unrecur:");
    Stack<Node> stack=new Stack<>();
    while(head!=null||!stack.isEmpty()){
        while(head!=null){
            stack.push(head);
            head= head.left;
        }
        head= stack.pop();
        System.out.print(head.value+" ");
        head=head.right;
    }
    System.out.println();
}

public static void posOrderUnRecur1(Node head){
    System.out.print("postorder unrecur:");
    if (head==null)
        return;
    Stack<Node> stack1=new Stack<>();
    Stack<Node> stack2=new Stack<>();
    while(head!=null||!stack1.isEmpty()){
        while(head!=null){
            stack1.push(head);
            stack2.push(head);
            head=head.right;
        }
        head=stack1.pop();
        head=head.left;
    }
    while(!stack2.isEmpty()){
        System.out.print(stack2.pop().value+" ");
    }
    System.out.println();
}

/**
 * 这里利用head来跟踪刚才打印过的结点，这样就能知道当前栈顶的结点的左子树处理完了没，右子树处理完了没。如果处理完了那么
 * 会打印孩子，这时候head也就跟踪了孩子。如果p.left!=head说明p的左孩子没处理过（注意这里p.right!=head因为右树处理完了就
 * 代表左孩子肯定处理完了），左孩子没有处理过那么我就去处理左孩子，就把左孩子压栈。如果p.right!=head那么就说明右孩子没有处理
 * 右孩子进栈。如果发现左右孩子都处理完了，那么我就打印自己。
 *
 * 代码有另外一种写法，就是先让左边界一条线压栈，然后打印，然后设置head。我们这里就是让head处理不会干扰我们的位置，
 * 这里“干扰”的含义就是不会干扰我们走逻辑分支，我们就是首先一条线左边界压栈了。head一开始是没有意义的，只要不干扰
 * 走逻辑分支1就行了。
 *
 * 核心思想就是利用head来标记现在栈顶的结点的子过程有没有完毕。
 * @param head
 */
public static void posOrderUnRecur2(Node head) {
    if (head==null)
        return;
    System.out.print("postorder unrecur :");
    Stack<Node> stack=new Stack<>();
    stack.push(head);
    Node p=null;
    while(!stack.isEmpty()){
        p= stack.peek();//瞥一眼栈顶，通过下面的逻辑分支来判断是三种情况的哪一种
        if (p.left!=null&&p.left!=head&&p.right!=head){//说明左子树还没有处理
            stack.push(p.left);
        }else if (p.right!=null&&p.right!=head){ //说明右子树没有处理
            stack.push(p.right);
        }else {//左右子树都处理完了，打印当前栈顶的结点。
            System.out.print(stack.pop().value+" ");
            head=p;//当第一次打印的时候，head才被赋予了它真正的含义
        }
    }
    System.out.println();
}

/**
 * 按照层序打印
 * @param head
 */
private static void printByLay(Node head){
    if (head==null)
        return;
    System.out.print("by lay:");
    Queue<Node> queue=new LinkedList<>();
    queue.add(head);
    while(!queue.isEmpty()){
        head=queue.poll();
        System.out.print(head.value+" ");
        if (head.left!=null){
            queue.add(head.left);
        }
        if (head.right!=null){
            queue.add(head.right);
        }
    }
    System.out.println();
}
```

代码-求最大宽度

```java
public static class Node {
   public int value;
   public Node left;
   public Node right;

   public Node(int data) {
      this.value = data;
   }
}

/**
 * 使用hashmap来实现最大宽度的求解
 * @param head
 * @return
 */
public static int getMaxWidth(Node head) {
   if (head==null)
      return 0;
   int max=-1;
   int curLay=1;
   int cur=0;
   Queue<Node> queue=new LinkedList<>();
   queue.add(head);
   HashMap<Node,Integer> hashMap=new HashMap<>();
   hashMap.put(head,1);
   while(!queue.isEmpty()){
      head=queue.poll();
      if (head.left!=null){
         queue.add(head.left);
         hashMap.put(head.left,curLay+1);
      }
      if (head.right!=null){
         queue.add(head.right);
         hashMap.put(head.right,curLay+1);
      }
      if (hashMap.get(head)!=curLay){
         max=Math.max(max,cur);
         curLay++;
         cur=1;
      }else{
         cur++;
      }
   }
   return max;
}

/**
 * 不使用哈希表实现最大宽度的求解，整体思路还是层序遍历
 * @param head
 * @return
 */
public static int getMaxWidth2(Node head){
   int max =-1;
   int curNum=0;
   Node cur=null;
   Node curLevel=head;//记录当前层的最后一个，一开始默认是头节点，因为头节点很自然的是第一层的最后一个结点
   Node nextLevel=null;//记录下一层的最后一个节点
   Queue<Node>queue=new LinkedList<>();
   queue.add(head);
   while(!queue.isEmpty()){
      cur=queue.poll();//每次弹出一个节点，把他的左右孩子入队（如果有的话）
      if (cur.left!=null){
         queue.add(cur.left);
         nextLevel= curLevel.left;//nextLevel的值就是最新入队的结点的值
      }
      if (cur.right!=null){
         queue.add(cur.right);
         nextLevel=curLevel.right;
      }
      curNum++;//cur的左右孩子都已经入队了之后把cur统计进当前层的结点总数
      if (cur==curLevel){//说明已经到大了当前层的最后一个结点了,结算max，并且迭代curlevel和nextlevel
         max=Math.max(max,curNum);
         curNum=0;//归零
         curLevel=nextLevel;
      }

   }
   return max;
}
```

---

- 判断是否是二叉搜索树

左树都比自己小右树都比自己大。

有一个方法，根据左小右大，我们用**中序遍历**可以保证不降序。原来打印的时机变成了和前面一个打印的结点比较的时机。我们把前面的结点用pre记下来。

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

/**
 * 二插搜索树的中序遍历打印的次序一定是非递减的，我们可以把打印行为替代为入队，然后按照从左到右一次检查
 * @param head
 * @return
 */
public static boolean isBST1(Node head) {
    if (head==null)
        return true;
    LinkedList<Node>list=new LinkedList<>();
    process1(head,list);
    int pre=Integer.MIN_VALUE;
    for (Node p:list){
        if (pre>=p.value)
            return false;
        pre=p.value;
    }
    return true;

}

/**
 * 服务isBST，作用是将以head为头的二叉搜索树以中序遍历的顺序入队
 * @param head
 * @param list
 */
public static void process1(Node head, LinkedList<Node> list) {
    if(head==null){
        return;
    }
    process1(head.left,list);
    list.add(head);
    process1(head.right,list);

}

public static boolean isBST2(Node head){
    if (head==null)
        return true;
    return process2(head).isBST;
}

/**
 * 一颗树要提供的信息有：它是不是二叉搜索树、它的最大值是多少、它的最小值是多少
 * 它是不是二插搜索树取决于它的左右子树是否都是二叉搜索树。并且根节点的值要大于左子树的最大值，小于右子树的
 * 最小值。这是一个可以递归的获取信息的过程。递归到null是一个基本情况，一个空结点我们认为它是一个二叉搜索树
 * 但是这里最大和最小值我们发现设置成什么都不合适。所以就让空节点返回一个空的Info
 */
public static class Info{
    public boolean isBST;
    public int max;
    public int min;

    public Info(boolean isBST,int max,int min){
        this.isBST=isBST;
        this.max=max;
        this.min=min;
    }
}

public static Info process2(Node head){
    if (head==null)
        return null;
    //获取信息
    Info left=process2(head.left);
    Info right=process2(head.right);
    //head的信息，要根据上面得到的左右子树的信息加工得到
    int min=head.value;//设置为自己，因为左右子树可能为空
    int max=head.value;//设置为自己，因为左右子树可能为空
    boolean isBST=true;
    //最小值，只可能出现在左子树。
    if (left!=null){
        min= left.min;
    }
    //最大值只可能出现在右子树上
    if (right!=null){
        max= right.max;
    }
    //如果出现根节点比左子树的最大值小的话说明不是二叉搜索树
    if (left!=null&&left.max>=head.value){
        isBST=false;
    }
    //如果出现根节点比右子树的最大值大的话说明不是二叉搜索树
    if (right!=null&&right.min<=head.value){
        isBST=false;
    }
    //如果左右子树中有其中一个不是二叉搜索树则整棵树都不是二叉搜索树
    if ((right!=null&& right.isBST==false)||(left!=null&& left.isBST==false)){
        isBST= false;
    }
    return new Info(isBST,max,min);
}
```

---

- 判断是否是完全二叉树

按照层序遍历。条件1：中间的任意结点如果有右无左那么直接返回false。条件2：在不违反条件1的情况下如果遇到了左右孩子不**双**全的情况，那么接下来的每一个结点都是叶子结点。

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

/**
 * 对层序遍历进行修改，如果发现某一个入队结点不是左右孩子健全的，那么接下来入队的结点都是叶子结点。
 * 入队的结点不能有左没右，否则就不是完全二叉树
 * @param head
 * @return
 */
public static boolean isCBT1(Node head) {
    if (head==null)
        return true;

    LinkedList<Node>list=new LinkedList<>();//队列
    list.add(head);
    boolean thing=false;//标记是否出现过左右儿子不双全的情况
    while(!list.isEmpty()){
        head= list.poll();
        if ((thing&&(head.left!=null||head.right!=null)) ||
                (head.right!=null && head.left==null)){
            return false;
        }
        if (head.left!=null){
            list.add(head.left);
        }
        if (head.right!=null){
            list.add(head.right);
        }
        if (head.left==null|| head.right==null){
            thing=true;
        }
    }
    return true;
}

public static boolean isCBT2(Node head) {
    return  process(head).isCom;
}

// 对每一棵子树，是否是满二叉树、是否是完全二叉树、高度
public static class Info {
    public boolean isCom;
    public boolean isFull;
    public int height;

    public Info(boolean isCom,boolean isFull,int height){
        this.height=height;
        this.isCom=isCom;
        this.isFull=isFull;
    }
}

public static Info process(Node head) {
    if (head==null){
        return new Info(true,true,0);
    }

    Info left=process(head.left);
    Info right=process(head.right);

    boolean isCom=false;
    boolean isFull=false;
    int height=0;

    if (left.isFull&& right.isFull&& left.height== right.height){
        isFull=true;
    }

    height=Math.max(left.height, right.height)+1;

    if (isFull){
        isCom=true;
    }else{
        if (left.isFull&& right.isFull&& left.height==right.height+1){
            isCom=true;
        }
        if (left.isFull&& right.isCom&& left.height== right.height){
            isCom=true;
        }
        if (left.isCom&& right.isFull&& left.height== right.height+1){
            isCom=true;
        }
    }
    return new Info(isCom,isFull,height);
}
```

---



- 判断平衡二叉树

```JAVA
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

/**
 * 利用后序遍历的递归序，在第三次返回结点的时候演算左右两边的高度是否差别小于等于1来判断是否为平衡二叉树。
 * 在这一整个过程中需要一个全局变量，这里我们使用一个数组来达到C语音中传进一个指针的效果，在上述的递归过程如果
 * 不是平衡二叉树就修改了指针的值。
 * @param head
 * @return
 */
public static boolean isBalanced1(Node head) {
    boolean[] ans=new boolean[1];
    ans[0]=true;//如果调用process过程中检测出不是平衡的就修改为false
    process1(head,ans);
    return ans[0];
}

public static int process1(Node head, boolean[] ans) {
    if (head==null)
        return 0;//空树默认高度为0
    int left=process1(head.left,ans);
    int right=process1(head.right,ans);
    if ((Math.abs(left-right))>1){
        ans[0]=false;
    }
    return Math.max(left,right)+1;
}

public static boolean isBalanced2(Node head) {
    return process(head).isBalance;
}

public static class Info{
    boolean isBalance;
    int height;

    public Info(boolean isBalance,int height){
        this.height=height;
        this.isBalance=isBalance;
    }
}

public static Info process(Node x) {
    if (x==null){//base case
        return new Info(true,0);
    }

    boolean isBalance=true;
    int height=0;

    Info left=process(x.left);
    Info right=process(x.right);

    if (!left.isBalance|| !right.isBalance){
        isBalance=false;
    }

    if (Math.abs(left.height- right.height)>1){
        isBalance=false;
    }

    height=Math.max(left.height, right.height)+1;

    return new Info(isBalance,height);

}
```

---



- 判断满二叉树

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

// 第一种方法
// 收集整棵树的高度h，和节点数n
// 只有满二叉树满足 : 2 ^ h - 1 == n
public static boolean isFull1(Node head) {
    Info1 res=process1(head);
    return (1<<res.height)-1== res.nodeNum;
}

public static class Info1 {
    public int nodeNum;
    public int height;

    public Info1(int nodeNum,int height){
        this.height=height;
        this.nodeNum=nodeNum;
    }
}

public static Info1 process1(Node head) {
    if (head==null){
        return new Info1(0,0);
    }

    int height=0;
    int nodeNUm=0;

    Info1 left=process1(head.left);
    Info1 right=process1(head.right);

    height= Math.max(left.height, right.height)+1;
    nodeNUm= left.nodeNum+ right.nodeNum+1;

    return new Info1(nodeNUm,height);
}

// 第二种方法
// 收集子树是否是满二叉树
// 收集子树的高度
// 左树满 && 右树满 && 左右树高度一样 -> 整棵树是满的
public static boolean isFull2(Node head) {
    return process2(head).isFull;
}

public static class Info2{
    boolean isFull;
    int height;

    public Info2(boolean isFull,int height){
        this.height=height;
        this.isFull=isFull;
    }
}

public static Info2 process2(Node head) {
    if (head==null){
        return new Info2(true,0);
    }

    boolean isFull=true;
    int height=0;

    Info2 left=process2(head.left);
    Info2 right=process2(head.right);

    height=Math.max(left.height, right.height)+1;
    isFull= left.isFull&& right.isFull&& left.height== right.height;

    return new Info2(isFull,height);
}
```

---



- 设计一棵树的打印函数

箭头是父函数调用给的

中间部分就是说明当前结点是如何打印的

打印的时候前面要留多少个空格是由层数决定的。

打印出来的值我们用一个String类型来表示。例如我们可以让String的长度永远是17，这样就不用担心值差距悬殊的时候会乱掉。

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

public static void printTree(Node head) {
    System.out.println("Binary Tree:");
    printInOrder(head, 0, "H", 17);
    System.out.println();
}

/**
 *我们将树逆时针旋转90°，这样一来就变成了右根左的递归序。然后我们要根据高度打印前面的空格，为了保持美观，我们将输出的值固定为
 * len长度的String，这样避免结点的值大小差距悬殊的时候破坏的了树的打印结构
 * @param head:打印以head为头的树
 * @param height:根据高度来决定行前打印的空格数
 * @param to:父亲结点调用传下来的参数，调用右子树传递"v"，调用左子树传递"^"
 * @param len:除了前面的空格，后面的打印的部分我固定为长度为len长度的String
 */
public static void printInOrder(Node head, int height, String to, int len) {
    if (head==null){
        return;
    }
    printInOrder(head.right, height+1, "v", len);

    String value=new String(to+head.value+to);
    int len1=(len-value.length())>>1;//左边的空格
    int len2=len-len1-value.length();//右边的空格
    String space1=getSpace(len1);//左边的空格
    String space2=getSpace(len2);//右边的空格
    String space3=getSpace(10*height);//和高度有关的空格
    System.out.println(space3+space1+value+space2);

    printInOrder(head.left, height+1, "^", len);

}

/**
 *
 * @param num:生成一个有num个空格的字符串
 * @return
 */
public static String getSpace(int num) {
    String space=new String(" ");
    StringBuffer buf=new StringBuffer();
    for (int i=0;i<num;i++){
        buf.append(space);
    }
    return buf.toString();
}
```

---



- 找最低公共祖先节点

- 给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点

就看node1往上和node2往上哪一个是最初汇聚的点。

一种方法就是我们把所有结点的父节点都记录到一个hashmap里面。然后把node1往上的祖先全部放到一个hashset里面，然后node2往上翻，第一个发现在hashset里面重复的点就是第一个相遇的结点。为什么要一个hashmap，因为这是我能够往上翻的前提。

有一个很精简的代码但是很难理解。node1和node2的所有情况就两大类。o1或者o2是另一个的公共祖先。还有一种情况就是o1o2不互为公共祖先，是通过汇聚的方式找到的。

---



- 找后继节点（特殊结构Node）

<img src="./image\image-20220409151732187.png" alt="image-20220409151732187" style="zoom:150%;" />

```
public static class Node {
    public int value;
    public Node left;
    public Node right;
    public Node parent;

    public Node(int data) {
        this.value = data;
    }
}

/**
 * 函数功能为找到任意一个结点x的后继结点。一种很显而易见的方法就是利用parent一直向上找，一直找到头节点，然后中序遍历找到x
 * 进而找到x的后继。但是这个一种递归序，复杂度一定是N。有一种想法就是我们能不能直接利用parent直接找到它的后继。
 * 注意到中序遍历的打印顺序是左中右。1. 如果一个结点有右孩子，那么打印完了这个结点一定是去打印右树的最左的结点。
 * 2.如果一个结点没有右孩子，那么打印完它之后就得往上找它的后继结点了，此时它是某一个结点的左子树的最后一个结点。也就是说
 * 我们要一直向上找，如果一个结点是父亲结点的右孩子就一直向上找，知道一个结点是父亲结点的左孩子就停，这个时候这个父亲节点
 * 就是之前结点的后继结点。因为这个结点是这个父亲结点的左树的最右的位置，也就是最后一个打印的位置。
 * @param node:返回node结点的后继节点
 * @return
 */
public static Node getSuccessorNode(Node node) {
    if (node==null)
        return null;
    if (node.right!=null){
        return getLeftMost(node.right);
    }else{
        while(node.parent!=null&&node.parent.right==node){//除了循环说明当前的node是它父亲的左孩子
            node=node.parent;
        }
        return node.parent;
    }
}

public static Node getLeftMost(Node node) {
    if (node==null)
        return null;
    while(node.left!=null){
        node= node.left;
    }
    return node;
}
```

---



- 序列化与反序列化

![image-20220409151745924](./image\image-20220409151745924.png)

```JAVA
/*
 * 二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化，
 * 以下代码全部实现了。
 * 但是，二叉树无法通过中序遍历的方式实现序列化和反序列化
 * 因为不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样。
 * 比如如下两棵树
 *         __2
 *        /
 *       1
 *       和
 *       1__
 *          \
 *           2
 * 补足空位置的中序遍历结果都是{ null, 1, null, 2, null}
 *
 * */
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

public static Queue<String> preSerial(Node head) {
    if (head==null){
        return null;
    }

    Queue<String> answer=new LinkedList<>();
    pres(head,answer);
    return answer;
}

public static void pres(Node head, Queue<String> answer) {
    if (head==null){
        answer.add(null);
    }else {
        answer.add(String.valueOf(head.value));
        pres(head.left,answer);
        pres(head.right,answer);
    }
}

public static Queue<String> inSerial(Node head){
    if (head==null){
        return null;
    }

    Queue<String> answer=new LinkedList<>();
    ins(head,answer);
    return answer;
}

public static void ins(Node head, Queue<String> answer){
    if (head==null){
        answer.add(null);
    }else {
        ins(head.left,answer);
        answer.add(String.valueOf(head.value));
        ins(head.right,answer);
    }
}

public static Queue<String> posSerial(Node head){
    if (head==null){
        return null;
    }

    Queue<String> answer=new LinkedList<>();
    poss(head,answer);
    return answer;
}

public static void poss(Node head, Queue<String> answer){
    if (head==null){
        answer.add(null);
    }else {
        poss(head.left,answer);
        poss(head.right,answer);
        answer.add(String.valueOf(head.value));
    }
}

public static Node buildByPreQueue(Queue<String> prelist){
    if (prelist==null||prelist.isEmpty()){
        return null;
    }

    return preb(prelist);
}

public static Node preb(Queue<String> prelist){
    String value=prelist.poll();//Node根据String的值来创建，只有String非空的时候才创建Node，否则Node就是空
    if (value==null){
        return null;
    }
    Node head=new Node(Integer.valueOf(value));
    head.left=preb(prelist);
    head.right=preb(prelist);
    return head;
}

public static Node buildByPosQueue(Queue<String> poslist){
    if (poslist==null||poslist.isEmpty()){
        return null;
    }
    Stack<String> stack=new Stack<>();
    while(!poslist.isEmpty()){//从栈中弹出的顺序是头右左
        stack.push(poslist.poll());
    }
    return posb(stack);
}

public static Node posb(Stack<String> posstack){
    String value=posstack.pop();
    if (value==null){
        return null;
    }
    Node head=new Node(Integer.valueOf(value));
    head.right=posb(posstack);
    head.left=posb(posstack);
    return head;

}

public static Queue<String> levelSerial(Node head){
    Queue<Node>queue=new LinkedList<>();//放结点
    Queue<String>res=new LinkedList<>();//放序列
    if (head==null){
        res.add(null);
    }else{
        res.add(String.valueOf(head.value));
        queue.add(head);
        Node p=null;
        while(!queue.isEmpty()){
            p=queue.poll();
            if (p.left!=null){
                res.add(String.valueOf(p.left.value));
                queue.add(p.left);
            }else {
                res.add(null);
            }
            if (p.right!=null){
                res.add(String.valueOf(p.right.value));
                queue.add(p.right);
            }else{
                res.add(null);
            }
        }
    }
    return res;
}

public static Node buildByLevelQueue(Queue<String> levelList){
    if (levelList==null||levelList.isEmpty()){
        return null;
    }
    Queue<Node> queue=new LinkedList<>();//装非空的Node，作用和层序遍历的队列一样
    Node head=generateNode(levelList.poll());
    if (head!=null){
        queue.add(head);
        Node p=null;
        while(!queue.isEmpty()){
            p= queue.poll();
            p.left=generateNode(levelList.poll());
            p.right=generateNode(levelList.poll());
            if (p.left!=null){
                queue.add(p.left);
            }
            if (p.right!=null){
                queue.add(p.right);
            }
        }
    }
    return head;
}

public static Node generateNode(String val){
    if (val==null)
        return null;
    return new Node(Integer.valueOf(val));
}
```

---

- 折纸问题

![image-20220409151751641](./image\image-20220409151751641.png)

```JAVA
public static void printAllFolds(int N) {
    process(1, N, true);
    System.out.println();
}

// 当前你来了一个节点，脑海中想象的！
// 这个节点在第i层，一共有N层，N固定不变的
// 这个节点如果是凹的话，down = T
// 这个节点如果是凸的话，down = F
// 函数的功能：中序打印以你想象的节点为头的整棵树！
public static void process(int i, int N, boolean down) {
    if (i > N) {
        return;
    }
    process(i + 1, N, true);
    System.out.print(down ? "凹 " : "凸 ");
    process(i + 1, N, false);
}
```

---

- 树的最大距离

- 题目：返回整棵树的最大距离。一个结点到另一个结点的最大距离就是中间要经过的节点数（算上自己）

```JAVA
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

public static int maxDistance1(Node head) {
    if (head == null) {
        return 0;
    }
    ArrayList<Node> arr = getPrelist(head);
    HashMap<Node, Node> parentMap = getParentMap(head);
    int max = 0;
    for (int i = 0; i < arr.size(); i++) {
        for (int j = i; j < arr.size(); j++) {
            max = Math.max(max, distance(parentMap, arr.get(i), arr.get(j)));
        }
    }
    return max;
}

public static ArrayList<Node> getPrelist(Node head) {
    ArrayList<Node> arr = new ArrayList<>();
    fillPrelist(head, arr);
    return arr;
}

public static void fillPrelist(Node head, ArrayList<Node> arr) {
    if (head == null) {
        return;
    }
    arr.add(head);
    fillPrelist(head.left, arr);
    fillPrelist(head.right, arr);
}

public static HashMap<Node, Node> getParentMap(Node head) {
    HashMap<Node, Node> map = new HashMap<>();
    map.put(head, null);
    fillParentMap(head, map);
    return map;
}

public static void fillParentMap(Node head, HashMap<Node, Node> parentMap) {
    if (head.left != null) {
        parentMap.put(head.left, head);
        fillParentMap(head.left, parentMap);
    }
    if (head.right != null) {
        parentMap.put(head.right, head);
        fillParentMap(head.right, parentMap);
    }
}

public static int distance(HashMap<Node, Node> parentMap, Node o1, Node o2) {
    HashSet<Node> o1Set = new HashSet<>();
    Node cur = o1;
    o1Set.add(cur);
    while (parentMap.get(cur) != null) {
        cur = parentMap.get(cur);
        o1Set.add(cur);
    }
    cur = o2;
    while (!o1Set.contains(cur)) {
        cur = parentMap.get(cur);
    }
    Node lowestAncestor = cur;
    cur = o1;
    int distance1 = 1;
    while (cur != lowestAncestor) {
        cur = parentMap.get(cur);
        distance1++;
    }
    cur = o2;
    int distance2 = 1;
    while (cur != lowestAncestor) {
        cur = parentMap.get(cur);
        distance2++;
    }
    return distance1 + distance2 - 1;
}

public static int maxDistance2(Node head) {
    return process(head).maxDistance;
}

public static class Info {
    public int maxDistance;
    public int height;

    public Info(int m, int h) {
        maxDistance = m;
        height = h;
    }

}

/**
 * 可能性分析：1. 如果最大距离经过了x，那么最大距离就是左树的高度和右树的高度之和+1
 * 2. 如果最大距离没有经过x，那么最大距离就是左右子树中最大距离中较大的那个
 * 这样我们就列出了全部的最大距离的可能性,最大距离就是1和2两种情况中最大的那个
 *
 * 高度没有可能性可言，就是左右子树中的高度较大者+1
 * @param x
 * @return
 */
public static Info process(Node x) {
    if (x==null){
        return new Info(0,0);
    }

    Info left=process(x.left);
    Info right=process(x.right);

    int maxDistance=0;
    int height=0;

    maxDistance= Math.max(Math.max(left.maxDistance,right.maxDistance), left.height+right.height+1);
    height= Math.max(left.height, right.height)+1;

    return new Info(maxDistance,height);

}
```

---



- 最大二叉搜索子树

```JAVA
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

public static int getBSTSize(Node head) {
    if (head == null) {
        return 0;
    }
    ArrayList<Node> arr = new ArrayList<>();
    in(head, arr);
    for (int i = 1; i < arr.size(); i++) {
        if (arr.get(i).value <= arr.get(i - 1).value) {
            return 0;
        }
    }
    return arr.size();
}

public static void in(Node head, ArrayList<Node> arr) {
    if (head == null) {
        return;
    }
    in(head.left, arr);
    arr.add(head);
    in(head.right, arr);
}

public static int maxSubBSTSize1(Node head) {
    if (head == null) {
        return 0;
    }
    int h = getBSTSize(head);
    if (h != 0) {
        return h;
    }
    return Math.max(maxSubBSTSize1(head.left), maxSubBSTSize1(head.right));
}

public static int maxSubBSTSize2(Node head) {
    if(head == null) {
        return 0;
    }
    return process(head).maxBSTSubtreeSize;
}

//递归套路需要的信息
public static class Info {
    public int maxBSTSubtreeSize;
    public boolean isAllBst;
    public int max;
    public int min;

    public Info(int maxBSTSubtreeSize, boolean isAllBst, int max, int min) {
        this.maxBSTSubtreeSize = maxBSTSubtreeSize;
        this.isAllBst = isAllBst;
        this.max = max;
        this.min = min;
    }
}

/**
 * 方法就是向左右子树要信息。
 * 可能性1.信息和x结点无关。也就是说明左右子树有至少一个为不是二叉搜索树。此时最大的二叉搜索子树大小就是左右子树的最大二插子树大小中较大的那个
 * 可能性2.信息和x结点有关。这时候就说明左右子树都是二叉搜索树。最大的二叉搜索子树就变成了以x为头的树的大小。
 *
 * @param x:返回以x为头的树的相关信息，包括了以x为头的子树是不是二叉搜索树、x为头的子树的最大值、x为头的子树的最小值、
 *         x为头的最大子搜索树的大小（结点个数）。
 * @return
 */
public static Info process(Node x) {
    if (x==null){
        return null;//返回空是因为min和max返回什么都不是很合适
    }

    Info left=process(x.left);
    Info right=process(x.right);

    int maxBSTSubtreeSize=0;
    boolean isAllBst=true;
    int max=x.value;
    int min=x.value;

    if (right!=null){
        max=Math.max(right.min,x.value);
    }
    if (left!=null){
        min=Math.min(left.max,x.value);
    }

    isAllBst= left.isAllBst&&right.isAllBst&&x.value> left.max&&x.value< right.min;

    maxBSTSubtreeSize=isAllBst? left.maxBSTSubtreeSize+ right.maxBSTSubtreeSize+1:
            Math.max(left.maxBSTSubtreeSize,right.maxBSTSubtreeSize);

    return new Info(maxBSTSubtreeSize,isAllBst,max,min);



}
```

---



- 派对的最大快乐值

 * 题目：派对的最大快乐值

   公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。树的头节点是公司唯一的老板。

   除老板之外的每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工(subordinates列表为空)，

   除基层员工外，每个员工都有一个或多个直接下级。

```java
public class Code15_MaxHappy {
    public static class Employee {
        public int happy;
        public List<Employee> nexts;

        public Employee(int h) {
            happy = h;
            nexts = new ArrayList<>();
        }
    }

    public static int maxHappy1(Employee boss) {
        if (boss == null) {
            return 0;
        }
        return process1(boss, false);
    }

    // 当前来到的节点叫cur，
    // up表示cur的上级是否来，
    // 该函数含义：
    // 如果up为true，表示在cur上级已经确定来，的情况下，cur整棵树能够提供最大的快乐值是多少？
    // 如果up为false，表示在cur上级已经确定不来，的情况下，cur整棵树能够提供最大的快乐值是多少？
    public static int process1(Employee cur, boolean up) {
        if (up) { // 如果cur的上级来的话，cur没得选，只能不来
            int ans = 0;
            for (Employee next : cur.nexts) {
                ans += process1(next, false);
            }
            return ans;
        } else { // 如果cur的上级不来的话，cur可以选，可以来也可以不来
            int p1 = cur.happy;
            int p2 = 0;
            for (Employee next : cur.nexts) {
                p1 += process1(next, true);
                p2 += process1(next, false);
            }
            return Math.max(p1, p2);
        }
    }

    public static int maxHappy2(Employee head) {
        Info allInfo = process(head);
        return Math.max(allInfo.no, allInfo.yes);
    }

    public static class Info {
        public int no;//x不来时候的最大快乐值
        public int yes;//x来时候的最大快乐值

        public Info(int n, int y) {
            no = n;
            yes = y;
        }
    }

    public static Info process(Employee x) {
        if(x==null){
            return new Info(0,0);
        }
        if (x.nexts.isEmpty()){
            return new Info(0,x.happy);
        }

        int no=0;
        int yes=x.happy;

        for (Employee employee:x.nexts){
            no+=Math.max(process(employee).no,process(employee).yes);
            yes+=process(employee).no;
        }

        return new Info(no,yes);
    }
```

## 前缀树

1) 单个字符串中，字符从前到后的加到一棵多叉树上
2) 字符放在路上，节点上有专属的数据项（常见的是pass和end值)
3) 所有样本都这样添加，如果没有路就新建，如有路就复用
4) 沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1可以完成前缀相关的查询

- 每一个结点都有两个字段：pass 和 end。

  pass：如果有一个字符经过了这个结点，那么这个结点的pass值就加一

  end：如果一个字符是一个字符串的结尾，那么当前停在的结点的end值加一

- 流程：每一次添加一个字符串都从头节点开始。如果有通往某一个字符的路那么就复用。如果没有就新建。

- 作用：

  1. 可以确定一个字符串是否有被记录过，和记录过几次---end值
  2. 可以知道有多少字符串以另一个字符串作为前缀---pass值。只要你通过了我，那么你就是以我之前的路径作为前缀的。
  3. 可以在特殊题目上再前缀树的节点上增加额外的信息支持解决问题。



```java
public static class Node{
    public int pass;
    public int end;
    public Node[] next;//指路

    public Node(){
        pass=0;
        end=0;
        next=new Node[26];//假设我们只放26个字母的小写，那么我们就有26条路
    }


}

public static class Trie1 {
    public Node head;

    public Trie1(){
        head=new Node();
    }

    public void insert(String val){
        if (val==null) {
            return;
        }

        char[] arr=val.toCharArray();
        Node p=head;
        p.pass++;
        for (char a:arr){
            if (p.next[a-'a']==null){
                p.next[a-'a']=new Node();
            }
            p=p.next[a-'a'];
            p.pass++;
        }
        p.end++;
    }

    /**
     * 找val在前缀树中存入了几次。
     * 思路很简单，就是怎么加的就怎么找。
     * @param val
     * @return
     */
    public int search(String val){
        if (val==null) {
            return 0;
        }

        char[] arr=val.toCharArray();
        Node p=head;
        for(char a:arr){
            if (p.next[a-'a']==null){
                return 0;
            }
            p=p.next[a-'a'];
        }
        return p.end;
    }

    public int prefixNumber(String val){
        if (val==null){
            return 0;
        }

        char[] arr=val.toCharArray();
        Node p=head;
        for (char a:arr){
            if (p.next[a-'a']==null){
                return 0;
            }
            p=p.next[a-'a'];
        }
        return p.pass;
    }

    public void delete(String val){
        if (search(val)==0){
            return;
        }

        char[] arr=val.toCharArray();
        Node p=head;
        p.pass--;
        for (char a:arr){
            if (--p.next[a-'a'].pass==0){
                p.next[a-'a']=null;
                return;
            }
            p=p.next[a-'a'];
        }
        p.end--;
    }
}

public static class Node2 {
    public int pass;
    public int end;
    public HashMap<Integer, Node2> nexts;//26个大小的空间不够就用这个，Integer表示这条路的ASCII码值

    public Node2() {
        pass = 0;
        end = 0;
        nexts = new HashMap<>();
    }
}

public static class Trie2 {
    private Node2 root;

    public Trie2() {
        root = new Node2();
    }

    public void insert(String word) {
        if (word == null) {
            return;
        }
        char[] chs = word.toCharArray();
        Node2 node = root;
        node.pass++;
        int index = 0;
        for (int i = 0; i < chs.length; i++) {
            index = (int) chs[i];
            if (!node.nexts.containsKey(index)) {
                node.nexts.put(index, new Node2());
            }
            node = node.nexts.get(index);
            node.pass++;
        }
        node.end++;
    }

    public void delete(String word) {
        if (search(word) != 0) {
            char[] chs = word.toCharArray();
            Node2 node = root;
            node.pass--;
            int index = 0;
            for (int i = 0; i < chs.length; i++) {
                index = (int) chs[i];
                if (--node.nexts.get(index).pass == 0) {
                    node.nexts.remove(index);
                    return;
                }
                node = node.nexts.get(index);
            }
            node.end--;
        }
    }

    // word这个单词之前加入过几次
    public int search(String word) {
        if (word == null) {
            return 0;
        }
        char[] chs = word.toCharArray();
        Node2 node = root;
        int index = 0;
        for (int i = 0; i < chs.length; i++) {
            index = (int) chs[i];
            if (!node.nexts.containsKey(index)) {
                return 0;
            }
            node = node.nexts.get(index);
        }
        return node.end;
    }

    // 所有加入的字符串中，有几个是以pre这个字符串作为前缀的
    public int prefixNumber(String pre) {
        if (pre == null) {
            return 0;
        }
        char[] chs = pre.toCharArray();
        Node2 node = root;
        int index = 0;
        for (int i = 0; i < chs.length; i++) {
            index = (int) chs[i];
            if (!node.nexts.containsKey(index)) {
                return 0;
            }
            node = node.nexts.get(index);
        }
        return node.pass;
    }
}

public static class Right {

    private HashMap<String, Integer> box;

    public Right() {
        box = new HashMap<>();
    }

    public void insert(String word) {
        if (!box.containsKey(word)) {
            box.put(word, 1);
        } else {
            box.put(word, box.get(word) + 1);
        }
    }

    public void delete(String word) {
        if (box.containsKey(word)) {
            if (box.get(word) == 1) {
                box.remove(word);
            } else {
                box.put(word, box.get(word) - 1);
            }
        }
    }

    public int search(String word) {
        if (!box.containsKey(word)) {
            return 0;
        } else {
            return box.get(word);
        }
    }

    public int prefixNumber(String pre) {
        int count = 0;
        for (String cur : box.keySet()) {
            if (cur.startsWith(pre)) {
                count += box.get(cur);
            }
        }
        return count;
    }
}
```

## 打表法

![image-20220512213852450](./image\image-20220512213852450.png)

### 买苹果问题

![image-20220512213910040](./image\image-20220512213910040.png)

- 分解质因数法 ---找两个数的最小公倍数

  分解质因数法就是先把要求最小公倍数的那几个数分别分解质因数，然后将原来几个数里所含该质因数的最多个数的每一个质因数相乘，所得的积就是要求的最小公倍数。 

  如：求60、42的最小公倍数。 

  解：60=2×2×3×5 42=2×3×7 

  60和42的最小公倍数=2×3×2×5×7=420 。 

  这种方法是把60和42分别质因数后，观察相同的质因数只取一个（如2，3），把各自独有的质因数全部乘进去，所得的积就是这两个数的最小公倍数。





### 吃草问题

![image-20220512214043443](./image\image-20220512214043443.png)

```java
// n份青草放在一堆
// 先手后手都绝顶聪明
// string "先手" "后手"
public static String winner1(int n) {
    if (n==0){
        return "后手";
    }
    int eat=1;
    while(true){
        if (winner1(n-eat).equals("后手")){
            return "先手";
        }
        if (eat>n/4){
            break;//退出条件放在这里是为了防止越界
        }
        eat*=4;
    }
    return "后手";
}

public static String winner2(int n) {
    if (n==0){
        return "后手";
    }
    return ((n-1)%5==2||(n-1)%5==4)?"后手":"先手";
}
```

### 连续累加数

![image-20220512214006417](./image\image-20220512214006417.png)

``` java
public static boolean isMSum1(int num) {
    if (num <= 1) {
        return false;
    }

    for (int i = 1; i <= num; i++) {//控制开头
        int sum = i;
        for (int j = i + 1; j <= num; j++) {
            sum += j;
            if (sum == num) {
                return true;
            } else if (sum > num) {
                break;
            }
        }
    }
    return false;
}

public static boolean isMSum2 ( int num){
    return (num & (num - 1)) != 0;
}
```



### 开灯关灯问题

- 有一个布尔类型的数组，有先手和后手之分。先手和后手和可以把i~0位的布尔值取反。谁率先把数组里面的数都变成true谁赢。

我们可以把布尔数组转发成int，然后打表找规律。



## 矩阵打印

1) zigzag打印矩阵
2) 转圈打印矩阵
3) 原地旋转正方形矩阵

- 核心技巧:找到coding上的宏观调度

### zigzag打印

![image-20220514135526482](./image\image-20220514135526482.png)

```java
public static void printMatrixZigZag(int[][] matrix) {
    int rEnd = matrix.length-1;//最大行数下标--有多少个一维数组
    int cEnd = matrix[0].length-1;//最大列数下标--每一个一维数组有多少个元素
    int a = 0;//(a,b)在上右边运动
    int b = 0;
    int c = 0;//(c,d)在左下边运动
    int d = 0;
    boolean up = true;
    while (a != rEnd+1) {
        printLevel(matrix, a, b, c, d, up);
        a = b == cEnd ? a + 1 : a;//a先更新，因为a的更新会收列的影响
        b = b == cEnd ? b : b + 1;
        d = c == rEnd ? d + 1 : d;
        c = c == rEnd ? c : c + 1;
        up = !up;
    }
    System.out.println();
}

/**
 * @param m:矩阵
 * @param a:(a,b)在上面和右面的边运动
 * @param b:
 * @param c:(c,d)在左边和下面的边运动
 * @param d:
 * @param up:如果up为true就自下往上打印
 */
public static void printLevel(int[][] m, int a, int b, int c, int d, boolean up) {
    if (m == null) {
        return;
    }
    if (up) {//自下往上打印
        while (c != a - 1) {
            System.out.print(m[c--][d++] + " ");
        }
    } else {//自上往下打印
        while (a!=c+1) {
            System.out.print(m[a++][b--] + " ");
        }
    }
}
```

### 转圈打印矩阵

![image-20220514135707977](./image\image-20220514135707977.png)

```java
public static void spiralOrderPrint(int[][] matrix) {
    int a=0;
    int b=0;
    int c=matrix.length-1;
    int d=matrix[0].length-1;
    while(a<=c){//直到他们碰上
        printEdge(matrix,a++,b++,c--,d--);
    }
}

public static void printEdge(int[][] m, int a, int b, int c, int d) {
    if(m==null){
        return;
    }
    if (a==c){//横线和单点的逻辑
        while(b!=d+1){
            System.out.print(m[a][b++]+" ");
        }
    }else if(b==d){//竖线的逻辑
        while(a!=c+1){
            System.out.print(m[a++][b]+" ");
        }
    }else{//长方形的逻辑
        //打印上面
        int b2=b;
        while (b2!=d){//不让碰上
            System.out.print(m[a][b2++]+" ");
        }
        //打印右边
        int a2=a;
        while (a2!=c){

            System.out.print(m[a2++][d]+" ");
        }
        //打印下边
        int d2=d;
        while (d2!=b){
            System.out.print(m[c][d2--]+" ");
        }
        //打印左边
        int c2=c;
        while(c2!=a){
            System.out.print(m[c2--][b]+" ");
        }
    }
}
```

### 原地旋转正方形矩阵

![image-20220514135754620](./image\image-20220514135754620.png)

```java
public static void rotate(int[][] matrix) {
    int a=0;
    int b=0;
    int rEnd=matrix.length-1;
    int cEnd=matrix[0].length-1;
    while(a<=rEnd){
        rotateEdge(matrix,a++,b++,rEnd--,cEnd--);
    }
}

public static void rotateEdge(int[][] m, int a, int b, int c, int d) {
    if(m==null||d-b!=c-a){
        return;
    }
    for (int i=0;i<c-a;i++){//一共有c-a组
        int temp=m[a][i+b];//第i组的一号
        m[a][i+b]=m[c-i][b];//第i组的4号赋值给第i组的1号
        m[c-i][b]=m[c][d-i];//第i组的3号赋值给第i组的4号
        m[c][d-i]=m[a+i][d];
        m[a+i][d]=temp;
    }
}

public static void printMatrix(int[][] matrix) {
    for (int i = 0; i != matrix.length; i++) {
        for (int j = 0; j != matrix[0].length; j++) {
            System.out.printf("%3d",matrix[i][j]);
        }
        System.out.println();
    }
}
```

## 贪心算法

**贪心算法求解的标准过程**

- 1，分析业务
  2，根据业务逻辑找到不同的贪心策略
  3，对于能举出反例的策略直接跳过，不能举出反例的策略要证明有效性
- 这往往是特别困难的，要求数学能力很高且不具有统一的技巧性

**贪心算法的解题套路**

- 1，实现一个不依靠贪心策略的解法×，可以用最暴力的尝试
  2，脑补出贪心策略A、贪心策略B、贪心策略C...
  3，用解法X和对数器，用实验的方式得知哪个贪心策略正确
  4，不要去纠结贪心策略的证明

**贪心算法**

- 1)最自然智慧的算法
  2)用一种局部最功利的标准，总是做出在当前看来是最好的选择
  3)难点在于证明局部最功利的标准可以得到全局最优解
  4)对于贪心算法的学习主要以增加阅历和经验为主

### 会议室宣讲

- 一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。

  给你每一个项目开始的时间和结束的时间。

  你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回最多的宣讲场次。

发现这一题我们按照会议最短的时间来安排或者按照会议最早的时间来安排都不能得到最优解，因为我们可以找出反例。

![image-20220516144321879](./image\image-20220516144321879.png)

- 这一题的正确的贪心是按照谁最早结束就安排谁

#### 代码

```java
public static class Program {
    int start;
    int end;

    public Program(int start, int end) {
        this.start = start;
        this.end = end;
    }
}

public static int bestArrange1(Program[] arr) {
    if (arr==null||arr.length==0){
        return 0;
    }
    return process1(arr,0,0);
}

/**
 *
 * @param arr:还剩下的没安排的会议
 * @param done:已经安排了几个会议
 * @param timeLine:现在来到的时间点
 * @return
 */
public static int process1(Program[] arr,int done,int timeLine){
    if (arr==null||arr.length==0){
        return 0;
    }
    int best=done;
    for (int i=0;i<arr.length;i++){
        if (arr[i].start>=timeLine){
            Program[] p=copyButExcept(arr,i);
            best=Math.max(best,process1(arr,done+1,arr[i].end));//利用递归for，让best一直更新
        }
    }
    return best;
}

public static Program[] copyButExcept(Program[] arr,int index){
    int i=0;//给p用
    Program[] p=new Program[arr.length-1];
    for (int j=0;j<arr.length;j++){//遍历arr
        if (j!=index){
            p[i++]=arr[j];
        }
    }
    return p;
}

public static int bestArrange2(Program[] arr){
    int timeLine=0;
    int best=0;
    Arrays.sort(arr,new ProgramComparator());//按照结束时间先后来排序
    for (int i=0;i<arr.length;i++){
        if (arr[i].start>=timeLine){
            best++;
            timeLine=arr[i].end;
        }
    }
    return best;
}

public static class ProgramComparator implements Comparator<Program>{
    public int compare(Program o1,Program o2){
        return o1.end-o2.end;
    }
}
```



### 放灯

- 题目：给定一个字符串str,“只由×'和∵'两种字符构成。‘×'表示墙，不能放灯，也不需要点亮
  ".'表示居民点，可以放灯，需要点亮
  如果灯放在i位置，可以让i-1， i和i+1三个位置被点亮返回如果点亮str中所有需要点亮的位置，至少需要几盏灯

- 代码技巧：如果递归公用老的数组就需要恢复现场，如果每次都复制出一个新的就不需要恢复现场。

- 如何贪心：

  第一个分支：如果i位置是一个x，那么直接跳到i+1位置做决定

  第二个分支：

  - 如果i位置是一个点，i+1位置是一个x，那么就在i位置放灯，跳到I+2位置做决定。
  - 如果i位置是一个点，i+1位置也是一个点，那么就在i+1的位置放灯，跳到I+3位置做决定。i+2位置不用管了，因为不管是不是墙都是满足的。
  - 如果i位置是一个点，i+1位置没有字符了，那么就在i位置放一个灯，结束。



#### 代码--暴力递归

```java
/**
 * 利用暴力递归来实现
 *
 * @param road:只带有叉和点的字符串
 * @return
 */
public static int minLight1(String road) {
    if (road==null||road.length()==0){
        return Integer.MAX_VALUE;
    }
    return process1(road.toCharArray(),0,new HashSet<Integer>());
}

/**
 * 因为index之前的位置已经决定好了，我们只需要决定index之后的位置是否放灯即可，最后lights中的元素个数就是灯的总数。
 * 每到一个'点'都有两种情况,放灯或者不放灯，我们让它递归下去。然后判断‘点’自己有没有被点亮，点亮说明左右两边或者自己位置有灯
 * 注意：在递归的时候不要把叉和点区别对待，不然不好递归
 * @param road:只带有叉和点的字符数组
 * @param index:在index之前的位置已经做好了是否放灯的决定---不包括index自己
 * @param lights:决定放灯的位置记录在light中
 * @return :返回能够照亮所有居民点的最少灯数
 */
public static int process1(char[] road, int index, HashSet<Integer> lights) {
    if (index == road.length) {//结束--base case//说明[0,road.length-1]做完决定
        for (int i = 0; i < road.length; i++) {//对于数组里面的每一个点都进行判断
            if (road[i]=='.'&&!lights.contains(i - 1) && !lights.contains(i) && !lights.contains(i + 1)) {
                return Integer.MAX_VALUE;//说明没有照亮所有的居民区
            }
        }
        return lights.size();
    } else {//还未结束
        int no=process1(road,index+1,lights);//index位置不放灯
        int yes=Integer.MAX_VALUE;//index位置放灯,如果index位置是x那么将一直保持MAX_VALUE
        if (road[index]=='.'){//只有index位置是'点'这个yes才有意义。因为墙不能放灯
            lights.add(index);
            yes=process1(road,index+1,lights);
            lights.remove(index);
        }
        return Math.min(no,yes);

    }
}
```



- 可能出错的地方：no或者yes不能多加lights，因为process本身就是一个全局的最小值。

  int no=process1(road,index+1,lights)+lights.size();

- 由于这里有递归方法，所以样本的大小要小一点，否则一直压栈速度慢，甚至可能溢出。



#### 代码--贪心

```java
public static int minLights2(String road) {
    if (road == null || road.length() == 0) {
        return 0;
    }
    return process2(road.toCharArray());
}

/**
 * 潜台词：index前面的影响不到index
 *
 * @param road:数组空不空在minLights2控制，这里默认是非空
 * @return
 */
public static int process2(char[] road) {
    int index = 0;
    int res = 0;
    while (index < road.length) {//因为index后跳的距离不规律所以不用for循环
        if (road[index] == 'x') {
            index++;
        } else {//index是点
            if (index + 1 == road.length) {//index后面没有了，那么只能在index放灯
                res++;
                break;
            } else {//index后面还有
                if (road[index + 1] == 'x') {//index+1是x
                    res++;
                    index += 2;
                } else {//index+1是点,不管index+2是x还是‘点’我们都要在index+1的位置放灯，然后跳到index+3
                    res++;
                    index += 3;
                }
            }
        }
    }
    return res;
}
```

### 切金条

- 一块金条切成两半，是需要花费和长度数值一样的铜板的。
  比如长度为20的金条，不管怎么切，都要花费20个铜板。一群人想整分整块金条，怎么分最省铜板?
  例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。
  如果先把长度60的金条分成10和50，花费60;再把长度50的金条分成20和30，花费50;—共花费110铜板。但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20，花费30;—共花费90铜板。

  输入一个数组，返回分割的最小代价。



#### 代码

```java
public static int lessMoney1(int[]arr){
    if (arr==null||arr.length==0){
        return 0;
    }
    return process1(arr,0);
}

/**
 *暴力的思路就是不断的去更新这个less。和安排会议思路差不多
 * @param arr:现在需要合并的金条，逆向思维寻求最小金额。
 * @param preMoney:因为是递归函数，子调用需要从父调用中得知之前已经累计了多少金额
 * @return
 */
public static int process1(int []arr,int preMoney){
    if (arr.length==1){
        return preMoney;
    }
    int less=Integer.MAX_VALUE;
    for (int i=0;i<arr.length;i++){
        for (int j=i+1;j<arr.length;j++){
            int []p=mergeTwoNum(arr,i,j);
            less=Math.min(less,process1(p,preMoney+arr[i]+arr[j]));
        }
    }
    return less;
}

public static int[] mergeTwoNum(int[]arr,int i,int j){
    int[] p=new int[arr.length-1];
    int index=0;//p
    for (int k=0;k<arr.length;k++){
        if (k!=i&&k!=j){
            p[index++]=arr[k];
        }
    }
    p[index]=arr[i]+arr[j];
    return p;
}

public static int lessMoney2(int[] arr){
    PriorityQueue<Integer> heap=new PriorityQueue<>();
    for (int a:arr){
        heap.add(a);
    }
    int sum=0;
    int cur=0;
    while (heap.size()>=2){
        cur=heap.poll()+heap.poll();//产生这次要付的钱
        sum+=cur;
        heap.add(cur);
    }
    return sum;
}
```



### 获得最大钱数

- 题目：输入:正数数组costs、正数数组profits、正数K、正数M
  costs[i]表示i号项目的花费
  profits[们]表示i号项目在扣除花费之后还能挣到的钱(利润)

  K表示你只能串行的最多做k个项目
  M表示你初始的资金
  说明:每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。输出:你最后获得的最大钱数。

![image-20220517225709367](./image\image-20220517225709367.png)

#### 代码

```java
public static class Program {
    public int cost;
    public int capital;

    public Program(int cost, int capital) {
        this.cost = cost;
        this.capital = capital;
    }
}

public static class LessCostComparator implements Comparator<Program>{
    @Override
    public int compare(Program o1, Program o2) {
        return o1.cost-o2.cost;
    }
}

public static class MoreCostComparator implements Comparator<Program>{
    @Override
    public int compare(Program o1, Program o2) {
        return o2.capital-o1.capital;
    }
}

/**
 * cost数组一定和capital数组等长
 * @param k:最多接收k个项目
 * @param w:是初始资金
 * @param cost:数组下标i代表第i个项目的花费
 * @param capital:第i个项目的净利润
 * @return
 */
public static int findMax(int k, int w, int[] cost, int[] capital) {
    PriorityQueue<Program> costHeap=new PriorityQueue<>(new LessCostComparator());
    PriorityQueue<Program> capitalHeap=new PriorityQueue<>(new MoreCostComparator());
    for (int i=0;i<cost.length;i++){//全部放入costHeap等待解锁
        costHeap.add(new Program(cost[i],capital[i]));
    }
    for (int i=0;i<k;i++){
        while(!costHeap.isEmpty()&&w>=costHeap.peek().cost){//有有待解锁的项目，并且我有能力启动
            capitalHeap.add(costHeap.poll());
        }
        if (capitalHeap.isEmpty()){
            return w;
        }
        w+=capitalHeap.poll().capital;
    }
    return w;
}
```



## 并查集

- 1)有若干个样本a、b、c、d…类型假设是V
  2)在并查集中一开始认为每个样本都在单独的集合里

  3)用户可以在任何时候调用如下两个方法:

  ​		`boolean isSameSet(V x,V y)`:查询样本x和样本y是否属于一个集合

  ​		`void union(V x,V y)`:把x和y各自所在集合的所有样本合并成一个集合

  4)isSameSet和union方法的代价越低越好

![image-20220516190459154](./image\image-20220516190459154.png)

- 并查集的大致思路就是如上。但是实现的方法有很多。

- 这里的并查集是用链表来实现的。这里有两个可以优化的地方，一个是在找父亲的时候，要沿途中要把链变成扁平的，就是全部都指向他们的最终父亲。还有一个就是小的集合挂在大的集合下面。
- 虽然我们这里把沿途的链变成扁平有额外的开销，但是分摊到每一次上，总体的时间复杂度就是O(1)的。

```java
/**
 * nodes表用来记录每一个结点
 * parents表用来记录每一个结点的代表结点,用于实现向上指
 * size表只有当一个结点是代表结点的时候才会有记录
 * 所有方法中的V v，默认都是在并查集里面的
 * @param <V>
 */
public static class UnionFind<V> {

    public static class Node<V> {
        V value;

        public Node(V value) {
            this.value = value;
        }
    }

    public HashMap<V, Node> nodes;
    public HashMap<Node, Node> parents;
    public HashMap<Node, Integer> size;

    public UnionFind(List<V> values) {
        nodes = new HashMap<>();
        parents = new HashMap<>();
        size = new HashMap<>();

        for (V v : values) {
            Node node = new Node<>(v);
            nodes.put(v, node);
            parents.put(node, node);
            size.put(node, 1);
        }
    }

    /**
     *
     * @param node:如果node不在nodes表里面，那么会返回自己
     * @return
     */
    public Node findFather(Node node) {
        Stack<Node> stack = new Stack<>();
        while (node != parents.get(node)) {
            stack.add(node);
            node = parents.get(node);
        }
        while (!stack.isEmpty()) {//扁平化
            parents.put(stack.pop(), node);
        }
        return node;
    }

    public boolean isSameSet(V a, V b) throws Exception {
            return findFather(nodes.get(a)) == findFather(nodes.get(b));
    }

    /**
     * 小挂大，所以第一步是确认不是一个集合后找大小
     *
     * @param a
     * @param b
     */
    public void union(V a, V b) {
        Node head1 = findFather(nodes.get(a));
        Node head2 = findFather(nodes.get(b));
        if (head1 == head2) {
            return;
        }
        int size1 = size.get(head1);
        int size2 = size.get(head2);
        Node big = size1 >= size2 ? head1 : head2;
        Node small = big == head1 ? head2 : head1;
        parents.put(small, big);
        size.put(big, size1 + size2);
        size.remove(small);
    }

    public int sets() {
        return size.size();
    }

}
```

### 合并用户

![image-20220518130736662](./image\image-20220518130736662.png)

#### 代码

```java
public static int HowManyPeople(List<Person> arr) {
    UnionFind<Person> unionFind = new UnionFind<Person>(arr);
    HashMap<String,Person> mapA=new HashMap<>();
    HashMap<String,Person> mapB=new HashMap<>();
    HashMap<String,Person> mapC=new HashMap<>();
    for (Person p:arr){
        if (mapA.containsKey(p.a)){
            unionFind.union(p,mapA.get(p.a));
        }else {
            mapA.put(p.a,p);
        }
        if (mapB.containsKey(p.b)){
            unionFind.union(p,mapB.get(p.b));
        }else {
            mapB.put(p.b,p);
        }
        if (mapC.containsKey(p.c)){
            unionFind.union(p,mapC.get(p.c));
        }else {
            mapC.put(p.c,p);
        }
    }
    return unionFind.sets();
}
```

## 图

### 图的介绍和两种遍历方式

![image-20220518234200825](./image\image-20220518234200825.png)

![image-20220518234248371](./image\image-20220518234248371.png)

![image-20220518234317403](./image\image-20220518234317403.png)

#### 代码--BFS

```java
public static void bfs(Node node){
    if (node==null){
        return;
    }
    LinkedList<Node> queue=new LinkedList<>();//实现层序遍历的功能
    HashSet<Node> set=new HashSet<>();//保证结点不重复入队
    queue.add(node);
    set.add(node);//入队和入集合一定是绑定在一起发生
    while(!queue.isEmpty()){
        node=queue.poll();
        System.out.print(node.value+" ");
        for (Node p:node.nexts){//让node周围一圈没有入过队的结点入队
            if (!set.contains(p)){
                queue.add(p);
                set.add(p);
            }
        }
    }
}
```

#### 代码--DFS

```java
public static void dfs(Node start){
    if (start == null) {
        return;
    }
    Stack<Node> stack=new Stack<>();
    HashSet<Node> set=new HashSet<>();
    stack.push(start);
    set.add(start);
    System.out.print(start.value+" ");//入栈就打印

    while (!stack.isEmpty()) {
        Node cur=stack.pop();
        for (Node node:cur.nexts){
            if (!set.contains(node)){
                stack.push(cur);//cur压回去
                stack.push(node);
                set.add(node);
                System.out.print(node.value+" ");//入栈就打印
                break;//回到while循环从刚刚加进去的这个最深的结点node重新开始
            }
        }
    }
}
```

### 拓扑排序



![image-20220518234352021](./image\image-20220518234352021.png)

- 代码

```java
public static List<Node> sortedTopology(Gragh gragh){
    HashMap<Node,Integer> inMap=new HashMap<>();
    Queue<Node> zeroQueue=new LinkedList<>();
    for (Node node:gragh.nodes.values()){
        inMap.put(node,node.in);
        if (node.in==0){
            zeroQueue.add(node);
        }
    }
    List<Node> result=new ArrayList<>();
    while(!zeroQueue.isEmpty()){
        Node cur=zeroQueue.poll();
        result.add(cur);
        for (Node next:cur.nexts){
            inMap.put(next,inMap.get(next)-1);
            if (inMap.get(next)==0){
                zeroQueue.add(next);
            }
        }
    }
    return result;

}
```

### 最小生成树

#### kruskal

![image-20220518234515902](./image\image-20220518234515902.png)

- 代码

```java
public static class UnionFind{

    HashMap<Node,Node> parents=new HashMap<>();//向上找到父亲
    HashMap<Node,Integer> sizeMap=new HashMap<>();//只有是一个集合的代表结点才在这个表里

    public UnionFind() {
        parents=new HashMap<>();
        sizeMap=new HashMap<>();
    }

    public void makeSets(Collection<Node> collection){
        parents.clear();
        sizeMap.clear();//先清空老的并查集
        for (Node cur:collection){
            parents.put(cur,cur);
            sizeMap.put(cur,1);
        }
    }

    public Node findFather(Node node){
        Stack<Node> stack=new Stack<>();
        while(node!=parents.get(node)){//出while的时候node就是代表结点
            stack.push(node);
            node=parents.get(node);
        }
        while(!stack.isEmpty()){
            parents.put(stack.pop(),node);
        }
        return node;
    }

    public boolean isSameSet(Node node1,Node node2){
        return findFather(node1)==findFather(node2);
    }

    public void union(Node node1,Node node2){
        Node head1=findFather(node1);
        Node head2=findFather(node2);
        if (head1!=head2){
            int size1=sizeMap.get(head1);
            int size2=sizeMap.get(head2);
            Node big=size1>=size2?head1:head2;
            Node small=big==head1?head2:head1;
            parents.put(small,big);
            sizeMap.remove(small);
            sizeMap.put(big,size1+size2);
        }
    }
}

public static class EdgeComparator implements Comparator<Edge>{//从小到大的比较器
    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.weight-o2.weight;
    }
}

public static Set<Edge> Kruskal(Gragh gragh){
    UnionFind unionFind=new UnionFind();
    unionFind.makeSets(gragh.nodes.values());//传来一个容器，初始化并查集
    PriorityQueue<Edge> heap=new PriorityQueue<>();
    HashSet<Edge> res=new HashSet<>();
    for (Edge edge:gragh.edges){
        heap.add(edge);
    }
    while (!heap.isEmpty()) {
        Edge edge= heap.poll();
        if (!unionFind.isSameSet(edge.from,edge.to)){
            unionFind.union(edge.from, edge.to);
            res.add(edge);
        }
    }
    return res;
}
```

#### prim



![image-20220518234953448](./image\image-20220518234953448.png)

- 代码

```java
public static class EdgeComparator implements Comparator<Edge> {
    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.weight - o2.weight;
    }
}

public static Set<Edge> Prim(Gragh gragh) {
    HashSet<Edge> res = new HashSet<>();
    PriorityQueue<Edge> heap = new PriorityQueue<>(new EdgeComparator());//存解锁的边
    HashSet<Node> set = new HashSet<>();//存解锁的点
    for (Node node : gragh.nodes.values()) {//for循环是为了防止森林，如果不是森林那么随便选一个就行

        if (!set.contains(node)) {
            set.add(node);
            for (Edge edge : node.edges) {
                heap.add(edge);
            }
            while(!heap.isEmpty()){
                Edge edge= heap.poll();
                if (!set.contains(edge.to)){
                    set.add(edge.to);
                    res.add(edge);
                    for (Edge e:edge.to.edges){
                        heap.add(edge);
                    }
                }
            }
        }
    }
    return res;
}
```



### Dijkstra

![image-20220522163203373](./image\image-20220522163203373.png)

- 代码-1版本

```java
/**
 * 从distanceMap中选一个距离最小的结点，并且这个结点不在set里面。
 * @param distanceMap
 * @param set
 * @return
 */
public static Node find(HashMap<Node,Integer> distanceMap, HashSet<Node> set){
    int distance=Integer.MAX_VALUE;
    Node minNode=null;//如果distanceMap中的结点都已经被选过了，那么就返回null
    for (Node node:distanceMap.keySet()){
        if (!set.contains(node)&&node.value<distance){
            minNode=node;
            distance= node.value;
        }
    }
    return minNode;
}

public static HashMap<Node,Integer> Dijkstra(Node from){
    HashMap<Node,Integer> distanceMap=new HashMap<>();
    HashSet<Node> set=new HashSet<>();
    distanceMap.put(from,0);
    Node cur=from;
    while(cur!=null){//开始一个一个选最小距离的结点
        int distance=distanceMap.get(cur);
        for (Edge edge:cur.edges){
            if (!distanceMap.containsKey(edge.to)){//这个点本来到达不了
                distanceMap.put(edge.to,distance+edge.weight);
            }else {//如果可以到达，就更新原本map里面的值
                distanceMap.put(edge.to,Math.min(distanceMap.get(edge.to),distance+ edge.weight));
            }
        }
        set.add(cur);
        cur=find(distanceMap,set);
    }
    return distanceMap;
}
```

- 代码-2版本

小根堆里面存的是一条一条记录，记录里面有两个字段，一个是目的结点，一个是从源节点到目的结点的距离。小根堆需要更新并且调整结构，因为距离是会更新的。由于我们需要更新位置，所以我们的小根堆需要一个额外的结构来记住每一个记录放在了哪一个位置。还需要一个一个忽略方法，让我弹出过的记录不能再一次加进来，也就是这个结点我们不会再对它做操作了，所以我们还需要另一个结构set来记录我们加入过的结点。

```java
public static class Record{
    public int distance;
    public Node node;

    public Record(int distance, Node node) {
        this.distance = distance;
        this.node = node;
    }
}

public static class Heap{
    public Node[] nodes;
    public HashMap<Node,Integer> distanceMap;//用来实现Node之间的映射比较
    public HashMap<Node,Integer> indexMap;//用来实现更新调整
    public int size;

    public Heap(int size) {
        this.size = size;
        nodes=new Node[size];
        distanceMap=new HashMap<>();
        indexMap=new HashMap<>();
    }

    /**
     * @param index:从index这个位置开始，向上调整为小根堆结构
     */
    private void upHeapify(int index){
        int child=index;
        Node temp=nodes[child];
        for(;distanceMap.get(nodes[child-1>>1])>distanceMap.get(temp)&&child>0;child=child-1>>1){
            indexMap.put(nodes[child-1>>1],child);
            nodes[child]=nodes[child-1>>1];
        }
        indexMap.put(temp,child);
        nodes[child]=temp;
    }

    /**
     *
     * @param index:从index开始向下调整成最小堆
     * @param maxIndex:nodes数组的最大下标为maxIndex
     */
    private void downHeapify(int index, int maxIndex){
        Node temp=nodes[index];
        int parent=index;
        int child;
        for (;parent*2+1<=maxIndex;parent=child){
            child=parent*2+2<=maxIndex
                    &&distanceMap.get(nodes[parent*2+2])<distanceMap.get(nodes[parent*2+1])?parent*2+2:parent*2+1;
            if (distanceMap.get(nodes[child])<distanceMap.get(temp)){
                indexMap.put(nodes[child],parent);
                nodes[parent]=nodes[child];
            }else {
                break;//写在for循环的（）里面太长了。换成写在for循环里面需要break
            }
        }
        indexMap.put(temp,parent);
        nodes[parent]=temp;
    }

    private Record pop(){
        Record record=new Record(distanceMap.get(nodes[0]),nodes[0]);
        indexMap.put(nodes[0],-1);//改成曾经来过，现在不在的状态
        distanceMap.remove(nodes[0]);//出去了，并且以后也回不来，彻底的不要了
        swap(0,size-1);
        nodes[size-1]=null;//释放
        downHeapify(0,--size-1);
        return record;
    }

    private void addOrUpdateOrIgnore(Node node,int distance){
        if (isInHeap(node)&&distance<distanceMap.get(node)){
            distanceMap.put(node,distance);
        }else if (!isEntered(node)){
            distanceMap.put(node,distance);
            indexMap.put(node,size);
            nodes[size++]=node;
            upHeapify(size-1);
        }
    }


    private boolean isEmpty(){
        return size==0;
    }

    private boolean isEntered(Node node){
        return indexMap.containsKey(node);
    }

    private boolean isInHeap(Node node){
        return isEntered(node)&&indexMap.get(node)!=-1;
    }

    private void swap(int index1,int index2){
        indexMap.put(nodes[index1],index2);
        indexMap.put(nodes[index2],index1);
        Node temp=nodes[index1];
        nodes[index1]=nodes[index2];
        nodes[index2]=temp;
    }

}

public static HashMap<Node,Integer> Dijkstra2(Node from,int size){
    HashMap<Node,Integer> res=new HashMap<>();
    Heap heap=new Heap(size);
    heap.addOrUpdateOrIgnore(from,0);
    while(!heap.isEmpty()){
        Record record=heap.pop();
        int distance=record.distance;
        Node node=record.node;
        for (Edge edge:node.edges){
            heap.addOrUpdateOrIgnore(edge.to,distance+edge.weight);
        }
        res.put(node,distance);
    }
    return res;
}
```

## 暴力递归到动态规划

![image-20220522213623215](./image\image-20220522213623215.png)

### 汉诺塔问题



![image-20220522213520843](./image/image-20220522213520843.png)

#### 代码

```java
private static void Hanoi1(int n){
    LeftToRight(n);
}

private static void LeftToRight(int n){
    if (n==1){
        System.out.println("left to right");
        return;
    }
    LeftToMid(n-1);
    System.out.println("left to right");
    MidToRight(n-1);
}

private static void MidToRight(int n) {
    if (n==1){
        System.out.println("mid to right");
        return;
    }
    MidToLeft(n-1);
    System.out.println("mid to right");
    LeftToRight(n-1);
}

private static void MidToLeft(int n) {
    if (n==1){
        System.out.println("mid to left");
        return;
    }
    MidToRight(n-1);
    System.out.println("mid to left");
    RightToLeft(n-1);
}

private static void LeftToMid(int n) {
    if (n==1){
        System.out.println("left to mid");
        return;
    }
    LeftToRight(n-1);
    System.out.println("left to mid");
    RightToMid(n-1);
}

private static void RightToMid(int n) {
    if (n==1){
        System.out.println("right to mid");
        return;
    }
    RightToLeft(n-1);
    System.out.println("right to mid");
    LeftToMid(n-1);
}

private static void RightToLeft(int n) {
    if (n==1){
        System.out.println("right to left");
        return;
    }
    RightToMid(n-1);
    System.out.println("right to mid");
    MidToLeft(n-1);
}
//==========================================================================

private static void Hanoi2(int  n){
    process(n,"left","right","mid");
}

private static void  process(int n,String from,String to,String other){
    if (n==1){
        System.out.println(from+" to "+to);
        return;
    }
    process(n-1,from,other,to);
    System.out.println(from+" to "+to);
    process(n-1,other,to,from);
}
```



### 逆序一个栈

![image-20220522213709335](./image\image-20220522213709335.png)

#### 代码

```java
/**
 * 抓住栈底的元素，其它的元素往下沉。利用递归栈帮我们存信息。reverse函数控制不会传空栈
 *
 * @param stack
 * @return
 */
private static int f(Stack<Integer> stack) {
    int res = stack.pop();

    if (stack.isEmpty()) {
        return res;//栈的最后一个元素返回
    } else {
        int last = f(stack);//最终会last会抓住最后一个元素
        stack.push(res);
        return last;//把最后一层递归抓到的栈底元素一路往上扔到最开始的递归
    }
}

/**
 * 从宏观的来看，空栈不用翻。先从栈底抽一个，然后把剩下的翻转，然后再放回去。
 * @param stack
 */
private static void reverse(Stack<Integer> stack) {
    if (stack.isEmpty()) {
        return;
    }
    int p=f(stack);
    reverse(stack);
    stack.push(p);
}
```



### 打印一个字符串的全部子序列

- 思路：打印全部子序列其实就是对于每一个字符进行选择，递归到底，把叶子结点放入list中。过程中的选择利用path来记录

![image-20220522213730379](./image\image-20220522213730379.png)

- 代码

```java
private static List<String> subs(String str){
    char[] arr=str.toCharArray();
    String path="";
    LinkedList<String> list=new LinkedList<>();
    process(arr,0,list,path);
    return list;
}

/**
 * 在index位置分两种情况，一种是要了index位置，一种是不要index位置。
 * @param chars:这是一个固定参数
 * @param index:从index位置开始把后面的决定做完。0~index-1位置已经做好了决定
 * @param res:不需要返回值，我们把决定的结果放到res中
 * @param path:记录之前做决定的状态
 */
private static void process(char[] chars, int index, LinkedList<String> res, String path) {
    if (index==chars.length){//base case,已经把决定做好了，直接加入到res中，返回
        res.add(path);
        return;
    }
    String yes=path+ chars[index];
    process(chars,index+1,res,yes);
    String no=path;
    process(chars,index+1,res,no);
}
```





- 把上面的算法改成打印不重复的

我们把收集的容器变成set而不是list就行了。如果结果要List，我们就再把set遍历一遍。、

- 思考：如果不要你给出所有的不重复的子序列，我只要你给出不同的子序列的个数。怎么求？---动态规划

代码

```java
private static LinkedList<String> subsNoRepeat(String str){
    char[] arr=str.toCharArray();
    LinkedList<String> list=new LinkedList<>();
    String path="";
    HashSet<String> set=new HashSet<>();//去重
    process2(arr,0,set,path);
    for(String s :set){
        list.add(s);
    }
    return list;
}

private static void process2(char[] chars, int index, HashSet<String>res, String path) {
    if (index==chars.length){//base case,已经把决定做好了，直接加入到res中，返回
        res.add(path);
        return;
    }
    String yes=path+ chars[index];
    process2(chars,index+1,res,yes);
    String no=path;
    process2(chars,index+1,res,no);
}
```

### 打印一个字符串的全部排列

- 要注意还原现场

思想：想象成str.len大小的空位，从第一个位置开始一个一个填充。

代码

- 思路1：将string放入一个List中，然后递归的从中选择一个出来贴到path中，选择出来后需要删除。path一开始是空串。
- 思路2：将string转化中一个char[]，然后从第一个位置开始递归。在第i位置，从[i,len-1]位置选一个和i位置进行交换，这里是包括i自己的，如果是i自己就意味着没有人和自己交换。

```java
/**
 * @param str
 * @return
 */
private static LinkedList<String> permutation1(String str) {
    if (str == null || str.length() == 0) {
        return null;
    }
    char[] s = str.toCharArray();
    ArrayList<Character> rest = new ArrayList<>();
    for (char c : s) {
        rest.add(c);
    }
    String path = "";
    LinkedList<String> res = new LinkedList<>();
    process1(rest, path, res);
    return res;
}

/**
 * 不需要返回值，这里相当于返回值加到res里面了
 * @param rest:从rest中选一个放到path中。当rest空了就说明path就是其中一个答案
 * @param path:记录之前选过的路径
 * @param res:当rest为空的时候把path放入到res中
 */
private static void process1(ArrayList<Character> rest, String path, LinkedList<String> res) {
    if (rest.isEmpty()) {//base case
        res.add(path);
        return;
    }
    for (int i = 0; i < rest.size(); i++) {
        char c = rest.get(i);
        rest.remove(i);
        process1(rest, path + c, res);//这里我们不写成path=path+c然后里面是path。如果这样写我们也需要恢复现场
        rest.add(i, c);//上面破坏了rest，这里从递归中返回需要恢复现场
    }
}


private static LinkedList<String> permutation2(String str) {
    if (str == null || str.length() == 0) {
        return null;
    }
    char[] s = str.toCharArray();
    LinkedList<String> res = new LinkedList<>();
    process2(s, 0, res);
    return res;
}

/**
 *
 * @param s:直接在s上面做操作
 * @param index:index~len-1位置选一个和index做交换
 * @param res：index走到了最后一个坐标len的时候就是一个结果
 */
private static void process2(char[] s, int index, LinkedList<String> res) {
    if (index == s.length) {
        res.add(String.valueOf(s));
    }else {
        for (int i=index;i<s.length;i++){//从这些位置中选一个和index做交换
            swap(s,index,i);
            process2(s,index+1,res);
            swap(s,index,i);
        }
    }

}

private static void swap(char[] s, int a, int b) {
    char temp=s[a];
    s[a]=s[b];
    s[b]=temp;
}
```

- 改成打印一个字符串的**不重复**的全部排列

- 可以通过集合来实现

- 但是有一个更加优雅的实现，**分支限界**。在每一层的递归中用一个set记录，阻止一些分支的进行。

代码

```java
/**
 * 和上面的不一样的是这个版本给出的是不重复的排列
 * @param str
 * @return
 */
private static LinkedList<String> permutation3(String str){
    if (str == null || str.length() == 0) {
        return null;
    }
    char[] s = str.toCharArray();
    LinkedList<String> res = new LinkedList<>();
    process3(s, 0, res);
    return res;
}

private static void process3(char[] s, int index, LinkedList<String> res) {
    if (index == s.length) {
        res.add(String.valueOf(s));
    }else {
        boolean[] visited=new boolean[26];//26个字母，如果量大可以用集合来代替
        for (int i=index;i<s.length;i++){
            if (!visited[s[i]-'a']){
                visited[s[i]-'a']=true;
                swap(s,index,i);
                process3(s,index+1,res);
                swap(s,index,i);
            }
        }
    }
}
```

### 数字字符串转化成字母字符串

- 问多少种转化结果，其实就是递归到底部，收集合格的叶子结点的个数

```
ConvertToLetterString
```

![image-20220523195341417](./image\image-20220523195341417.png)

![image-20220524161857455](./image\image-20220524161857455.png)

- 代码

```java
private static int number(String str){
    if (str == null || str.length() == 0) {
        return 0;
    }
    char[] s=str.toCharArray();
    return process1(s,0);
}

/**
 *
 * @param s:固定参数，参与的数字串
 * @param index:s数组0~index-1范围已经决定好。现在要返回从index~len-1范围上组织有多少方式
 * @return
 */
private static int process1(char[] s, int index) {
    if (index == s.length) {//base case，从最底层的调用返回1给上层收集
        return 1;
    }
    if (s[index]==0){
        return 0;
    }
    int ways=process1(s,index+1);
    if (index+2<=s.length&&(s[index] - 'a') * 10 + s[index + 1] - 'a' <= 26) {
        ways+=process1(s,index+2);
    }
    return ways;
}

private static int dp1(String str) {
        char[] s = str.toCharArray();
        int N = s.length;
        int[] dp = new int[N + 1];
        dp[N] = 1;
        for (int index = N - 1; index >= 0; index--) {
            //默认就是0，所以第二个if语句默认已经初始化好了
            dp[index] = dp[index + 1] + (index + 2 <= N && (s[index] - 'a') * 10 + s[index + 1] 				- 'a' <= 26 ?dp[index + 2] : 0);
        }
        return dp[0];
    }
```

###  背包问题--从左到右尝试模型

- 此题和深度返回的改版。只不过是在递归的后面加上对应的价值。如果只是返回深度，那么就是在递归的后面加上1

**![image-20220523195418657](./image\image-20220523195418657.png)**

很显然背包问题是有很多计算的，所以我们改成动态规划是有意义的。

回想之前背包问题，index位置是从0~n-1，但是由于在暴力递归代码里我们用index到达了n来判断结束，所以index实际上可以到达n。所以我们就让index多来一行。

二维的数组。两层for循环，暴力递归怎么调，动态规划就怎么填。

动态规划转移方程其实就是暴力尝试中是如何组织决策的。

- 代码

```java
private static int maxValue(int[] weight, int[] value, int bag) {
    if (weight == null || value == null || value.length == 0 || weight.length == 0 || bag <= 0) {
        return 0;
    }
    return process1(weight, value, 0, bag);
}

/**
 * @param weight:固定参数，代表货物的重量，数组的长度代表货物的种类，数组的长度一定和value数组的长度一样
 * @param value:固定参数，代表货物的价值
 * @param index:代表index之前的货物已经做过选择了。
 * @param rest:还剩下多少空间可以装载货物
 * @return :返回的是rest背包种类，对从index下标开始货物做选择能得到的最大价值
 */
private static int process1(int[] weight, int[] value, int index, int rest) {
    if (index == weight.length) {//base case 已经没有货物可以选了
        return 0;
    }
    int p1 = process1(weight, value, index + 1, rest);//不选index位置的货物所能得到的最大值
    int p2 = rest - weight[index] >= 0 ?
            process1(weight, value, index + 1, rest - weight[index]) + value[index] : 0;
    return Math.max(p1, p2);
}

private static int dp1(int[] weight, int[] value,int bag){
    if (weight == null || value == null || value.length == 0 || weight.length == 0 || bag <= 0) {
        return 0;
    }
    int[][] dp=new int[weight.length+1][bag+1];
    //weight.len行默认就是0，已经初始化完毕
    for (int index=weight.length-1;index>=0;index--){//index
        for (int rest=0;rest<=bag;rest++){//bag
            dp[index][rest]=Math.max(dp[index+1][rest],
                    rest - weight[index] >= 0 ? dp[index + 1][ rest - weight[index]] + value[index] : 0);
        }
    }
    return dp[0][bag];
}
```

### 拿牌的获胜者--范围上的尝试模型

![image-20220523195538262](./image\image-20220523195538262.png)

![image-20220524161911026](./image\image-20220524161911026.png)

- 代码

```java
private static int scoreOfWinner1(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int first = f1(arr, 0, arr.length - 1);
    int second = s1(arr, 0, arr.length - 1);
    return Math.max(first, second);
}

private static int f1(int[] arr, int l, int r) {
    if (r == l) {
        return arr[l];
    }
    int case1 = s1(arr, l + 1, r) + arr[l];
    int case2 = s1(arr, l, r - 1) + arr[r];
    return Math.max(case1, case2);//一定给自己最有利的情况
}

private static int s1(int[] arr, int l, int r) {
    if (r == l) {
        return 0;
    }
    int case1 = f1(arr, l + 1, r);
    int case2 = f1(arr, l, r - 1);
    return Math.min(case1, case2);//对手是坏蛋，一定给你最差的情况
}

/**
 * 使用傻缓存方法
 *
 * @param arr
 * @return
 */
private static int scoreOfWinner2(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }

    int N = arr.length;
    int dpf[][] = new int[N][N];
    int dps[][] = new int[N][N];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            dpf[i][j] = -1;
            dps[i][j] = -1;
        }
    }

    int first = f2(arr, 0, arr.length - 1, dpf, dps);
    int second = s2(arr, 0, arr.length - 1, dpf, dps);
    return Math.max(first, second);
}

private static int f2(int[] arr, int l, int r, int[][] dpf, int[][] dps) {
    if (r == l) {
        return arr[l];
    }
    if (dpf[l][r] != -1) {
        return dpf[l][r];
    }
    int case1 = s2(arr, l + 1, r, dpf, dps) + arr[l];
    int case2 = s2(arr, l, r - 1, dpf, dps) + arr[r];

    dpf[l][r] = Math.max(case1, case2);//一定给自己最有利的情况
    return dpf[l][r];
}

private static int s2(int[] arr, int l, int r, int[][] dpf, int[][] dps) {
    if (r == l) {
        return 0;
    }
    if (dps[l][r] != -1) {
        return dps[l][r];
    }
    int case1 = f2(arr, l + 1, r, dpf, dps);
    int case2 = f2(arr, l, r - 1, dpf, dps);

    dps[l][r] = Math.min(case1, case2);//对手是坏蛋，一定给你最差的情况
    return dps[l][r];
}

/**
 * 动态规划版本
 *
 * @param arr
 * @return
 */
private static int scoreOfWinner3(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int N = arr.length;
    int dpf[][] = new int[N][N];
    int dps[][] = new int[N][N];
    for (int i = 0; i < N; i++) {
        dpf[i][i] = arr[i];
    }
    for (int l = N - 2; l >= 0; l--) {//从下往上
        for (int r = l+1; r < N; r++) {//从左往右
            dpf[l][r] = Math.max(dps[l + 1][r] + arr[l], dps[l][r - 1] + arr[r]);
            dps[l][r] = Math.min(dpf[l + 1][r], dpf[l][r - 1]);
        }
    }
    return Math.max(dps[0][N - 1], dpf[0][N - 1]);

}
```



### 人过河问题

![image-20220523195604498](./image\image-20220523195604498.png)



### 海盗分硬币问题

![image-20220523195628625](./image\image-20220523195628625.png)



### 村内送信问题

![image-20220523195655511](./image\image-20220523195655511.png)





### N皇后问题

- 题目：N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列,也不在同一条斜线上给定一个整数n,返回n皇后的摆法有多少种。

  n=1，返回1

  n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0

  n=8，返回92

- 方法：

  规定每一行只能放一个皇后，也只能这样

  每一行皇后的位置，横纵坐标记在一个结构里。每一行有一个结构。每次要新增加一个皇后都要和之前所有的皇后都不共行也不共列。如果发现某一层没有皇后可以摆了，那么就退到上一层去，让上一层的皇后换地方。

  这里的结构使用一个数组即可，数组的下标代表行数，数组的值代表列数。

  Process1的返回值的含义代表前面皇后是那样摆的情况下能摆出多少种。

- 如何验证皇后不打架。在我们的设定中，皇后一定不同行，所以我们不需要验证皇后共行问题。我们验证共列问题。共斜线问题：(a,b)和(c,d)只要满足|a-c|==|b-d|即可。



- 算法常数项的改进。 位运算。

![image-20220523213031388](./image\image-20220523213031388.png)

- 代码

```java
package class07_RecursionToDP;

public class Code08_NQueens {

    private static int num1(int n) {//n皇后
        if (n < 1) {
            return 0;
        }
        int[] record = new int[n];
        return process1(n, 0, record);
    }

    /**
     * @param n:总共有n个皇后要排
     * @param index:目前已经把0~index-1的皇后排好了，现在要看看在之前决策的基础上，从index~n-1有多少种排法 index对应于行
     * @param record:index之前的皇后的布局放置在record中，用来判断index位置的皇后能放在哪里。record[i]=j代表的是第i行的皇后放在了j列位置
     * @return :返回从index~n-1有多少种排法---在之前的基础上
     */
    private static int process1(int n, int index, int[] record) {
        if (index == n) {//顶层递归收集底层递归的这些1
            return 1;
        }
        int sum = 0;
        for (int i = 0; i < n; i++) {//index行的每一列都下去试试看。
            if (isOk(record, index, i)) {
                record[index] = i;
                sum += process1(n, index + 1, record);
            }
        }
        return sum;
    }

    /**
     * @param record:0~index-1的皇后在棋盘上的位置
     * @param index:index行想放入一个皇后。我们的结构天生决定了两个皇后不可能共行
     * @param colum:判断把皇后放在index行的colum位置可不可行。
     * @return
     */
    private static boolean isOk(int[] record, int index, int colum) {
        for (int i = 0; i < index; i++) {
            if (record[i] == colum || index - i == Math.abs(colum - record[i])) {//判断是否共列和共斜线
                return false;
            }
        }
        return true;
    }

    private static int num2(int n) {
        if (n < 1) {
            return 0;
        }
        int limit = (1 << n) - 1;//得到右边n位全是1，其它都是0
        return process2(limit, 0, 0, 0);
    }

    /**
     *
     * @param limit:对于n皇后问题所对应的特定限制
     * @param col:列限制
     * @param left:左斜线限制
     * @param right:右斜线限制
     * @return:
     */
    private static int process2(int limit, int col, int left, int right) {
        if (col==limit){//当col==limit也就意味着每一列都放好了皇后
            return 1;
        }
        int sum=0;//累加种数
        int pos=~(col|left|right)&limit;//limit作用是让未越界的位保持不变，越界的位清零，因为我们我们要从右到左一个一个取1
        int mostRightOne=0;
        while(pos!=0){//还有1给我们取。循环的含义是在当前行把每一列都试一遍。
            mostRightOne=(~pos+1)&pos;//pos最右边的1被我们拿到。补数与上自己可以拿到最右边的1
            pos-=mostRightOne;//最右边的1被我们取了，减去。
            sum+=process2(limit,col|mostRightOne,(left|mostRightOne)<<1,(right|mostRightOne)>>1);
        }
        return sum;//所有位置都取不了了就返回0，说明这种情况不行。
    }

    public static void main(String[] args) {
        System.out.println(num1(8));
        System.out.println(num2(8));
    }


}

```



### 套路

![image-20220524161923223](./image\image-20220524161923223.png)



### 动态规划

- 怎么尝试—件事?
  1)有经验但是没有方法论?
  2)怎么判断一个尝试就是最优尝试?
  3)难道尝试这件事真的只能拼天赋?那我咋搞定我的面试?

  4)动态规划是啥?好高端的样子哦…和尝试有什么关系?
  后面给你带来最强的私货! ->暴力递归到动态规划的套路!解决任何面试中的动态规划问题!

- 什么暴力递归可以继续优化?
  有重复调用同一个子问题的解,这种递归可以优化
  如果每一个子问题都是不同的解，无法优化也不用优化

- 常见的4种尝试模型
  1)从左往右的尝试模型
  2)范围上的尝试模型
  3)多样本位置全对应的尝试模型
  4)寻找业务限制的尝试模型

### 机器人走路问题

- 思想：有选择的返回叶子结点。有0和1

- 题目：假设有排成一行的N个位置，记为1~N，N一定大于或等于2

  开始时机器人在其中的M位置上(M一定是1~N中的一个)

  如果机器人来到1位置，那么下一步只能往右来到2位置;

  如果机器人来到N位置，那么下一步只能往左来到N-1位置;

  如果机器人来到其它位置，那么下一步可以往左走或者往右走;

  规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个)的方法有多少种给定四个参数N、M、K、P，返回方法数。



- 我们有一种暴力递归的写法。但是这种写法会有上面所说的重复计算问题，这里可以优化，我们可以把之前计算得到过的放到一个缓存里面。暴力递归函数有两个可变参数，那么我们就准备一个二维数组，存入可变参数对的答案。这个优化就是动态规划。这是动态规划里面最粗糙的一种解法，叫做记忆化搜索。这是一种傻缓存的形式
- 动态规划实际上就是把参数的组合弄成结构化的缓存。缓存里面的依赖关系就来自于某一个暴力递归。能改成动态规划的暴力递归一定是有很多重复计算的。一旦已经写出了暴力递归就已经不用管原始题意了，根据递归就可以直接改成动态规划。

- 代码

```java
private static int ways(int n, int start, int end, int k){
    if (n<=1||start>n-1||start<0||end>n-1||end<0||k<0){
        return 0;
    }
    return process1(n,start,end,k);
}

private static int process1(int n, int cur, int end, int rest) {
    if (rest==0){//base case，上层收集这些1
        return cur==end?1:0;
    }
    int goLeft=cur>0?process1(n, cur-1, end, rest-1):0;
    int goRight=cur<n-1?process1(n, cur+1, end, rest-1):0;
    return goLeft+goRight;
}

private static int ways2(int n, int start, int end, int k){
    if (n<=1||start>n-1||start<0||end>n-1||end<0||k<0){
        return 0;
    }
    int [][]dp=new int[n][k+1];//0~n-1  0~k
    for (int i=0;i<dp.length;i++){
        for (int j=0;j<dp[0].length;j++){
            dp[i][j]=-1;
        }
    }
    return process2(n,start,end,k,dp);


}

private static int process2(int n, int cur, int end, int rest, int[][] dp) {
    if (rest==0){//base case，上层收集这些1
        return cur==end?1:0;
    }
    if (dp[cur][rest] != -1) {
        return dp[cur][rest];
    }
    int goLeft=cur>0?process1(n, cur-1, end, rest-1):0;
    int goRight=cur<n-1?process1(n, cur+1, end, rest-1):0;
    dp[cur][rest]=goLeft+goRight;
    return goLeft+goRight;
}

private static int ways3(int n, int start, int end, int k){
    if (n<=1||start>n-1||start<0||end>n-1||end<0||k<0){
        return 0;
    }
    int dp[][]=new int[n][k+1];//[cur][rest]
    dp[end][0]=1;//rest=0已经初始化
    for (int rest=1;rest<=k;rest++){
        for (int cur=0;cur<n;cur++){
            int goLeft=cur>0?dp[cur-1][rest-1]:0;
            int goRight=cur<n-1?dp[cur+1][rest-1]:0;
            dp[cur][rest]= goLeft+goRight;
        }
    }
    return dp[start][k];
}
```

### 凑金额

![image-20220524161935933](./image\image-20220524161935933.png)

- 单参数的方法可以实现返回最小或者最大的硬币数量（通过计算树展开的深度）。但是没办法返回方法的总数，因为例如{2,3}凑10,2323和2233其实是同一种方法。

#### 返回最少要多少个硬币--代码

- 和递归的深度有关。一种方法是每一层利用每一种硬币下去递归，这种方法硬币的个数直接就是深度。第二种方法是每一层利用硬币的使用个数下去递归，这样的话就是深度的改进，也就是每次+1变成每次加上对应的个数。
- 这里比背包问题多了一个向上返回深度的条件。也就是这里的rest一定要为0才能向上返回，由于多了这个条件，所以需要通过一个特殊的返回值作为判断，主动取消返回特殊值分支的收集。所以这里的min设置为了MAX，如果此题不需要rest为0的话min设置为0即可。
- 从合格的叶子结点中选择最小的。return 0代表是合格的叶子结点，可以参与竞争。return MAX说明是不合格的叶子结点。不参与竞争

```java
/**
     * 每一层按照特点一种硬币（index）使用了几个来进行展开
     *
     * @param amount:硬币的面额
     * @param aim:目标
     * @return :返回的是最少的硬币数
     */
    private static int minCoins(int[] amount, int aim) {
        if (amount == null || amount.length == 0 || aim < 0) {
            return 0;
        }
        return process1(amount, 0, aim);
    }

    /**为什么要保证next!=MAX,因为在Java程序中MAX+i会变成负数，这是底层决定的。
     * @param amount:固定参数面额
     * @param index:index之前的硬币已经决定使用多少
     * @param rest:需要用index及其往后的硬币凑成rest
     * @return :返回凑成rest需要的最少硬币
     */
    private static int process1(int[] amount, int index, int rest) {
        if (index == amount.length) {//需要用返回值来区分一个调用是否合法
            return rest == 0 ? 0 : Integer.MAX_VALUE;
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; amount[index] * i <= rest; i++) {//i代表amount[index]硬币选了几个
            int next = process1(amount, index + 1, rest - amount[index] * i);
            min=next != Integer.MAX_VALUE ?Math.min(min,i+next):min;
        }
        return min;
    }

    /**为什么要保证next!=MAX,因为在Java程序中MAX+i会变成负数，这是底层决定的。
     * 没有优化过的动态规划，里面有for循环
     * @param amount
     * @param aim
     * @return
     */
    private static int minCoinsDp1(int[] amount, int aim) {
        if (amount == null || amount.length == 0 || aim < 0) {
            return 0;
        }
        int N = amount.length;
        int[][] dp = new int[N + 1][aim + 1];//[index][rest]
        for (int rest = 1; rest <= aim; rest++) {//初始化第N行
            dp[N][rest] = Integer.MAX_VALUE;
        }
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                int min = Integer.MAX_VALUE;
                for (int i = 0; amount[index] * i <= rest; i++) {//i代表amount[index]硬币选了几个
                    int next = dp[index + 1][rest - amount[index] * i];
                    min=next != Integer.MAX_VALUE ?Math.min(min,i+next):min;
                }
                dp[index][rest] = min;
            }
        }
        return dp[0][aim];
    }

    /**dp[index][rest - amount[index]] != Integer.MAX_VALUE需要保证，因为MAX+1是没有意义的
     * 优化过的动态规划，去掉了for循环
     * @param amount
     * @param aim
     * @return
     */
    private static int minCoinsDp2(int[] amount, int aim) {
        if (amount == null || amount.length == 0 || aim < 0) {
            return 0;
        }
        int N = amount.length;
        int[][] dp = new int[N + 1][aim + 1];//[index][rest]
        for (int rest = 1; rest <= aim; rest++) {//初始化第N行
            dp[N][rest] = Integer.MAX_VALUE;
        }
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                dp[index][rest] = dp[index + 1][rest];//一张都不选
                if (rest - amount[index] >= 0 && dp[index][rest - amount[index]] != Integer.MAX_VALUE) {//至少有一张的话利用空间感可以优化
                    dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - amount[index]] + 1);
                }
            }
        }
        return dp[0][aim];
    }

    /**
     * 用另一种递归过程来实现。每一层按照是否能够使用每一种硬币来展开，每层都只能使用一个.这种递归方式会导致调用得很深
     * 会有非常非常多的重复计算，数据量大的话很可能跑不完。所以一定要改成动态规划。
     *
     * @param amount:面额数组
     * @param aim:要凑成的金额
     * @return
     */
    private static int minCoins2(int[] amount, int aim) {
        if (amount == null || amount.length == 0 || aim < 0) {
            return 0;
        }
        return process3(amount, aim);
    }

    /**
     * 注意：此题是利用递归的深度来解题。并不是收集最底层的1来进行解题。所以rest==0的时候return 0.如果return 1的话边数会多一个
     * @param amount:面值
     * @param rest:还剩下多少钱要凑
     * @return
     */
    private static int process3(int[] amount, int rest) {
        if (rest == 0) {
            return 0;
        }
        if (!restIsOk(amount, rest)) {//这段代码可以省略，因为这里的min进去之后如果还是MAX也就代表着现在没有合适的硬币了
            return Integer.MAX_VALUE;
        }
        int min = Integer.MAX_VALUE;
        for (int coin : amount) {
            if (rest - coin >= 0) {//每一层选择性展开
                int next = process3(amount, rest - coin);
                min = next!= Integer.MAX_VALUE?Math.min(min,next+1):min;
            }
        }
        return min;
    }

    private static boolean restIsOk(int[] amount, int rest) {//至少有一个硬币可以用
        for (int coin : amount)
            if (rest >= coin) return true;
        return false;
    }

    private static int minCoins2Dp(int[] amount, int aim) {
        if (amount == null || amount.length == 0 || aim < 0) {
            return 0;
        }
        int []dp=new int[aim+1];//dp[rest]=0,
        for (int rest=1;rest<aim+1;rest++){
            if (!restIsOk(amount, rest)) {
                dp[rest]= Integer.MAX_VALUE;
            }
            int min = Integer.MAX_VALUE;
            for (int coin : amount) {
                if (rest - coin >= 0) {//每一层选择性展开
                    int next = dp[rest-coin];
                    min = next!= Integer.MAX_VALUE?Math.min(min,next+1):min;
                }
            }
            dp[rest]=min;
        }

        return dp[aim];
    }
```

- minCoins  minCoinsDp1    minCoinsDp2时间比较

  ![image-20220527165559733](./image\image-20220527165559733.png)

  可以看到暴力递归的会比下面两个动态规划慢很多

- minCoinsDp1    minCoinsDp2时间比较

  ![image-20220527165800486](./image\image-20220527165800486.png)

  可以看到优化后的动态规划又比没有优化的动态规划快了很多

- 上面的这段代码是按照硬币的种类来展开递归的，递归的深度就是硬币的种类数



```java
/**
     * 每一层按照特点一种硬币（index）使用了几个来进行展开
     *
     * @param amount:硬币的面额
     * @param aim:目标
     * @return :返回的是最少的硬币数
     */
    private static int minCoins(int[] amount, int aim) {
        if (amount == null || amount.length == 0 || aim < 0) {
            return 0;
        }
        return process1(amount, 0, aim);
    }

    /**为什么要保证next!=MAX,因为在Java程序中MAX+i会变成负数，这是底层决定的。
     * @param amount:固定参数面额
     * @param index:index之前的硬币已经决定使用多少
     * @param rest:需要用index及其往后的硬币凑成rest
     * @return :返回凑成rest需要的最少硬币
     */
    private static int process1(int[] amount, int index, int rest) {
        if (index == amount.length) {//需要用返回值来区分一个调用是否合法
            return rest == 0 ? 0 : Integer.MAX_VALUE;
        }
        int min = Integer.MAX_VALUE;
        for (int i = 0; amount[index] * i <= rest; i++) {//i代表amount[index]硬币选了几个
            int next = process1(amount, index + 1, rest - amount[index] * i);
            min = Math.min(next != Integer.MAX_VALUE ? i + next : Integer.MAX_VALUE, min);
        }
        return min;
    }

    /**为什么要保证next!=MAX,因为在Java程序中MAX+i会变成负数，这是底层决定的。
     * 没有优化过的动态规划，里面有for循环
     * @param amount
     * @param aim
     * @return
     */
    private static int minCoinsDp1(int[] amount, int aim) {
        if (amount == null || amount.length == 0 || aim < 0) {
            return 0;
        }
        int N = amount.length;
        int[][] dp = new int[N + 1][aim + 1];//[index][rest]
        for (int rest = 1; rest <= aim; rest++) {//初始化第N行
            dp[N][rest] = Integer.MAX_VALUE;
        }
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                int min = Integer.MAX_VALUE;
                for (int i = 0; amount[index] * i <= rest; i++) {//i代表amount[index]硬币选了几个
                    int next = dp[index + 1][rest - amount[index] * i];
//                    min = Math.min(next != Integer.MAX_VALUE ? i + next : Integer.MAX_VALUE, min);
                    min=next != Integer.MAX_VALUE ?Math.min(min,i+next):min;
                }
                dp[index][rest] = min;
            }
        }
        return dp[0][aim];
    }

    /**dp[index][rest - amount[index]] != Integer.MAX_VALUE需要保证，因为MAX+1是没有意义的
     * 优化过的动态规划，去掉了for循环
     * @param amount
     * @param aim
     * @return
     */
    private static int minCoinsDp2(int[] amount, int aim) {
        if (amount == null || amount.length == 0 || aim < 0) {
            return 0;
        }
        int N = amount.length;
        int[][] dp = new int[N + 1][aim + 1];//[index][rest]
        for (int rest = 1; rest <= aim; rest++) {//初始化第N行
            dp[N][rest] = Integer.MAX_VALUE;
        }
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                dp[index][rest] = dp[index + 1][rest];//一张都不选
                if (rest - amount[index] >= 0 && dp[index][rest - amount[index]] != Integer.MAX_VALUE) {//至少有一张的话利用空间感可以优化
                    dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - amount[index]] + 1);
                }
            }
        }
        return dp[0][aim];
    }

    /**
     * 用另一种递归过程来实现。每一层按照是否能够使用每一种硬币来展开，每层都只能使用一个.这种递归方式会导致调用得很深
     * 会有非常非常多的重复计算，数据量大的话很可能跑不完。所以一定要改成动态规划。
     *
     * @param amount:面额数组
     * @param aim:要凑成的金额
     * @return
     */
    private static int minCoins2(int[] amount, int aim) {
        if (amount == null || amount.length == 0 || aim < 0) {
            return 0;
        }
        return process3(amount, aim);
    }

    /**
     * 注意：此题是利用递归的深度来解题。并不是收集最底层的1来进行解题。所以rest==0的时候return 0.如果return 1的话边数会多一个
     * @param amount:面值
     * @param rest:还剩下多少钱要凑
     * @return
     */
    private static int process3(int[] amount, int rest) {
        if (rest == 0) {
            return 0;
        }
        if (!restIsOk(amount, rest)) {
            return Integer.MAX_VALUE;
        }
        int min = Integer.MAX_VALUE;
        for (int coin : amount) {
            if (rest - coin >= 0) {//每一层选择性展开
                int next = process3(amount, rest - coin);
                min = next!= Integer.MAX_VALUE?Math.min(min,next+1):min;
            }
        }
        return min;
    }

    private static boolean restIsOk(int[] amount, int rest) {//至少有一个硬币可以用
        for (int coin : amount)
            if (rest >= coin) return true;
        return false;
    }

    private static int minCoins2Dp(int[] amount, int aim) {
        if (amount == null || amount.length == 0 || aim < 0) {
            return 0;
        }
        int []dp=new int[aim+1];//dp[rest]=0,
        for (int rest=1;rest<aim+1;rest++){
            if (!restIsOk(amount, rest)) {
                dp[rest]= Integer.MAX_VALUE;
            }
            int min = Integer.MAX_VALUE;
            for (int coin : amount) {
                if (rest - coin >= 0) {//每一层选择性展开
                    int next = dp[rest-coin];
                    min = next!= Integer.MAX_VALUE?Math.min(min,next+1):min;
                }
            }
            dp[rest]=min;
        }

        return dp[aim];
    }
```

- 这段代码是每一层都使用一个硬币来展开。递归的深度可能会非常的恐怖！所以一定一定要改成动态规划。这种暴力递归的方法速度会被上一种暴力的递归的速度慢很多！！！

- minCoins2Dp  minCoinsDp2速度进行比较

  ![image-20220527170322350](./image\image-20220527170322350.png)

  可以看到下面这一种尝试方式虽然说暴力递归的情况速度很垃圾，但是它的动态规划版本完爆上面已经改进过的动态规划版本。因为下面这种版本的变量只有rest一个

#### 有多少种方法可以凑成-代码

- 此题就是收集叶子结点问题，收集合格的叶子结点。合格为1，不合格为0.

```java
/**
 *
 * @param amount:面额数组，每种硬币可以使用无数个
 * @param aim:要凑成的目标
 * @return :凑成aim一共有多少种方法
 */
private static int ways(int[] amount, int aim) {
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    return process2(amount, 0, aim);
}

/**
 * @param amount:
 * @param index:
 * @param rest:
 * @return :返回的是有多少种方法凑成rest
 */
private static int process2(int[] amount, int index, int rest) {
    if (index == amount.length) {
        return rest == 0 ? 1 : 0;
    }
    int sum = 0;
    for (int i = 0; amount[index] * i <= rest; i++) {//i代表amount[index]硬币选了几个
        int next = process2(amount, index + 1, rest - amount[index] * i);
        sum += next;
    }
    return sum;
}

private static int waysDp1(int[] amount, int aim) {
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    int N = amount.length;
    int dp[][] = new int[N + 1][aim + 1];
    dp[N][0] = 1;//第N行初始化完毕
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            int sum = 0;
            for (int i = 0; amount[index] * i <= rest; i++) {//i代表amount[index]硬币选了几个
                int next = dp[index + 1][rest - amount[index] * i];
                sum += next;
            }
            dp[index][rest] = sum;
        }
    }
    return dp[0][aim];
}

/**
 * 去for循环的方法：如果至少可以用一个硬币就可以使用规律。如果一个都不用就保留dp[index+1][rest]
 * @param amount:
 * @param aim:
 * @return
 */
private static int waysDp2(int[] amount, int aim) {
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    int N = amount.length;
    int dp[][] = new int[N + 1][aim + 1];
    dp[N][0] = 1;//第N行初始化完毕
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            dp[index][rest]=dp[index+1][rest];
            if (rest-amount[index]>=0){
                dp[index][rest]+=dp[index][rest-amount[index]];
            }
        }
    }
    return dp[0][aim];
}
```



### 贴纸问题

![image-20220524161944339](./image\image-20220524161944339.png)

我们这里要规定每一次都先搞定原始字符串的第一个字符，防止贴纸没有符合的会导致递归跑不完。最终的结果和你先搞定哪个字符是无关的。所以我可以规定每一次都先搞定第一个字符。我也可以使用一个函数来判断贴纸至少可以解决一个字符我才进去。

这个暴力递归明显有重复过程。但是这里我们只能用记忆化搜索的方式就够了，因为String参数的变化范围是无穷的，我们没有办法进行精细化。本质上动态规划就是把傻缓存细粒度结构化的样子。

- 第一种尝试的方法也是一颗多叉树展开的方法，但是是按照使用了哪一种贴纸进行的多叉树展开。我们还有第二种尝试的方法，我们按照使用了多少张某一种贴纸来展开![image-20220524165258708](./image\image-20220524165258708.png)

- 第二种尝试的方法需要有另一个参数index记录贴纸，多了一个参数，不如第一种尝试。把可变参数的数量减下来，依次增加缓存的命中率。



- 代码

```java
private static int minStickers1(String[] sticker, String aim) {
        if (sticker == null || sticker.length == 0 || aim == null) {
            return 0;
        }
        return process1(sticker, aim);
    }

    private static int process1(String[] sticker, String rest) {
        if (rest.length() == 0) {
            return 0;
        }
        int min = Integer.MAX_VALUE;
        for (String str : sticker) {
            String s = minus(rest, str);
            if (s.length() != rest.length()) {//贴纸有用才递归
                int next = process1(sticker, s);
                min = next == Integer.MAX_VALUE ? min : Math.min(min, next + 1);//和上面这段可以互换
            }
        }
        return min;
    }

    /**
     * 观察到这里的减法是先转化成数组才进行的。所以自然可以想到，如果我们一开始就把贴纸和目标转化成数组的话就可以省下转化的时间。
     *
     * @param a
     * @param b
     * @return
     */
    private static String minus(String a, String b) {//a-b
        String res = "";
        char[] charsA = a.toCharArray();
        char[] charsB = b.toCharArray();
        int[] alphabet = new int[26];
        for (char c : charsA) {
            alphabet[c - 'a']++;
        }
        for (char c : charsB) {
            alphabet[c - 'a']--;
        }
        for (int i = 0; i < alphabet.length; i++) {
            if (alphabet[i] > 0) {
                while (alphabet[i]-- != 0) {
                    res += (char) (i + 'a');
                }
            }
        }
        return res;
    }

    /**
     * 这里不把aim也转化成char[]是因为，如果转化了就不能通过每次消除第一个字符来做贪心算法了
     * @param stickers
     * @param aim
     * @return
     */
    private static int minStickers2(String[] stickers, String aim) {
        if (stickers == null || stickers.length == 0 || aim == null) {
            return 0;
        }
        int[][] charsSticker = new int[stickers.length][26];
        for (int i = 0; i < stickers.length; i++) {//对每一个字符串
            for (char c : stickers[i].toCharArray()) {//转化成字符类型的数组，然后对此数组进行遍历
                charsSticker[i][c - 'a']++;//第i的字符串对应的特定字符的位置+1
            }
        }
        return process2(charsSticker, aim);
    }

    private static int process2(int[][] stickers, String aim) {
        if (aim.length() == 0) {
            return 0;
        }
        char[] charsAim = aim.toCharArray();
        int min = Integer.MAX_VALUE;
        for (int[] charsSticker : stickers) {//每张贴纸都试
            if (charsSticker[charsAim[0] - 'a'] > 0) {//目标的第一个字符先变为0.这是一步贪心。只有能消去目标的第一个字符的贴纸我才选
                int next = process2(stickers, minus2(charsSticker, aim));//改变目标，继续删除它的第一个字符
                min = next == Integer.MAX_VALUE ? min : Math.min(min, next + 1);
            }
        }
        return min;
    }

    private static String minus2(int[] sticker, String rest) {
        char[] charsRest = rest.toCharArray();
        int[] restCount = new int[26];
        for (char c : charsRest) {
            restCount[c - 'a']++;
        }
        for (int i = 0; i < sticker.length; i++) {
            if (sticker[i] > 0) {
                restCount[i] -= sticker[i];
            }
        }
        String res = "";
        for (int i = 0; i < restCount.length; i++) {//对于每一个字母
            for (int j = 0; j < restCount[i]; j++) {//把字母加restCount[i]次到res上
                res += (char) (i + 'a');
            }
        }
        return res;
    }

    private static int minStickers3(String[] stickers, String aim) {
        if (stickers == null || stickers.length == 0 || aim == null) {
            return 0;
        }
        int[][] charsSticker = new int[stickers.length][26];
        for (int i = 0; i < stickers.length; i++) {//对每一个字符串
            for (char c : stickers[i].toCharArray()) {//转化成字符类型的数组，然后对此数组进行遍历
                charsSticker[i][c - 'a']++;//第i的字符串对应的特定字符的位置+1
            }
        }
        HashMap<String, Integer> dp = new HashMap<>();
        dp.put("",0);
        return process3(charsSticker, aim, dp);
    }

    private static int process3(int[][] stickers, String aim, HashMap<String, Integer> dp) {
        if (dp.containsKey(aim)){
            return dp.get(aim);
        }
        char[] charsAim = aim.toCharArray();
        int min = Integer.MAX_VALUE;
        for (int[] charsSticker : stickers) {//每张贴纸都试
            if (charsSticker[charsAim[0] - 'a'] > 0) {//目标的第一个字符先变为0.这是一步贪心。只有能消去目标的第一个字符的贴纸我才选
                int next = process2(stickers, minus2(charsSticker, aim));//改变目标，继续删除它的第一个字符
                min = next == Integer.MAX_VALUE ? min : Math.min(min, next + 1);
            }
        }
        dp.put(aim,min);
        return min;
    }
```

### 总结

![image-20220528134326851](./image\image-20220528134326851.png)

### 两字符串最长公共子序列

![image-20220912142651471](image/image-20220912142651471.png)

- 真正在写代码的时候左上角的格子可以不管，因为左上角的格子一定比上面的格子和左边的格子弱。

代码

```JAVA
private static int longestCommonSubsequence(String a, String b) {
        if (a == null || b == null || a.length() == 0 || b.length() == 0) {
            return 0;
        }
        char[] string1 = a.toCharArray();
        char[] string2 = b.toCharArray();
        return process1(string1, a.length() - 1, string2, b.length() - 1);
    }

    /**
     * @param a:固定参数
     * @param index1:0~index1 的字符串
     * @param b:固定参数
     * @param index2:0~index2 的字符串
     * @return :返回a的0~index1的字符串和b的0~index2的字符串的最大公共子序列长度
     */
    private static int process1(char[] a, int index1, char[] b, int index2) {
        if (index1 == 0 && index2 == 0) {//二维递归的base case
            return a[index1] == b[index2] ? 1 : 0;
        } else if (index1 == 0) {//base case
            return a[index1] == b[index2] ? 1 : process1(a, index1, b, index2 - 1);
        } else if (index2 == 0) {//base case
            return a[index1] == b[index2] ? 1 : process1(a, index1 - 1, b, index2);
        } else {//至少都有两个字符
            //p1这里一定有一个前提条件就是a[index1]==b[index2]
            int p1 = a[index1] == b[index2] ? process1(a, index1 - 1, b, index2 - 1) + 1 : 0;//最长公共子序列的最后一个字符都在a和b的最后
            int p2 = process1(a, index1, b, index2 - 1);//最长公共子序列的最后一个字符在a不在b
            int p3 = process1(a, index1 - 1, b, index2);//最长公共子序列的最后一个字符在b不在a
            //p4这种情况可以不存在，因为p4一定小于p1,p2,p3.p2/p3的子串范围都大于p4，或者说p4已经包含在p2或者p3的决策中了。
//            int p4=process1(a,index1-1,b,index2-1);
            return Math.max(Math.max(p2, p3), p1);
        }
    }

    private static int longestCommonSubsequence2(String str1, String str2) {
        if (str1 == null || str2 == null || str1.length() == 0 || str2.length() == 0) {
            return 0;
        }
        char[] a = str1.toCharArray();
        char[] b = str2.toCharArray();
        int[][] dp = new int[str1.length()][str2.length()];
        dp[0][0] = a[0] == b[0] ? 1 : 0;
        for (int index2 = 1; index2 < b.length; index2++) {
            dp[0][index2] = a[0] == b[index2] ? 1 : dp[0][index2 - 1];
        }
        for (int index1 = 1; index1 < a.length; index1++) {
            dp[index1][0] = a[index1] == b[0] ? 1 : dp[index1 - 1][0];
        }
        for (int index1 = 1; index1 < a.length; index1++) {
            for (int index2 = 1; index2 < b.length; index2++) {
                int p1 = a[index1] == b[index2] ? dp[index1 - 1][index2 - 1] + 1 : 0;
                int p2 = dp[index1][index2 - 1];
                int p3 = dp[index1 - 1][index2];
                dp[index1][index2]= Math.max(Math.max(p2, p3), p1);
            }
        }
        return dp[str1.length() - 1][str2.length() - 1];
    }
```

### 洗咖啡杯问题

![image-20220528134449517](./image\image-20220528134449517.png)



### 马跳棋盘问题



```java
private static int steps1(int x,int y,int k){
    return process1(x,y,k);
}

/**
 *棋盘的大小是9*10 --->映射到下标就是0~8和0~9
 * 按理来说应该是由五个参数，2个目标位置的参数不变化，3个可变参数，2个现在位置，1个剩余的步数
 * 但是我们考研进行转化，我们的马从(0,0)走向(x,y)，其实反过来看，我们的马可以等价于从(x,y)走向(0,0)，
 * 所以我们可以省略目标参数
 * @param x:目标位置横坐标
 * @param y:目标位置纵坐标
 * @param k:还有k步可以走
 * @return :返回总共有多少种方法可以走到目标位置。这明显是一个收集合格的叶子结点的问题，合格为1，不合格为0.
 *          以及需要将跳出界限的分支杀死--返回0.
 */
private static int process1(int x, int y, int k) {
    if (k==0) return x==0&&y==0?1:0;//走到了最底下的叶子结点，收集合格的叶子结点
    if (x<0||x>8||y<0||y>9) return 0;//扼杀不合格的分支
    return process1(x+1,y+2,k-1)+process1(x+1,y-2,k-1)+
            process1(x-1,y+2,k-1)+process1(x-1,y-2,k-1)+
            process1(x+2,y+1,k-1)+process1(x+2,y-1,k-1)+
            process1(x-2,y+1,k-1)+process1(x-2,y-1,k-1);
}

private static int waysDP(int x,int y,int k){
    int[][][] dp=new int[9][10][k+1];//0~8  0~9  0~k
    dp[0][0][0]=1;//初始化，其它默认就是0，不用管
    for (int level=1;level<=k;level++){//k
        for (int i = 0; i < 9; i++) {//x
            for (int j = 0; j < 10; j++) {//y
                dp[i][j][level]=getVal(dp,i+1,j+2,level-1)+getVal(dp,i+1,j-2,level-1)+
                        getVal(dp,i-1,j+2,level-1)+getVal(dp,i-1,j-2,level-1)+
                        getVal(dp,i+2,j+1,level-1)+getVal(dp,i+2,j-1,level-1)+
                        getVal(dp,i-2,j+1,level-1)+getVal(dp,i-2,j-1,level-1);
            }
        }
    }
    return dp[x][y][k];
}

private static int getVal(int[][][]dp,int x,int y ,int k){
    if (x<0||x>8||y<0||y>9) return 0;
    return dp[x][y][k];
}
```

## 滑动窗口

> 滑动窗口是什么?滑动窗口是—种想象出来的数据结构:
>
> 	滑动窗口有左边界L和右边界R
> 	在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分
> 	L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口
> 	L和R都只能往右滑

---

假如有一个数组，一开始窗口的左边界和右边界都在最左侧的位置，-1位置。没有包住任何一个数。

窗口运动遵循几个原则：

1. 右边界右移即R++，指的是新的一个数从右侧进入了窗口。
2. 左边界右移即L++，指的是已经进来的数从左侧出去了。
3. 任何时候L都要小于等于R。也就是不能跑到R的右边去。

---

每次L和R的移动都会导致窗口的状况改变。那么我如何知道每一个状况窗口的最大值或者是最小值？我能不能找一个不遍历的方法来实现这个功能。是可以的，这就是我们所说的窗口内最大值的更新结构，我做出一个结构，这个结构随着窗口的状况变化也随之变化，效果就是我每次想要达到窗口内的最大值我都能迅速的得到。

我们可以用单调双端队列（一个数可以从头进从头出，也可以从尾进从尾出）来实现这个结构---得到最大值，我们维持双端队列从头到尾是从大到小。

1. 在进数的时候也就是R++，从尾部加，如果队列为空或者前一个位置的数比自己大，那么就直接从尾部放入。如果加数的时候发现前面的数比自己小，就不停的从双端队列的尾部弹出数，直到双端队列为空或者前一个数比自己大了才从尾部进去
2. 在出数的时候也就是L++，看一下当前双端队列的头部的数是不是过期的那个数，例如L=5，L++变成了6，那么过期的那个数的下标就是5。此时看一下双端队列的头部是不是过期的那个数，如果是就弹出，如果不是就跳过，什么也不做。

这样做出来的双端队列头部的值就是我们现在窗口的最大值。可以看到，这个双端队列在进数的时候可以一直保证队列的头部是最大值。因为窗口可能会出数，所以利用L来推算出过期的数，这样就让双端队列的最左边一直保持的是不过期的（不过期说明这个数还在窗口里）最大值。

- 在R不动，L++的情况下，L位置的数过期了。此时双端队列里面的值代表的是哪些数会成为最大值的优先级。即值决定了哪些位置会依次成为最大值。例如双端队列现在的情况是2,1。现在我们进入了一个3，根据我们的规则，1和2都要弹出。凭什么可以这样？因为这个时候L不动，我从L到R的最大值就是3，因为3晚过期，怎么都轮不到3前面的1和2当最大值。同理，如果下一个进来的数比3小的话例如1，我们可以把它入队，放到3的后面。因为一旦3过期了，最大值就是1了，因为这个时候只有1不是过期的。
- 值比你好，比你晚过期----直接把前面的扔了。值比你坏但是比你晚过期，先留着。（好坏决定于是要最大还是最小，如果要最大，那么好的就是大于）
- 值相等也把前面的扔了
- 要把得到窗口的最小值我们只需要维持从头开始到尾部双端链表的值是从小到大就行了。
- 一个数要把从尾巴出去，要么从头出去。从尾巴出去（R++，出数的时候）就是后面进来了一个晚过期而且比它好的数（这个“好”取决于你要的是最大值还是最小值）。从头出去说明这个数是被过期掉的（L++，出数的时候）。每一个记录最多进双端队列一次，出双端队列一次。
- 窗口划过了N个数，双端队列的总代接是O（N），因为每个位置（index）最多进一次，最多出一次。平均下来每划过一个数的代价就是O（1）。
- 窗口用两个整型控制即可
- L的值代表的是最近一次出窗口的数的下标，R代表的最近一次进窗口的下标。也就是说(L,R]代表的是窗口囊括的数

### 固定大小窗口划过数组

- 题目：假设一个固定大小为W的窗口，依次划过arr。返回每一次滑出状况的最大值
  例如, arr = [4,3.5,4,3,3,6,7],W = 3

  返回:[5.5,5,4,6,7]

分析：根据前面的滑动窗口的结构，我们先让窗口滑动到R=w-1，记录下此时的最大值。之后每次都r++，l++再记录一次最大值。直到r越界了。

- java中LinkedList就是双端队列。前面在讲的时候双端队列里有index还有值。由于这里是arr，我们要值需要arr[index]即可。一定不能只放值！！！因为我们有通过index来判断过期，有了位置我即可拿到值，也可以判断是否过期。靠近头部存放的位置所对应的值一定要是最大的。
- 窗口并不是要独立写一个数据结构才能用。只需要维持一套逻辑就能用。这道题固定窗口大小决定了过期位置是确定的，即L可以用R推断出来。L=R-w+1,w为窗口大小

#### 代码

```java
public static int[] getMaxWindow(int[] arr, int w){
    if (arr == null || arr.length == 0||w<=0) {
        return null;
    }
    int[] res=new int[arr.length-w+1];//长度为3对应1个结果，3-w+1
    int index=0;//专门给res数组用
    //这是一个双端队列。队头放大的值，需要谁就把谁放在队头。里面的值是下标
    LinkedList<Integer> qmax=new LinkedList<>();
    for (int R=0;R<arr.length;R++){//arr的每一个数一个一个进入窗口
        //不断的循环，直到当前队尾比R对应的值大，或者一直到队列为空。
        while (!qmax.isEmpty()&&arr[qmax.peekLast()]<=arr[R]){//把队列里面值比R小的先踢出去
            //比不过R就从尾巴出去，位置留给R
            qmax.pollLast();
        }
        qmax.addLast(R);
        if (R>=w-1){//从窗口扩大到w开始之后。不仅要进去一个，还要过期一个。在过期一个之前顺便得到一个结果
            res[index++]=arr[qmax.peekFirst()];//先得到一个结果再去过期一个
            if (R-w+1==qmax.peekFirst()){//过期操作。R-w+1是过期的位置，去判断当前队头是不是过期了！
                qmax.pollFirst();//过期就从队头出去
            }
        }
    }
    return res;
}
```

### 达标子数组问题

- 题目：给定一个整型数组arr，和一个整数num
  某个arr中的子数组sub，如果想达标，必须满足∶

  sub中最大值-sub中最小值<= num,
  返回arr中达标子数组的数量

#### 分析

暴力解很显然，就是枚举每一个数组，看看每一个达不达标。枚举出每一个子数组-----N²，找出最大值最小值----N。合起来就是N³的解。

这里有一个隐藏条件：子数组A要满足条件，必须满足子数组A的子数组A1也要满足条件。因为子数组A如果满足条件，maxa>maxa1,mina<mina1。既然A都满足maxa-minb<=num，那么maxa1-mina1也必然<=num。

隐藏条件的拓展：如果小范围上的子数组已经不达标了，这个子数组扩充得到的大数组一定也不达标。

做法：做出两个窗口的更新结构，一个更新最大值，一个更新最小值。这样我就可以让窗口一直长大，一直到窗口不达标了我就停，不让那个会使得窗口不达标的数进这个窗口（体现在R++会因为不合格break跳过）。这样一来我们就可以知道以L开始的窗口的达标个数。然后让L往右边走，继续让R扩充（也可能不扩充了，因为第二次进来会反复加一次R，如果还是不达标，那么R还是不能++），这样又可以求出L+1开始的窗口达标的有几个。有几个？----利用下标相减。

整个过程L和R不回退。代价为O（N）。



---

优化一个题有几个方向：

1. 数据状况
2. 问题本身

这题是属于两个方向结合做优化。首先要能够用窗口内最大值和最小值的更新结构的前提是它的求解流程得是一个窗口。这道题得益于我们的那两个隐藏条件。子数组达标外扩必定不达标。子数组达标，它的子数组必定达标。这样一来我们就把范围和问题本身建立了单调性-----不达标，扩大必定不达标。达标，缩小必定达标。

把范围和问题建立单调性经常可以用首尾指针或者滑动窗口写。

#### 代码

```java
/**
 * @param arr:
 * @param num:子数组的最大值和最小值的差<=num
 * @return :返回满足条件的子数组的个数
 */
public static int getNum(int[] arr, int num){
    if (arr==null||arr.length==0||num<0){
        return 0;
    }
    int res=0;
    LinkedList<Integer> qmin=new LinkedList<>();
    LinkedList<Integer> qmax=new LinkedList<>();
    int R=0;//一直向前不回退
    //求出以每一个位置作为开头的达标子数组的数量
    for (int start=0;start<arr.length;start++){
        while(R<arr.length){
            //R进到窗口中,维持最大值和最小值的结构
            while(!qmax.isEmpty()&&arr[R]>=arr[qmax.peekLast()]){//谁大谁有理
                qmax.pollLast();
            }
            qmax.addLast(R);
            while(!qmin.isEmpty()&&arr[R]<=arr[qmin.peekLast()]){//谁小谁有理
                qmin.pollLast();
            }
            qmin.addLast(R);
            //判断是否达标。下面出窗口需要peek，所以这里不能因为不达标就直接出了。在上面重复进队的时候while会帮我们重置。
            if (arr[qmax.peekFirst()]-arr[qmin.peekFirst()]>num){
                break;//不达标---加入了R之后变得不达标了1。
            }
            R++;
        }
        //start出窗口，过期，更新结构
        if (start==qmin.peekFirst()){
            qmin.pollFirst();
        }
        if (start==qmax.peekFirst()){
            qmax.pollFirst();
        }
        res+=(R-start);//偏移了R-start次到达了不达标的位置。算上自己的位置刚好就是偏移量。
    }
    return res;
}
```

## 单调栈

给定一个数组，要你找出每一个数左右两边离它最近并且比它小的数在哪。没有的话标记为-1。

我想求每一个位置，左边和右边离它最近的比它小的数的位置在哪，这么一张表就是单调栈要解决的问题。

暴力解法是O（N²），单调栈可以做到O（N）。

流程：先假设这个数组没有重复值。栈底放的是比较小的数，因为这里我们要求的是左右边离最近的比它小的数。如果是要求比它大的数的话，栈底就放比较大的数。所以现在我们的栈从栈底到栈顶是从小到大的。

如果栈为空就直接进栈，如果不为空就检查目前的栈顶是不是比你小。如果比你小就直接进栈。如果比你大，那么栈顶就弹出，同时生成栈顶那个数的记录。谁让你出来的，谁就是右边离你最近的小于你的数。你底下压的是谁，谁就是左边离你最近的比你小的数。让栈顶一直弹出，弹出几个数就生成几个记录，直到这个数被放入栈中。

整个数组处理完了就开始单独处理栈里还剩下的东西。这个时候栈里的数就都没有右边离它最近比它小的数了，因为这个时候的栈里面的数是我让他弹出的，而不是因为有一个数要进来才导致它弹出的。这个数底下压的是谁，谁就是左边的最近的比它小的数。

在这一整个流程中，所有的数都是进一次出一次，所以整体的时间复杂度是O（1）。

- 看下图abc情况。b在a的上面，意味着之前加载a和b之间的数都比b大，所以a一定是左边最近的比b小的数。同理，b和c之间的数都被c给弹出了，说明这些数都比b大，但是比c小。因为此时c要把b也弹出。所以c也比b小。所以b的右边最小就是c

![image-20220602110327783](image/image-20220602110327783.png)

- 栈顶如果放小，那么求出来的就是离得最近的大于它的两个数。

---

上面的是没有重复值的数组。如果有重复值的话，栈里面就放的不是整型了，而是放一个整型列表，里面存的是对应值相等的下标。

- 流程类似。唯一不同的点就是如果相等的话就加到列表里面去。如果弹出就整个列表一起弹出，一起设置。

![image-20220602145534590](image/image-20220602145534590.png)



### 实现代码

- 注意，如果你要的是最近的大于等于index的下标，那么在whilie循环的时候如果arr[i]<arr[stack.peek()]让栈顶弹出。<符号是大于等于的相反面

```java
public static int[][] getNearLessNoRepeat(int[] arr){
    int [][] res=new int[arr.length][2];//一左一右
    Stack<Integer> stack =new Stack<>();//存放下标
    for (int i=0;i<arr.length;i++){
        while(!stack.isEmpty()&&arr[i]<arr[stack.peek()]){
            int index=stack.pop();//弹出
            //设置
            int left=stack.isEmpty()?-1:stack.peek();//前面一步有弹出，这里要检查
            int right=i;
            res[index][0]=left;
            res[index][1]=right;
        }
        stack.push(i);
    }
    while(!stack.isEmpty()){
        int index=stack.pop();//弹出
        //设置
        int left=stack.isEmpty()?-1:stack.peek();
        int right=-1;
        res[index][0]=left;
        res[index][1]=right;
    }
    return res;
}


/**
 * 逻辑：1.空栈，直接创建列表入栈然后把数插进去。2.栈非空且数组中的数大于栈顶列表代表的数，创建列表入栈然后把数插进去
 * 3.栈非空且数组中的数等于栈顶列表代表的数，直接把数插进栈顶的的列表中。
 * 4. 栈非空且数组中的数小于栈顶列表代表的数，循环弹出栈顶的列表并且设置直到跳出循环进入到123的逻辑分支
 * @param arr:目标数组
 * @return :数组的行号代表arr数组中的每一个数的下标，列一左一右放左右两边的最小
 */
public static int[][] getNearLess(int[] arr){
    int [][] res=new int[arr.length][2];//一左一右
    Stack<LinkedList<Integer>> stack =new Stack<>();//存放下标的列表
    for (int i=0;i<arr.length;i++){
        while(!stack.isEmpty()&&arr[i]<arr[stack.peek().peekLast()]){//小于
            LinkedList<Integer> list=stack.pop();//弹出
            //设置
            int left=stack.isEmpty()?-1:stack.peek().peekLast();//压着的队列的最后一个
            int right=i;
            for ( Integer j:list){
                res[j][0]=left;
                res[j][1]=right;
            }
        }
        if (!stack.isEmpty()&&arr[i]==arr[stack.peek().getLast()]){//等于
            stack.peek().addLast(i);//从尾部加
        }else {//大于
            LinkedList<Integer>list=new LinkedList<>();
            list.addLast(i);//从尾部加
            stack.push(list);
        }
    }
    while(!stack.isEmpty()){
        LinkedList<Integer> list =stack.pop();
        int left=stack.isEmpty()?-1:stack.peek().getLast();
        int right=-1;
        for (Integer i:list){
            res[i][0]=left;
            res[i][1]=right;
        }
    }
    return res;
}
```

### 求子数组（累加和 * 最小值）的最大值

- 题目：给定一个只包含正整数的数组arr, arr中任何一个子数组sub,一定都可以算出(sub累加和)* (sub中的最小值)，那么所有子数组中，这个值最大是多少?


子数组求和的技巧：生成一个前缀和数组sum[],其中sum[i]代表arr[0]+...+arr[i]。这样一来arr[L]+...+arr[R]=sum[R]-sum[L-1]

分析：

	问题拆解，这里有两个变量，一个是累加和一个是最小值。我们先把最小值定下来，然后此时要求整体的最大值就变成了求累加和的最大值，显然累加和要越大子数组的范围也要越大。然后在众多值中，求出来的情况中再选一个最大的。这样就得到了整体的最大值。
	
	所以这里我们就选中arr[0]当做这个最小值，看看往右边扩展可以扩展到多大。注意上面说的是找到最小值定下来最为一个最小情况。这里我们以arr中的每一个位置作为最小值是对上面说的进行进一步的拆解。

- 对单调栈做一个改进，我们找到离一个数最近的小于等于它的数就行。如果新数小于等于栈顶，那么栈顶就弹出。

![image-20220602152559257](image/image-20220602152559257.png)

#### 代码

```java
/**
 * 数组的每一个数作为最小值，找出扩展出来的最大子数组，因为这个数要作为最小值，所以数组里面的数都是要<=它。所以我们找出离它最近的
 * 大于它的左右两边的数L和R，(L,R)即是我们要找的最大子数组。我们要找出最近的大于index的数，while的判断条件就是
 * arr[i]<=arr[stack.peek()],注意观察<=是>的相反面。
 * @param arr:
 * @return :
 */
public static int max(int[] arr){
    int [] res=new int[arr.length];
    Stack<Integer> stack =new Stack<>();//存放下标
    int[] sum=new int[arr.length];
    sum[0]=arr[0];
    int max=Integer.MIN_VALUE;
    for (int i=1;i<arr.length;i++){
        sum[i]=sum[i-1]+arr[i];
    }
    for (int i=0;i<arr.length;i++){
        while(!stack.isEmpty()&&arr[i]<=arr[stack.peek()]){//这里是小于等于就行，不需要严格小于
            int index =stack.pop();
            //栈为空说明左边没有比arr[index]大的数，换言之左边的全部范围都属于我们的最大子数组
            max=Math.max(max,arr[index]*(stack.isEmpty()?sum[i-1]:sum[i-1]-sum[stack.peek()]));
        }
        stack.push(i);
    }
    while(!stack.isEmpty()){
        int index=stack.pop();
        //栈为空说明右边没有比arr[index]大的数，换言之右边的全部范围都属于我们的最大子数组
        max=Math.max(max,arr[index]*(stack.isEmpty()?
                                     sum[arr.length-1]:sum[arr.length-1]-sum[stack.peek()]));
    }
    return max;
}
```

- 直方图中截出最大的长方形（和上面一样的解法）

![image-20220602162516998](image/image-20220602162516998.png)



- 找出你要求的结果和范围之间的单调性。

## KMP

![image-20220913144606635](image/image-20220913144606635.png)

![image-20220913144613757](image/image-20220913144613757.png)

![image-20220913144618468](image/image-20220913144618468.png)

![image-20220913144622845](image/image-20220913144622845.png)

![image-20221114104953158](image/image-20221114104953158.png)

```java
private static int kmp(String str, String match) {
    if (str==null||match==null||match.length()<1||str.length()<match.length()) return -1;
    char[] s1 = str.toCharArray();
    char[] s2 = match.toCharArray();
    int[] next=getNext(match);
    int p1=0;
    int p2=0;
    while(p1!=str.length()&&p2!=match.length()){//不越界
        if (s1[p1]==s2[p2]){
            p1++;
            p2++;
        }else if (p2!=0){//p2还可以回退
            p2=next[p2];
        }else{//p2==0,回退不了了，说明p1现在这个位置不对
            p1++;
        }
    }
    return p2==match.length()?p1-p2:-1;
}

private static int[] getNext(String match) {
    if (match.length() == 1) return new int[]{-1};
    char[] chars = match.toCharArray();
    int[] next = new int[match.length()];
    next[0] = -1;
    next[1] = 0;
    int i=2;
    int p=next[1];//当前要从2位置开始填，所以p要等于next[2-1]
    while(i!=match.length()){
        if (chars[i-1]==chars[p]){//i-1位置和p位置相等,
            next[i++]=++p;//长度是i-1位置长度+1，p即代表要比较的位置，也代表前缀子串的长度
        }else if (p==0){//p前面无路可跳
            next[i++]=0;
        }else {//p前面还有路可以跳
            p=next[p];
        }
    }
    return next;
}

private static int baoli(String str,String match){
    if (str==null||match==null||match.length()<1||str.length()<match.length()) return -1;
    char[] s1 = str.toCharArray();
    char[] s2 = match.toCharArray();
    int p1=0;
    int p2=0;
    for (int i = 0; i < str.length(); i++) {
        p1=i;
        p2=0;
        while(p1!=str.length()&&p2!=match.length()){
            if (s1[p1]==s2[p2]){
                p1++;
                p2++;
            }else
                break;
        }
        if (p2==match.length())return p1-p2;
    }
    return -1;
}
```

- 应用

![image-20220916155702211](image/image-20220916155702211.png)

![image-20220916155817670](image/image-20220916155817670.png)



## Manacher

Manacher算法解决的是最长回文子串是多长。

解决回文有什么用处呢？DNA就是一些序列，可以把DNA认为是字符串，回文有一些生理学意义，有一些基因片段它是回文属性的，比如说人是对称的。在某一些DNA序列里面，基因的序列对呈现一些回文关系。

![image-20220916213833831](image/image-20220916213833831.png)

![image-20220916213839568](image/image-20220916213839568.png)

- 事实上，如果`i'`的范围越界了，也就是超过L了，那么i加上Parr[i']也会越出R。让Parr的含义变成右边界减去中心。此时如果i+Parr[i']<R,那么我们直接让Parr[i]等于Parr[i']。如果i+Parr[i']>R,那么就让Parr[i]等于R-i。也就是说Parr[i']<R-i时选Parr[i']。Parr[i']>R-i时选R-i。等价于在i在R内，并且i'不是踩在边界的情况下Parr[i]=min（R-i,Parr[i']）

  也就是Parr[i]=min（R-i+1,Parr[i']）.

  如果i+Parr[i']==R，那么就让它等于R-i+1，然后

![image-20220916213844479](image/image-20220916213844479.png)

![image-20220916213848519](image/image-20220916213848519.png)

![image-20220916213852397](image/image-20220916213852397.png)

## 斐波那契数列

- 斐波那契数列的递推式，F(N)=F(N-1)+F(N-2)，f(0)=1,f(2)=1.

斐波那契数列是由严格递推式的，不随条件转移。不是说在某些情况下才等于这个递推式，而是在任何情况下都满足这个式子。

![image-20220912213129224](image/image-20220912213129224.png)

![image-20220912213134578](image/image-20220912213134578.png)

```java
//普通递归
private static int f1(int n){
    if (n<1)return 0;
    if (n==1||n==2)return 1;
    return f1(n-1)+f1(n-2);
}

/**
 * 利用动态规划
 * @param n:返回斐波那契数列的第n项
 * @return :
 */
private static int f2(int n){
    if (n<1)return 0;
    if (n==1||n==2)return 1;
    int res=0;
    int n1=1;
    int n2=1;
    for (int i = 0; i < n - 2; i++) {//res迭代n-2次就是答案
        res=n1+n2;
        n1=n2;
        n2=res;
    }
    return res;
}

private static int f3(int n){
    if (n<1)return 0;
    if (n==1||n==2)return 1;
    int[][] m=new int[][]{{1,1},{1,0}};
    m=matrixPower(m,n-2);
    return m[0][0]+m[1][0];
}

/**
 *
 * @param a:矩阵
 * @param n:矩阵a的n次方
 * @return :返回结果
 */
private static int[][] matrixPower(int[][] a,int n){
    if (n<=0) return null;
    int[][] res=new int[a.length][a[0].length];
    for (int i = 0; i < res.length; i++) {//初始化为单位矩阵
        res[i][i]=1;
    }
    int [][]m=a;//一次方
    for (;n!=0;n>>=1){
        if ((n&1)==1) res=mulMatrix(res,m);
        m=mulMatrix(m,m);//m平方
    }
    return res;
}


private static int[][] mulMatrix(int[][]a,int[][]b){
    int[][] res=new int[a.length][b[0].length];
    for (int i = 0; i < a.length; i++) {
        for (int j = 0; j < b.length; j++) {
            for (int k = 0; k < b[0].length; k++) {
                res[i][j]+=a[i][k]*b[k][j];
            }
        }
    }
    return res;
}
```

达标字符串问题

![image-20220912213210450](image/image-20220912213210450.png)

 ![image-20220913192648236](image/image-20220913192648236.png)

```java
public static int getNum1(int n) {
    if (n < 1) {
        return 0;
    }
    return process(1, n);
}

/**
 * fi,如果i+1位置是1，那么就变成fi+1.如果i+1位置是0，那么fi+2位置就是1，就变成fi+2
 * @param i:从str[i,n]假设i位置是1，有多少种方法
 * @param n:01序列的长度
 * @return
 */
public static int process(int i, int n) {
    if (i == n - 1) {//n位置分别取1和2
        return 2;
    }
    if (i == n) {//n位置直接就是1，只有一种方法
        return 1;
    }
    return process(i + 1, n) + process(i + 2, n);
}

public static int getNum2(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    int pre = 1;
    int cur = 1;
    int tmp = 0;
    for (int i = 2; i < n + 1; i++) {
        tmp = cur;
        cur += pre;
        pre = tmp;
    }
    return cur;
}

public static int getNum3(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return n;
    }
    int[][] base = { { 1, 1 }, { 1, 0 } };
    int[][] res = matrixPower(base, n - 2);
    return 2 * res[0][0] + res[1][0];
}

public static int fi(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return 1;
    }
    int[][] base = { { 1, 1 },
            { 1, 0 } };
    int[][] res = matrixPower(base, n - 2);
    return res[0][0] + res[1][0];
}

public static int[][] matrixPower(int[][] m, int p) {
    int[][] res = new int[m.length][m[0].length];
    for (int i = 0; i < res.length; i++) {
        res[i][i] = 1;
    }
    int[][] tmp = m;
    for (; p != 0; p >>= 1) {
        if ((p & 1) != 0) {
            res = muliMatrix(res, tmp);
        }
        tmp = muliMatrix(tmp, tmp);
    }
    return res;
}

public static int[][] muliMatrix(int[][] m1, int[][] m2) {
    int[][] res = new int[m1.length][m2[0].length];
    for (int i = 0; i < m1.length; i++) {
        for (int j = 0; j < m2[0].length; j++) {
            for (int k = 0; k < m2.length; k++) {
                res[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
    return res;
}
```

## 蓄水池算法

蓄水池问题：假设有一个机器，源源不断吐出球，机器可以认为是一个流，从一号球开始吐，吐完一号球一定吐二号球，以此类推。但是你只有一个能装下十个球的袋子。机器吐出来的每一个球你都要去决定是入袋子还是扔掉。如果你扔掉了这个球，那么你永远也无法找回。那么现在要保证吐出来的每一个球被选中的概率都是相等的。也就是说如果吐了1000个球，你要保证每一个球被选中的概率都是10/1000。它每吐出任何一个球都得保证吐出过的求被选中的概率都是相等的。

- 这个题不是说我搞了一个序列之后我才弄随机，弄不了，因为只有十个球的空间。不能把过往的球都留下来才弄随机。难点在这。

流程：

1. 在机器吐出1~10号球的期间，完全入袋子，没有筛选逻辑。每一个球都不扔掉，都进袋子。

- 接下来引入一个随机函数f，假设有一个随机函数给我们用，随机函数当我传入i的时候给我返回1~i等概率的一个数字。

2. 如果我吐出了k号球，k号球是1~10之外的一个数。当它出现的时候我要有一个决策来决定要不要它。我用10/k的概率决定这个球要不要入袋子。那么就调用f（k），如果f（k）返回的是1~10那么就进入袋子，否则就扔掉。如果k号球要进袋子，舍弃袋子里的谁？--袋子里的球等概率扔一个。

为什么这样的流程可以保证在每一次吐出一个球的时候，之前吐出的所有球都等概率进袋子。

![image-20220913093615382](image/image-20220913093615382.png)

这样的算法有什么用？想象你有100的用户，要在今天选出所有登录的用户中的100个作为幸运观众。如果你是暴力解，你只能先把所有的登录作为一个list，然后去掉重复的用户，然后再从中做随机，选出100个观众。这样的暴力求解需要把所有数据放到一个大服务器上进行运算，而且只选出100个观众。

但是如果使用蓄水池算法，那么我只需要一台服务器，就给我100个位置每个用户在登录的时候实现两个方法。f1验证你今天是不是首次登录。f2方法得出你是全球第几个（x）登录的用户。如果用户是首次登录，那么就以100/x的概率决定进去，然后从袋子中随机踢出去一个。最后再开奖的时候直接公布这100个人即可。根本不需要各个服务器之间同步数据。稍微有点难度的就是要知道你是全球第几个登录的用户，这个还是相对好实现的。

原本以非常大的代价才能能够搞定的事情，现在变成了动态决定。我就准备只有100个人的空间，这个事情就拿下了。

```java
public static class RandomBox {
   private int[] bag;
   private int N;//袋子的大小
   private int count;//已经过了count个球

   public RandomBox(int capacity) {
      bag = new int[capacity];
      N = capacity;
      count = 0;
   }

   private int rand(int max) {
      return (int) (Math.random() * max) + 1;
   }

   public void add(int num) {
      count++;
      if (count <= N) {
         bag[count - 1] = num;
      } else {
         if (rand(count) <= N) {
            bag[rand(N) - 1] = num;
         }
      }
   }

   public int[] choices() {
      int[] ans = new int[N];
      for (int i = 0; i < N; i++) {
         ans[i] = bag[i];
      }
      return ans;
   }

}
```



## bfprt算法

- 有更好的算法笔试使用。笔试的时候不要使用bfprt算法。这是面试用的

![image-20220916155842116](image/image-20220916155842116.png)

![image-20220916155849864](image/image-20220916155849864.png)

![image-20220916155857839](image/image-20220916155857839.png)

```java
public class Code01_FindMinKth {//bfprt,寻找第k小

    // 利用大根堆，时间复杂度O(N*logK)。原理：k大小的大根堆，每次遍历数组都让比较大的出堆，这样到结束大的都出去了，剩下的就是第k小的
    // 因为剩下的k个是arr中前k小的数，他们之中最大的，也就是位于堆顶的数就是第k小的数。
    public static int minKth1(int[] arr, int k) {
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((Integer o1,Integer o2)->{return o2-o1;});
        for (int i = 0; i < k; i++) maxHeap.add(arr[i]);//保持堆有k的空间即可，这样每次添加或者删除都是常数操作lgk
        for (int i = k; i < arr.length; i++) {
            if (arr[i] < maxHeap.peek()) {//让两者之间比较大的那个进不了堆，或者出堆
                maxHeap.poll();
                maxHeap.add(arr[i]);
            }
        }
        return maxHeap.peek();
    }

    // 改写快排，时间复杂度O(N)
    public static int minKth2(int[] array, int k) {
        int[] arr = copyArray(array);
        return process2(arr, 0, arr.length - 1, k - 1);
    }

    public static int[] copyArray(int[] arr) {
        int[] ans = new int[arr.length];
        for (int i = 0; i != ans.length; i++) {
            ans[i] = arr[i];
        }
        return ans;
    }

    /**
     * @param arr:在arr中找在下标[L,R]中排在第index位置的数。arr数组无序，在无序的arr中找出实际上应该排在index位置的数
     * @param L:左边界，包括
     * @param R:右边界，包括
     * @param index:找出在下标[L,R]中排在第index位置的数
     * @return :返回这个在下标[L,R]中排在第index位置的数
     */
    public static int process2(int[] arr, int L, int R, int index) {
        if (L == R)  return arr[L];//base case。此时L=R=index
        int pivot = arr[L + (int) (Math.random() * (R - L + 1))];//pivot ∈ [L,R-L]
        int[] range = partition(arr, L, R, pivot);//三向切分
        if (index >= range[0] && index <= range[1]) {//index在它们之间，数都是相等的说明已经找到了
            return arr[index];
        } else if (index < range[0]) {//到左边去递归
            return process2(arr, L, range[0] - 1, index);
        } else {//到右边去递归
            return process2(arr, range[1] + 1, R, index);
        }
    }

    /**
     *
     * @param arr:进行划分的函数
     * @param L:划分的左边界，包括
     * @param R:划分的右边界，包括
     * @param pivot:这里显式指定了一个划分值，我们也可以实现一个默认是最左边的数或者是最右边的数做划分值的partition函数
     *             但是这样的话我们就要在调用函数中从[L,R]中随机选择一个数与最左或右的数做交换，再进行partition，实现随机
     * @return :返回与划分值相等的范围
     */
    public static int[] partition(int[] arr, int L, int R, int pivot) {
        int less = L - 1;
        int more = R + 1;
        int cur = L;
        while (cur < more) {//与more撞上就停止，说明中间的不确定区域已经全部搞定
            if (arr[cur] < pivot) {
                swap(arr, ++less, cur++);
            } else if (arr[cur] > pivot) {
                swap(arr, cur, --more);
            } else {
                cur++;
            }
        }
        return new int[] { less + 1, more - 1 };
    }

    public static void swap(int[] arr, int i1, int i2) {
        int tmp = arr[i1];
        arr[i1] = arr[i2];
        arr[i2] = tmp;
    }

    // 利用bfprt算法，时间复杂度O(N)
    public static int minKth3(int[] array, int k) {
        int[] arr = copyArray(array);
        return bfprt(arr, 0, arr.length - 1, k - 1);
    }

    // arr[L..R]  如果排序的话，位于index位置的数，是什么，返回
    public static int bfprt(int[] arr, int L, int R, int index) {
        if (L == R) {
            return arr[L];
        }
        int pivot = medianOfMedians(arr, L, R);
        int[] range = partition(arr, L, R, pivot);
        if (index >= range[0] && index <= range[1]) {
            return arr[index];
        } else if (index < range[0]) {
            return bfprt(arr, L, range[0] - 1, index);
        } else {
            return bfprt(arr, range[1] + 1, R, index);
        }
    }

    /**
     *
     * @param arr:arr[L,R]中的元素五个一组，返回组中位数们的中位数
     * @param L:包括
     * @param R:包括
     * @return :返回中位数们的中位数
     */
    public static int medianOfMedians(int[] arr, int L, int R) {
        int size = R - L + 1;
        int offset = size % 5 == 0 ? 0 : 1;//是否有不够五个的组
        int[] mArr = new int[size / 5 + offset];
        for (int team = 0; team < mArr.length; team++) {
            int teamFirst = L + team * 5;
            mArr[team] = getMedian(arr, teamFirst, Math.min(R, teamFirst + 4));
        }
        // marr中，找到中位数
        // marr(0, marr.len - 1,  mArr.length / 2 )
        return bfprt(mArr, 0, mArr.length - 1, mArr.length / 2);
    }

    /**
     * @return :取得arr[L,R]的中位数。偶数返回上中位数
     */
    public static int getMedian(int[] arr, int L, int R) {
        insertionSort(arr, L, R);//排序的个数小，使用插入排序反而快
        return arr[(L + R) / 2];
    }

    public static void insertionSort(int[] arr, int L, int R) {
        for (int i = L + 1; i <= R; i++) {
            for (int j = i; j-1 >= L && arr[j-1] > arr[j]; j--) {
                swap(arr, j, j - 1);
            }
        }
    }
```

## Morris遍历

之前看过树的几种遍历方式，无论是二叉树的递归遍历还是利用非递归的方式完成遍历，都是需要额外空间的。时间复杂度是O（N），和结点的个数有关。空间复杂度和高度相关，无论你是利用的递归调用的系统栈还是自己的栈，空间复杂度都是O（h）。

Morris遍历的厉害之处在于可以把空间复杂度优化成O（1）。很多树的问题和树的遍历有关，掌握了一个性能优良的遍历，意味着某一个关于树的遍历的问题，Morris遍历的流程就是最优解。笔试的时候以最快的通过为准，面试的时候再拿出来聊。

![image-20220919201056353](image/image-20220919201056353.png)

![image-20220919201101752](image/image-20220919201101752.png)

利用递归调用，可以回到自己3次。Morris遍历不能做到检查三次，但是可以做到前两次。

```
if (head==null)return;
//1     
posOrderRecur(head.left);
//2
posOrderRecur(head.right);
//3
```

如果找到一个结点的真实的最右结点？只需要加一个判断，走到一个结点的右指针为null或者是cur就停。null的时候出来代表我当前是第一次来到cur，否则就是第二次来到cur。

即便每个结点都有找到左树右边界的代价，总的代价最多也就2N。所以总代价也不会超过O（N）

现在我们已经知道Morris序了，如果加工出先序、中序？

如何知道一个结点能不能来到自己两次？有左树就会来到自己两次。

---



- 先序：对于能来到自己两次的结点就让他第1次打印，其它结点都遇到就打印。

- 中序：对于能来到自己两次的结点就让他第2次打印，其它结点都遇到就打印。对于没有左树的结点，直接打印，然后往右移动。对于有左子树的结点，第二次来到自己是从mr的right指针回来的，回来之后也要往右移动。所以总结的说，一个结点要往右移动了就打印。

- 后序：打印时机为在第二次回到自己的节点上。第二次回到自己，就**逆序**打印自己左树的右边界。怎么想到的？因为整棵树可以利用左子树的右边界分解，不重复！！！

  现在问题是如何逆序打印右边界？此时mr已经指向空了，我们可以把cur.left到mr的一大串看成是一个单链表，我们翻转这个单链表，用完之后再调回来。

- 如何判断一个树是不是搜索二叉树？中序遍历一下，如果值一直是递增的，它就是搜索二叉树。我们把中序遍历的打印时机变成比对时机即可。

---



- 一棵树，我想知道上面的最小高度。最小高度：只有我到了叶子结点我才有一个高度，我想知道在所有叶子结点中，那个是距离头部最短的，我想把那个距离返回。

利用递归套路：如果我左树不为空我就求左树最小高度+1，如果右树不为空就求右树的最小高度+1，两个比对，谁更小谁就是我的最小高度。这个方法额外空间很高，树的高度就是额外空间。

如何用Morris遍历来改写？改写的难度就是我们只能用有限几个变量。

1. cur来到任何位置的时候能否知道它现在所在的高度？
2. 如果我能够确定cur此时是叶子结点，我就记录它的高度，我用一个全局最小值min来捕捉它。

如果能够做到1,2两个机制，我们就能利用Morris遍历改出来。

如何做到1？一开始的cur在第一层，高度为1。如果cur无左树（Morris遍历的第一种情况），下一步的cur是往右移，在cur往右移动之前把level++。现在来看Morris遍历的第二种情况，如果cur有左树，我们可以区别分出它是第一次来到自己还是第二次来到自己。我们要阻止从底下的mr跳上来的情况。如果cur是第一次来到自己，cur往左走，level++。如果是mr跳上来的话怎么办？ mr-cur左树右边界的节点数。

假设pre为前驱结点，如果pre.left=cur,也就是说我们是通过从pre往左走下来的，level++。但是pre.right==cur的时候不能呢level++，因为我不能确定我的前驱是不是在底下，不能确定我是不是跳上来的。所以我们这样判断：如果pre.right==null，那么就可以level++，否则如果pre.right==cur的话就利用mr的高度-cur左树右边界的节点数。

做到2？我们能不能知道cur真实情况下是不是叶子结点？不能做到！！！！因为真正当你到达一个叶子结点的时候你判断不出来，因为它的右指针一定是改过的。

那么我们如何把所有的叶子结点拿到？所有的叶子结点都会在能回到自己两次的结点的时候重新发现一遍。

![image-20220919213520774](image/image-20220919213520774.png)

整棵树的最右的叶子结点7没有人去发现，我们需要单独去捉7的高度。从mr跳上来的时候，我们要判断一个mr是不是叶子结点，是才参与更新，不是就不参与更新。如何判断mr.left如果为空它就是叶子结点。

- 代码：







---

- 总结

什么时候一个流程可以定成Morris遍历？如果是定成从左树收集信息，从右树收集信息完了之后做整合的话就不能用Morris遍历。但是如果左树的信息用完之后我不要了，我可以利用一个变量把左树的所有信息继承下去，比如说min，那么我就可以用Morris改。

如果信息可以传递就能改，如果不能传递，就不能改。

## 线段树

- 线段树是用来更快的区间的修改、更新、查询一些东西。

先看典型的应用场景再看如何推广。给定一个有0~1000下标的数组。做出一个线段树结构，对外提供三个接口。

  add：将arr数组中L~R范围上的数全部+v

  update：将arr数组中L~R范围上所有的数全部变成v

  getsum：将arr数组中L~R范围上所有的数的累加和返回

  也可以把线段树称为区间修改树。在实现中0下标的位置全部弃而不用。要做到三个方法全部都做到logN为复杂度

  ![image-20221113234150731](image/image-20221113234150731.png)

先来建立一些概念。先假设数组的长度是2的次幂。例如数组的长度是8，下标的值对应1~8。要把某一个大范围二分下去的每一个小范围的信息都记录下来，如何实现，用某一个结点记录1~8的信息，这个“信息”具体可能是一个整数值。也就是L~R的一个范围会对应一个信息，这个信息是一个整数值。那么1~8这个范围二分下去的小范围就是1~4以及5~8。以此类推往下分。

分完之后的结构如下。现在随便给你一个范围，如果是正好二分到的范围，那么就可以直接找到。如果不是正好二分到的范围，也可以通过某些组合得到。刚刚我们说“信息”先看成一个整数，现在把信息看成是累加和，那么观察下图可以发现此时线段树的**每一个结点的信息都可以由左右孩子的信息得到**。并且可以计算的值这个树的总结点数在我们的假设的条件下为2N-1个。

![image-20221113234158393](image/image-20221113234158393.png)

前面我们的假设是arr中元素的个数是2的次幂。现在希望在arr的个数不是2的次幂的时候，都希望构建出来的这棵树是满二叉树。举个例子，假设现在arr只有6个数，我可以认为最底层还是8个结点，但是我认为第7个数和第8个数都是0，并且如果你让我在某个范围修改的时候发现下标已经超过6了，那么我就忽略，我自己是知道我自己的空间是1~6，但是我为了让它变成满二叉树，我们可以通过补0的方式来实现。这么做是因为只有arr的个数刚好是2的次幂的时候才能够每次二分都能够均分，所以当个数不够的时候我们也要一个满二叉树。

并且可以计算得出对于任意arr中元素的个数N，所需要的线段树的结点个数。经过推导可以知道，4N的空间肯定够用，那么我每次底层都准备4N的空间来装树的结点，没用到的浪费了就浪费了。

![image-20221113234215396](image/image-20221113234215396.png)

这个满二叉树如何表示呢？利用数组即可，因为满二叉树有一个优雅的性质，一个结点的父节点为index/2，左孩子为2index，右孩子为2index+1。

![image-20221113234709370](image/image-20221113234709370.png)

算法的思想：

- 这个树中的每一个结点可以映射为(L,R)，也就是arr数组中的起始下标和终止下标。我们的目标是把4N长度的sum数组填好，要填好sum[0]需要知道sum[1]和sum(2)。如此，我们可以自顶向下利用递归填好sum数组，(L,R)只有当L==R的时候才能够填入sum[x]。所以递归的结构应该为process(int l,int r,int x)，意思是sum[x]位置对应的是L~R范围上的信息。
- 可以不用递归来做。我们可以不直接建立4N的空间，这样做太没脑子。我们可以聪明一点，因为每次我们都是要建立出一个满二叉树，根据上面的总结，结点的个数最多为<img src="image/image-20221114084000825.png" alt="image-20221114084000825" style="zoom:50%;" />，并且废弃掉0下标，我们可以直接建立一个<img src="image/image-20221114084018973.png" alt="image-20221114084018973" style="zoom:50%;" />大小的数组即可。这样一来我们直接倒着填充这个数组，从最后一个下标开始填，如果不存在就填0，把最后一层的填完之后就可以自底向上迭代的填好这个数组了。



---

现在假设我们已经填好了sum数组。现在提出一个概念：**懒更新**。假如现在要你在1~6范围上调用add方法，使得上面的数全部+4。此时的任务范围是1~6。1~6任务首先在顶部1~8，先看1~6有没有把当前所在的结点的范围包括了，没有的话就向左右孩子下发任务1~6。接着1~6任务来到了1~4结点，此时已经把1~4结点包括了，这次就不再去下发任务了。开始往lazy中填入信息，在lazy信息中找到对应的1~4的位置，把信息（这个信息是4，也就是要add的数值）填入。意味着我曾经收到过一个任务，让1~4所有的数字都+4，但是这个任务我不再下发了。同理，脑补出右边的执行过程1~6的任务会下发到5~6的范围，然后找到lazy对应的5~6范围，填入4。

那么利用懒更新机制可以达到多少的时间复杂度？代价：logN。因为其实就是左边往下走，右边往下走，直到左右两边都无路可走。沿途总有很多的结点会被lazy了。可以把这个过程看成是在拼接任务范围，利用小的范围拼接成任务范围的过程。

现在假设我们已经利用一个一个的小范围拼成了大范围的一个任务，并且这些小范围已经在lazy数组中的相应位置填上了你要add的数值。但是如果上面又下发了一个新任务到了某个范围（位置），此时如果这个范围的lazy不是0，那么说明这个范围的结点之前懒过，现在有任务来了，不能再懒了，我们需要把这个范围的lazy的值下发给它的左右孩子，然后把自己的lazy值变为0，表示我现在开始接活了。然后接着根据这个新任务的范围，决定下发给左右孩子。

例如：假设现在1~256的lazy为7。说明它之前懒住了。现在来了一个1~100的任务到1~256这个结点上，有新任务来了，它懒不住了，下发它的懒信息。左右孩子的lazy全部都更新为7。然后1~100的这个任务发放到1~128这个结点，然后1~128又懒不住了，继续下发lazy给它的左右孩子，然后才接活。以此类推。



---

- 算法add(int L,int R,int C,int l,int r,int rt)：L~R就是任务，C就是要加的数值。l~r是当前任务来到的范围，rt是l~r范围对应的结点的下标。
- 算法update。当l~r结点收到一个任务L~R上所有的数都更新为C。那么此时l~r结点的lazy直接清空，因为ilazy其实就是我之前懒得告诉下边的结点你要去更新你的sum值。现在你都要全部更新成C了，那我还告诉你啥，你直接C*对应的范围内数的个数不就行了。
- 大范围上的懒东西，无论是懒更新还是懒增加，一定都比子范围上的懒东西要晚！！所以父节点在发懒更新的时候字任务攒的懒更新和懒增加全部失效，sum也直接改了。在一个结点上面如果同时有懒更新和懒增加，懒更新一定是早于懒增加的，所以下发懒东西的时候一定要先发懒更新再发懒增加。
- 算法为什么快？因为一个范围性的信息被我们分割组合了，上级比较大，如果他自己能解决掉这个任务就不把任务下发给下级了，也就是上级lazy住了。如果上级解决不了这个任务再把之前自己lazy的分给下级也是不迟的，所以这样可以极大的提高了时间效率。lazy只是缓住了下级的更新，但是上级的sum值都是正确的。

---

线段树题目：

- 想象一下标准的俄罗斯方块游戏，X轴是积木最终下落到底的轴线
  下面是这个游戏的简化版：
  1)只会下落正方形积木
  2)[a,b]->代表一个边长为b的正方形积木，积木左边缘沿着X=a这条线从上方掉落
  3)认为整个X轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的
  4)没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。

  给定一个N*2的二维数组matrix,可以代表N个积木依次掉落
  返回每一次掉落之后的最大高度

 如何变成线段树模型：正方形-->落下来会导致有一个区域全部都+边长。落了一个[3,4],会导致3~6范围上全部+4，注意这里不是3~7范围，因为[3,4]这个块不会影响到另外一个块落到7上。那么这个模型需要维护哪些信息呢？sum数组变成了height数组，height数组里面维护的是每个范围对应的最大高度。并且我们是需要update而不是add，不要被前面说的“加”迷惑！因为下图在2下标落下了一个3边长的正方形之后会导致2~4下标范围全部更新为5！

<img src="image/image-20221113234512990.png" alt="image-20221113234512990" style="zoom:67%;" />

- 做离散化：它落的下标可能很远，不可能建一个非常大的数组。我们把落下来的每个方块对应的左右边界放进一个数组即可。



- 代码：









---

题目：房子染色问题。给你1~n个房子，给你m个颜色。[a,b,x]表示a~b范围的房子全部染成颜色x，对应update。[a,b]表示叫你返回a~b范围的房子有多少种不同的颜色，对应query。那么对应于每个区间我要维护什么信息呢？我关系的是这个区间里面使用了些什么样的颜色，别的我不关心。一个区间里面使用了什么颜色可以用一个boolean类型的数组来表示，数组里面的每一个位置对应的是一个颜色有没有使用。这样一来父区间使用的颜色就可以用左右孩子的两个boolean类型的数组或运算得到。

---

题目：最大线段重合问题。[1,3]代表在1~3范围上描一段，[2,4]表示在2~4范围上描一段。那么现在两段线段在2~3上是有重合的，这个重合信息记为2。那么[1,3]可以看成是在add(1,2,1)，也就是在1~2上加1，因为[1,3]在1~3画了一条线，不认为3被盖住了，其实这种边界问题见仁见智。父区间的重合信息其实是两个子区间的重合信息的最大值。依然需要进行离散化。

解释一下[1,3]映射成add(1,2,1)的原因。看下图，如果我们把[1,3]定义为就是在严格的1~3划线，那么此时跨越了，3个点，但是我们知道[1,3]其实只有2个单位的长度。所以跨越的点多了。并且基于这样的事实：我们把上面的三段线段整体向左平移一丢丢，其实整体的线段的重合数也是不变的。所以我们把[1,3]映射为在1的左边一点，划到3的左边一点，这样一来就包括了1而不包括3。此时某一个下标的位置例如1就代表着一段从1的左边一丢丢，向右延伸1单位长度的线段。这样一来[1,3]映射为add(1,2,1)，即在1代表的这段线和2代表的这段线对应的个数都加1。

<img src="image/image-20221113234530436.png" alt="image-20221113234530436" style="zoom: 50%;" />

上面这题用线段树解太重了，有一种更好的方法。不管哪个线段，都把每一个线段开始位置排个序，如果开头一样，谁前谁后无所谓。例如[4,6],[1,10],[2,5],[1,7]，排序完了之后就是[1,10],[1,7],[2,5],[4,6]。

准备一个小根堆。我们从[1,10]开始，每次拿出结尾的位置10。如果堆为空就直接进去。如果堆非空就看看小根堆的最小值是不是小于线段的开头1，如果**小于等于**1，那么小根堆就弹出最小值，直到堆顶是一个比1大的数，10就入堆。记录此时堆的大小。等到所有的线段都遍历结束之后，之前所有的状态中，堆的最大的size就是答案。

小根堆里面放的元素的含义：之前出现的线段还有哪些会对此时的线段产生影响的结尾都在小根堆里面。

- 代码：







---

对上面的线段重合问题继续扩展。给你一堆矩形，矩形可以用两点来表示，这两点是矩形的斜边，做直角的时候按照直角坐标系直上直下来画。也就是四个变量，最右边到哪里，最左边到哪里，最下面到哪里，最上面到哪里。要求出矩形最多重合的数量。

我们可以按照矩形的底来遍历，越靠下的矩形越先遍历。我们可以把矩形按照底排好序放在一个数组中。从底最小的矩形开始遍历。我们每遍历到一个矩形R，可能和这矩形R产生相交的矩形X的顶部一定是超过这个矩形R的顶部的。我们把这些顶比R的底低的矩形略去，只把R以及底小于R、顶高于R的底的矩形参与运算，把有关的矩形放到一个TreeSet中，按照左边界排序。此时把他们在x轴上跨度拿出来，转化成线段重合问题即可。

- 代码：















---

总结：

- 什么样的题可以用线段树解？区间范围上我要统一add或者update或者query，如果父范围的信息可以由左树和右树的信息直接加工得到，并且这样的信息是不需要调研具体的左树的状况和右树的状况的就可以用线段树做。也就是我们不需要跨越左孩子和右孩子来得到父亲的信息，父亲的信息可以直接由左右孩子的信息得到。

  例子：例如我要求一个范围上出现最多次数的一个数，假设现在左孩子1出现最多，10次；右孩子2出现最多，20次。但是可能左孩子中可能有3出现了9次，右孩子中3出现了19次，这样一来父亲出现最多次数最多的数应该是3才对。也就是说此时父节点的信息需要对左孩子和右孩子中具体的信息进行整合才能得到，也就是说需要具体了解左右孩子中每个数出现的状况。这种情况就不能使用线段树。



## 数组累加和问题三连

---

小插曲：假设要设计一个系统，这个系统的功能是让你提供不同的uuid。这个系统可能全球都在用，并且用的极其频繁，只需要你能够一直提供不重复的uuid即可。要求要从原理上杜绝相同，那么说明hash的方法是不行的，因为hash只是说以极小的概率会产生碰撞，但是原理上是可能的。由于调用的很频繁，所以你可能不是一台机器提供服务，而是多台机器提供服务。

这样行不行：每台机器上都有ip地址、mac地址、或者hostname。我拿ip去拼现在的纳秒时间。但是这样每台机器上的时间要强同步，并且每台机器的ip要不一样。

我们可以这样设计。类似于dns服务器的架构。全球有一个皇帝机器，可以无穷无尽的给出uuid的范围。按照一个树形结构扩展。孩子结点可以向父节点一次性要很多很多的uuid的范围，然后自己再去分配。

---

**数组累加和问题1**：给你一个数组arr，**里面都是正数**，再给你一个数sum。我想知道累加和正好等于sum的子数组最长是多长。

如下图，sum为6的最长子数组的长度就是6。

![image-20221113234545201](image/image-20221113234545201.png)

注：子数组、子串都是连续的。子序列是可以不连续的。

在滑动窗口的时候说过，累加和和范围是有单调性的，这个数组都是正数，累加和与范围是严格单调性。只要发现了单调性，就一定可以找到一个很优雅的解法。如果发现了单调性，要么是左右指针往中间跑。要么是一个窗口从左往右滑动。

这一题我们只需要一个窗口从左往右滑动就可以解题。只需要分三种情况，当窗口内的sum<目标sum的时候，R往右移动。当窗口内的sum>目标sum的时候L往右移动。当窗口内的sum==目标sum的时候，更新maxlen，L往右移动。（这里L和R谁先动都可以）

原理：当你窗口在左边界是x，并且右边界R能够扩到使得窗口内数组的累加和是sum，那么以这个左边界开头，有且仅有这个子数组可以使得sum为目标sum。所以这个时候可以更新maxlen。并且右移窗口的左边界。因为单调性，所以我们可以大胆的直接丢掉右边的那些没试过的位置。

- 代码



---

**数组累加和问题2**：给你一个数组arr，**里面有负、有正、有0**，再给你一个数sum。我想知道累加和正好等于sum的子数组最长是多长。

这一题单调性就没有了，数组范围增大累加和是可能变小的。 我们把结果数组分成几类，arr中每一个位置开头的数组算作是1类，这些所有类的最大值就是总的最大值。或者按照子数组的结尾来进行分类。在上面的解法中，我们就是用了每个位置开头的答案取最大值。

这一题我们按照子数组的结尾来分类。假设以i位置结尾，并且0~i的累加和是1000。我们假设目标target是200。如果0~m的累加和是800，并且m是最小的使得0~m累加和是200的下标。那么从m+1到i的累加和一定是800，并且是以i结尾最长的。

我们用一个map来位置每一个累加和最早出现的位置。并且最开始的时候要有（0.-1）这条记录，否则如果0~i正好是1000，那么你就要找和为1000-1000=0最早出现的位置。这样设置之后会找到-1，-1+1~i就是最长的长度。

- 代码





继续拓展：给你一个数组arr，**里面有负、有正、有0**，只有1和2的数量一样的多的子数组才是达标的，问所有达标子数组中长度最长是多少。

可以转化成数组累加和问题2。把所有非1和2的数全部变成0，把所有的2变成-1。然后变成在这样的一个处理后的数组中求累加和为0的最长子数组。





---

数组累加和问题3：给你一个数组arr，**里面有负、有正、有0**，以及一个数k，此时所有sum小于等于k的子数组都是达标的。问所有达标子数组中最长的长度是多少。

先定义一个概念：以i开头的的所有子数组，使得累加和最小的子数组的信息我要捕获到，信息有：累加和是多少，你是从i到哪的。

累加和记录在minsum[i]中

从i到哪记录在minsumend[i]中

如何填这些信息就是一个动态规划的过程。

```java
minsum[i]=minsum[i+1]<=0?arr[i]+minsum[i+1]:arr[i];
minsumend[i]=minsum[i+1]<=0?minsumend[i+1]:i;
```

得到了我们的预处理结构之后。我们把这套题按照每个位置开始分类。每一个位置我们都可以扩出一块区域，如果没超就继续扩，直到阔不动了就停。但是停了之后部门不从下一个位置从头扩，我们要充分利用前面一个位置扩出来的遗留信息。

如下图所示，也就是说右边界m不回退。

![image-20221113234556862](image/image-20221113234556862.png)



## 哈希函数有关的结构和岛问题

认识哈希函数 -> out f(in data)    输入一个in类型的变量data，输出一个out类型的结果。
1)输入参数data,假设是in类型，特征：可能性无穷大，比如str类型的参数
2)输出参数类型out,特征：可能性可以很大，但一定是有穷尽的
3)哈希函数没有任何随机的机制，固定的输入一定是固定的输出
4)输入无穷多但输出值有限，所以不同输入也可能输出相同（哈希碰撞）
5)再相似的不同输入，得到的输出值，会几乎均匀的分布在out域上
重点：第5条！

- hash没有一点的随机成分。hash函数的离散型和均匀性其实是一码事。

假设有一个40亿个无符号整数的文件，每一个整数4字节。假设只有1G内存。想要统计哪个数字出现的次数是最多的。我可以用这1G的内存做一张hash表出来。这个hash表中的key代表某一个数，value代表key出现的次数。假设把key和value都弄成无符号整数。拿这1G内存做hash表最多可以放几条记录？一条键值对记录8byte。40亿条整数如果每一个每一个都不一样，那么我们就需要有40亿条记录。此时我们需要320亿字节---》32G。也就是说我只有1G内存的话按照这种方法可能会内存溢出。也就是说当我的内存中存的记录数不超过1亿条的时候，内存不会爆。

思路：由于内存只有1G，我们可以把40亿个整数分成40份，这样一份只有大概1亿的整数，我们把1亿个整数放到内存里面是可以的。但是40亿个整数怎么个分法是很有讲究的。因为我们希望若干数值为x的数即使分布在40亿整数的不同位置，他们也能被分到一个文件里面。这一点哈希函数是可以做到的，因为数值相同的数经过相同的hash计算得到的值一定是相同的。那么我们把这40亿个整数一个一个的进行hash运算，算出来的结果%40，分到40个不同的文件。由hash函数的性质可知这40个文件里面的元素个数一定是差不多的。然后我们逐个把40个不同的文件分别求出其中出现次数最多的数，最后得到答案。



---

经典的hash表的实现。就准备17条记录。对于每一个输入求hash然后模17。这里的hash表记录的value其实是一个指针，把所有的映射到这个位置的数全部串起来。但是这样会有问题，当我的数越来越多的时候，链也会越来越长。并且我们知道这些链表的长度一定是均匀变长的。当某一条链的长度超过6了，那么大概率其它的链长度也超过6了。这个时候我们进行扩容。我们把hash表的记录数增加，然后重新计算原本hash表中元素的位置，重新放到新的hash表中。

计算hash -》O（1）、取模-》O（1）、到一条链中找 ，如果链长度都不超过6-》O（1）、扩容分摊之后也只是O（1）

---

### 布隆过滤器

1)利用哈希函数的性质
2)每一条数据提取特征
3)加入描黑库

布隆过滤器有啥用？类似于实现一个黑名单系统，并且是没有删除行为的。应用场景：爬虫、网络上禁止的资源。

最暴力的实现-》hash表，但是太浪费内存。而布隆过滤器可以极大地节约空间。

---

设计：有一个类似于位图的东西。位图就是位数组。可以直接拿int[]类型的数组去拼出位数组。但是如果位图要求很大，我们用int[]类型来表示就不够了。这个时候我们可以用一个二维数组来表示位图。

布隆过滤器先搞出一个m长度的位图，初始状态全0，全白的状态，如果有一个位变为1，就是一个描黑的状态。

对于一个url如果我们要加入到黑名单中，我们准备k个hash函数，算出k个hash值，模m把对应的位置涂黑。

对于另外一个url，只有k个hash值模m之后都是黑的，才判断它在黑名单里。

布隆过滤器是有失误率的，它可能会冤枉好人，但是它一定不会放过任何一个坏人。

现在出现的问题：位图选多大？选多少个哈希函数？你知道的只有样本量。通过样本量事先定义好m和k，因为不存在扩容的操作。并且和样本类型无关，因为我只需要hash函数把这个类型接收进去然后算出值即可。我还需要知道你预期的错杀率，我才能对应设计布隆过滤器。甚至如果你不允许错杀率，那么就不能使用布隆过滤器。所以我们需要知道样本量n以及失误率p。

---

布隆过滤器的三个重要公式。

m我们可以明显的想到：m越大肯定失误率越低

k如果很小，那么提取的特征就少，就容易失误。但是提取的特征太多了，m就不够你用了，失误率反而上来。

![image-20221114214907714](image/image-20221114214907714.png)

算出来这些值之后还有一个重要的问题

k个hash函数怎么找，还要求k个hash函数是独立的。

很简单，hash(x)=f(x)+k*g(x)

### 一致性哈希

- 解决数据分布式存储的一种方案

假设数据层有三台机器。对于每一个任务，我可以经过hash运算%3来判断在哪一台机器。但是这种方法在查询一个范围的数据的时候就很麻烦。物品需要在三台机器分别找出来，然后merge。

如果在业务上中低高频的key量都不少，那么经过hash函数的映射就可以实现几台数据存储服务器是负载均衡的。但是这样的设计在做服务器扩容的时候数据迁移代价很高，需要全量的迁移数据。这是无法接受的。这是传统的架构的问题。一致性哈希就是用来解决这个问题的，一致性hash可以做到负载均衡也可以做到迁移代价很低。

把hash函数的返回值范围想象成一个环。假设三台机器按照hostname进行区分，把这三个hostname分别进行hash运算，然后体现在环上。注意：不一定会均分这个环，但是现在我们先假设他们三个均分了这个环。然后假设现在我们要找一个key属于哪个机器，那么就把这个key进行hash运算，算出来的结构顺时针寻找，找到的第一个机器就是它归属的机器。

这样的话在一台机器下线的时候只需要把它管的数据给到他顺时针的下一个机器即可。机器上线的时候就把他所属的数据从它的顺时针的下一个机器上拿过来即可。

那么如何找？我们可以把机器的hostname算出来的hash值排序一下，做成一个路由表。上层在拿到key算出hash值之后，利用这个路由表决定去哪个存储服务器上，找到>=num最左

现在要解决几个问题。如果一开始的机器数量太少，算出来的几个hash值可能会离得很近。哪怕一开始均分，突然下线一个机器，马上就不均分了。

一致性hash最关键的技术：虚拟结点技术。之前我们假设是直接拿机器的hostname去抢环，现在我们给三个机器分别分配1000个字符串。用这些分配的字符串去抢环。当一个key到来的时候，算出它的hash值，看看顺时针先找到哪一个字符串，这个字符串属于谁，这个key就存到哪台机器。

那么如果机器的性能不一样，给性能好的机器多分配几个结点就等价于分配了权重了。

---

知道每一个商家的经纬度，如何知道任意给定的一个位置周围1km、2km有多少商家。我们可以把整个地图划分为很多的小格子，是一个二维平面。我们可以把商家具体存在哪个格子的信息记录下来。当我们得到一个任意的位置的时候我们可以通过经纬度算出它属于哪一个格子，然后我们可以顺着这个格子的位置扩充出更多的格子。我们只需要把这些格子的商家的信息拿出来，然后一个一个计算看看是否符合预期。

### 并行算法

- 岛问题：一个只有0和1两种数字的二维矩阵中，上下左右能连成一片的1，算一个岛返回矩阵中，一共有几个岛

- 下图：2个岛

  <img src="image/image-20221115130532734.png" alt="image-20221115130532734" style="zoom:33%;" />

- 代码： 有感染行为   O(N)





没有比上面复杂度更好的方法，因为至少要把矩阵看过一遍。

用并查集来做。可以把一个图拆分成很多小区域分别交给cpu去跑。cpu只需要记录边界的信息即可，最后全部拿到一起用并查集合并。



## 如何解决资源限制类题目

- 技巧：

  1)布隆过滤器用于集合的建立与查询，并可以节省大量空间（已讲）
  2)一致性哈希解决数据服务器的负载管理问题（已讲）
  3)利用并查集结构做岛问题的并行计算（已讲）》
  4)哈希函数可以把数据按照种类均匀分流
  5)位图解决某一范围上数字的出现情况，并可以节省大量空间
  6)利用分段统计思想、并进一步节省大量空间
  7)利用堆、外排序来做多个处理单元的结果合并

---

题目1：

- 32位无符号整数的范围是0-4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，可以使用最多1GB的内存，怎么找到出现次数最多的数？

用hash做离散分到40个文件



---

题目2：

- 32位无符号整数的范围是0-4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，所有在整个范围中必然存在没出现过的数。可以使用最多1GB的内存，怎么找到所有未出现过的数？
  【进阶】
  内存限制为10MB,但是只用找到一个没出现过的数即可

  内存限制为10KB,但是只用找到一个没出现过的数即可

  内存限制为3个变量,但是只用找到一个没出现过的数即可



用位图可以比map省下32倍的空间，用一个比特位表示一个数出没出现过。

如果只有10MB呢？假设现在只有3KB。可以做出750长度的int类型数组并且不会爆。接着找离750最近的2的某次方--》2^9=512。所以我们知道我们把数组长度定位512的时候，内存不会爆。所以我们可以把int类型的取值范围的2^32均分为512份。也就是一份有2^23这么大的范围，。然后我们遍历这40亿个整数，遍历到每一个整数我们算出它属于哪份，对应的那份就++。我们知道，就算40亿个整数都不相等，也无法把把int类型的所有取值都取过一遍。也就是说我们均分的这么多份中，一定有不足2^23的。那么我们也就知道了在这个范围上必定缺数字。然后继续在这个范围上再分出512份，以此类推，直到有一次，这个范围已经可以全部放入512大小的数组中。



如果只有三个变量？三个变量，l，r，mid（mid不参与变量，直接通过l和r算）。从头遍历一遍文件，考虑在l~mid范围上满还是不满，用第三个变量count来统计。一直二分。



---

题目3：

- 有一个包含100亿个URL的大文件，假设每个URL占用64B,请找出其中所有重复的URL
  【补充】
  某搜索公司一天的用户搜索词汇是海量的（百亿数据量），
  请设计一种求出每天热门Top100词汇的可行办法

哈希分类到不同的机器上，在机器上继续哈希到不同的文件中，然后在单独的每个文件中统计url出现的次数。

top100如何知道？在每个小文件中找出top100，然后总的合起来找到一个top100。方法就是每次都取小文件的top的top。利用二维堆可以比这个方法快。二维堆就是把每个单独的堆的顶部再组成一个堆。





---

题目4：

- 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。

也是用位图，不过这次用两个比特来表示一个数出现了几次。



---

题目5：

- 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数可以使用最多10MB的内存，怎么找到这40亿个整数的中位数？

中位数指的是如果排完序之后的中位数

和题目3一样的思路，先按照你给我空间大小把42亿的范围给分了。然后统计在每个范围上数出现的次数。统计完成之后一顿累计，找到哪个范围加上之后超过了21亿。假设加之前是19亿，加上之后是25亿。那么我们就可以推断出我们要找的数是这个范围的第2亿小。

---

题目6：

- 32位无符号整数的范围是0-4294967295，有一个10G大小的文件，每一行都装着这种类型的数字，整个文件是无序的，给你5G的内存空间，请你输出一个10大小的文件，就是原文件所有数字排序的结果。

按照给定的空间我计算出合适大小的map和一个小根堆，假设小根堆可以放100个数。map存每一个数字在堆里面的下标，堆里面的结点包括数字以及出现的频次。过完一遍文件只有小根堆就把top100的数搞定了。然后再去一遍一遍的遍历。

## 有序表的原理、应用、扩展

- 搜索二叉树：搜索二叉树一定要说明以什么标准来排序经典的搜索二叉树，树上没有重复的用来排序的key值。如果有重复节点的需求，可以在一个节点内部增加数据项用来表述重复出现了几次。

- 经典的搜索二叉树为什么值是不重复的？因为如果要考虑平衡性的话，有左旋右旋操作，平衡性是保持不住的。

---

- 搜索二叉树查询key（查询某个key存在还是不存在)
  l)如果当前节点的value==key,返回true
  2)如果当前节点的value<key,当前节点向左移动
  3)如果当前节点的value>key,当前节点向右移动
  4)如果当前节点变成null,返回false

- 性能取决于输入状况

- 这个时候我们引入平衡机制，有左旋和右旋的概念。左旋右旋的概念是针对头节点来说的。Right(Node x)意思就是x结点要往自己的右侧方向倒下去。

Java中TreeMap的底层是平衡搜索二叉树。和hashMap的区别是，hashMap的增删改查都是O（1）的时间复杂度，TreeMap的增删改查时间都是O(logN)

---

有序表是一种接口名，是一种规范：

1. key按序组织
2. 增删改查O(logN)

AVL树、SB树、红黑树都可以完成有序表的接口功能。

AVL树拥有最严格的平衡性，任何结点的左右数的高度差小于2。

SB树，任何叔结点所拥有的的节点数不少于它的任何一个侄子结点。

如下图，b结点的侄子结点是f和g。b的节点数有3个，不小于f和g的，所以达标。

<img src="image/image-20221117210126334.png" alt="image-20221117210126334" style="zoom:50%;" />

两边的差距最多的为n:2n+1。差距不是特别悬殊的时候时间复杂度就是logn

<img src="image/image-20221117211548212.png" alt="image-20221117211548212" style="zoom:50%;" />

- 红黑树：

  1. 每一个结点不是红就是黑
  2. 头节点是黑、叶节点是黑
  3. 红结点的子一定是黑结点
  4. 从任何结点到它的每一个子，所有路径上黑结点的数量一样多。

  

红结点的子一定是黑说明两个红结点不能相邻。最长的链是黑红交替的。最短的链全黑。因为最长的链和最短的链黑结点一样多，并且长链是黑红交替，说明长链短链相差的长度一定不会超过两倍。

无论是AVL树、SB树、红黑树，都设计了属于自己的调整策略。但是底层是会使用左旋和右旋这两个基本动作。在插入、删除、查找的时候都和二叉搜索树无二。只是在删完了或者插完了之后会有额外的动作来进行平衡。

AVL树是往上去调整整条链，看看有没有结点的平衡性被破坏。只查受这条链上的结点有没有收到影响。

**<img src="image/image-20221117213224502.png" alt="image-20221117213224502" style="zoom:50%;" />**

如果是删除一个结点，并且这个结点是有左右孩子的。例如下图画插的是要删除的结点。白色箭头是它的后继结点顶上它的位置。要检查的链应该是后继结点原来的位置往上检查，而不是后继节点来到的位置开始检查。如何理解？可以看成就是删除了这个后继结点，所以要从那里开始查，因为那里少结点了嘛！

<img src="image/image-20221117213632553.png" alt="image-20221117213632553" style="zoom:50%;" />

---

AVL树、SB树、红黑树，都是一样的，都是往上走同一条链来看看要不要调整平衡。只是发现不平衡时候的调整动作有差异。



### AVL Tree

怎么去查那一条链上的平衡性？只有左右旋两个动作。有四种违规情况，LL、LR、RL、RR。四种违规情况只会中一个，因为每次增删结点我们都查。

一个结点的左右树的高度差如果超过1，那么就是违规了。

![image-20221117214747496](image/image-20221117214747496.png)

第一个字母是L之后就往a的左树走，也就是从a往左边走到b，然后看看是b的左边还是右边导致不平衡的。

![image-20221117215114759](image/image-20221117215114759.png)

在左右子树都比较大的时候如何确定是LL还是RR呢？看下图，如果是插入导致违规，E子树和F子树一定只有一个是6高度。因为现在是添加了一个结点违规了，如果两个都是6的话说明之前就违规了，矛盾！那么E子树和F子树谁的高度是6谁就违规！

如果是删除导致违规，那么E和F可能都为6高度。

<img src="image/image-20221117215619326.png" alt="image-20221117215619326" style="zoom:67%;" />

现在假设我们知道了一个结点是LL或者是LR违规。如何调整？

圆圈是结点，方块是子树。

如果是LL型，直接对x结点做一个右旋。

![image-20221117220721594](image/image-20221117220721594.png)

如果是LR型，让x的孙结点z上到顶部。目标是要让z上到顶部，根据下图，可以先让y左旋，再让x右旋。因为y左旋之后情况就变成LL型了。

![image-20221117221615950](image/image-20221117221615950.png)

左旋右旋调整的代价是O（1），四种违规情况最多中一个，最多调整两次。沿着一条logn长度的链往上检查。所以总的调整平衡性的时间复杂度是O(1)。



- 总结：

  LL、LR、RR、RL。LL和、LR一组；RR和RL一组。不可能同时遇到两组，因为要么左孩子高要么右孩子高。

  假设我们中了LL、LR这组。假设x.l.l的高度和x.l.r的高度不一样，那么如果x.l.l高，就对x做一次右旋。如果x.l.r高，那么就做两次旋转。如果x.l.l的高度和x.l.r的高度一样，那么就对x做一次右旋，也就是只能当成LL型进行处理，不能当做LR型进行处理。

  如何简单理解？如果出现x.l.l的高度和x.l.r的高度一样，**说明x的左树的高度违规是因为右树删了结点导致的**。右侧少了结点那么我们就把x右旋下去，十分合理！！

### Size Balance Tree

如果一个结点的左孩子的节点数不如他右孩子的左孩子的个数多，就是RL。

如果一个结点的左孩子的节点数不如他右孩子的右孩子的个数多，就是RR。

如果一个结点的右孩子的节点数不如他左孩子的右孩子的个数多，就是LR。

如果一个结点的右孩子的节点数不如他左孩子的左孩子的个数多，就是LL。

m（x）用来检查x的左右孩子违规与否。发现LL型违规之后，x进行一次右旋，然后m（x），x（b），只要是换过左右孩子的结点都需要重复调用m函数检查是否违规。

![image-20221118135901836](image/image-20221118135901836.png)

RL型也是先进行两次旋转，把孙子转到顶部。然后发现有三个结点的子发生了变化，继续调用m函数。上游结点的递归最后去做。

![image-20221118141150477](image/image-20221118141150477.png)

- 为什么size balance tree比AVL快？因为size balance tree的平衡性模糊，avl树的扰动大。

- 高手在一个结点删除的时候不做平衡性调整，这样做的确有可能会越删越不平衡，一律把平衡的实际放在add的时候。在某一次add的时候由于有递归行为，所以可以把之前由于删掉的不平衡的结点全部调整成平衡的。



### Skip List

跳表可以用用来实现有序表，性能也是logn水平。但是它的实现和搜索二叉树没关系。

跳表是由Node串成的，Node内部有一个List<Node>也就是有多条往外指的指针。跳表开始的第一个结点的key是null，标记为整个系统的最小值。跳表最左侧的结点认为是弃而不用的。一开始结点只有一条往外指的指针。

加入结点的时候先建出一个新节点，并且默认有一条指针。然后随机的决定要额外生成多少条指针。调用01随机生成器，是0就增加一条指针，是1就停。然后一开始的那个弃而不用的结点如果发现有一个新的结点的层数比自己的层数高，一定要保证自己的层数和新出来的那个最高层数一样。

- 加入结点的时候，从第一个结点的最高层开始看看能不能往右跳，往右跳的条件是往右跳到的那个结点要小于等于自己。如果不能再往右跳了就往下走一层，然后继续往右跳。如果发现右边没有结点，就还是在当前这个结点，继续往下跳，重复上面的过程。
- 查询的时候同理。

<img src="image/image-20221118154153631.png" alt="image-20221118154153631" style="zoom:67%;" />



可以发现第1层，也就是最底下的一层串了所有的结点。越高层跨度越大。由于是摇色子决定拥有的层数，所以第一层1/

2，第二层1/4，第三层1/8。。。跳表其实是从高层到底层建立了索引关系。为什么可以保证是logn？因为完全凭运气来决定自己占了几层。

### 红黑树

1. 一个结点非红即黑
2. 头节点是黑、叶子结点也是黑
3. 红结点的黑子结点不能是红
4. 从任何一个结点出发，到它能到达的叶子结点的所有路径中，黑结点的数量一样多。

增删改查都和搜索二叉树一样。区别就是增完删完在之后要从受影响的结点开始一条链上去都做有效性的检查。但是红黑树的平衡性太容易被破坏了！破坏红黑树的平衡性的情况非常的多！插入的情况下，违规五种可能。删除的情况下违规的可能性8种。总共13情况。

为什么红黑树这么麻烦但是还这么著名呢？因为它的平衡性很模糊，对增删没有这么敏感。我每次都检查是否违规，但是我并不是很经常去调整。也就是说当你在磁盘上实现了一种数据结构，对于增删很敏感，那么就最好不用像AVL树这样对增删敏感的数据结构，就应该使用sb树或者红黑树。更进一步说，如果你对磁盘的IO真的很敏感，敏感到你愿意牺牲一些查询的常数项的时间，那么我们就应该使用调整次数更少的B树和B+树，这是多叉树。

redis为什么选择跳表来作为底层的数据结构？因为跳表这样的结构是一层一层的线性结构，比较好进行序列化。

### 题目

题目1：

给你一些数组，长度不一，每个数组里面是有序的。整体是一个二维数组，但是每一行有序。想找到一个**最窄**[a,b]，是一个闭区间，使得上面的所有数组都至少有一个数命中在这个区间里。最窄区间可能有多个，我想要开始序号最小的那个区间。

流程：第一回，把所有数组的第一个元素（最小的），放到有序表中，然后得到一个区间，这个区间就是有序表中的最小值和有序表中的最大值，用一个变量记录此时的区间。接着 从有序表中弹出最小的，弹出来的数来自于哪个数组，就从哪个数组再取一个扔到有序表中，再次生成一个新的区间，和原本记录下来的那个区间比较，如果更窄才更新，大于或等于都不更新。

原理：我们本质是在寻求，如果以某一个数字为区间的开头，这个区间最窄是多少。

这道题完全不需要自己去改写有序表，我们只需要拿系统的来用即可。

---

题目2：

- 给定一个数组arr,和两个整数a和b（a<=b)
  求arr中有多少个子数组，累加和在[a,b]这个范围上
  返回达标的子数组数量

假设我们知道0~i的累加和是100，我们要求p~i的累加和落到[10,30]的范围，那么0~p-1的累加和就落在[70.90]。

反过来，假设0~i的累加和是100，如果我们知道0~j累加和范围落在[70~90]范围上，那么必然存在j+1~i累加和落在[10.30]范围上。

所以，要求以i结尾的子数组中有多少累加和落到[10,30]的范围，本质上就是求0~0,0~1,0~2,....,0~i-1这些数组中有多少个累加和范围落在[70,90]范围上。

如果我们把有前缀和数组sum，sum[i]代表从0~i范围的累加和。把上面的100换成sum[i]，假设目标范围是[a,b]，那么以i结尾的这部分答案就是sum[0...i-1]有多少个值落在[sum[i]-b,sum[b]-a]。

我们发现，我们要找到sum[0...i-1]中有多少个值落在[sum[i]-b,sum[b]-a]中，可以一个一个遍历sum数组，但是这样需要O(i)的时间复杂度，如果i从0~n都要加起来，那么就是O(n²）的时间复杂度。太慢了！

如果我们能够在二叉搜索树中允许重复值，并且有一个字段all可以记录每个结点接收了多少数字的话，要求多少个值落在[sum[i]-b,sum[b]-a]其实就是log(N)的时间。注意，你所增加的all字段在调平衡的时候也需要注意交换，把all信息维持对。



---

题目3：

- 有一个滑动窗口（讲过的）
  1)L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧
  2)任何一步都可能R往右动，表示某个数进了窗口
  3)任何一步都可能L往右动，表示某个数出了窗口
  想知道每一个窗口状态的中位数（严格中位数，如果是偶数个，需要返回（上中位数+下中位数） /2）

这题本质上就是要求：你的结构允许增加、删除、并且查询第k小的数是什么。

还是需要一棵维持了all字段的允许重复值出现的搜索树。要查第k小，只需要一个递归即可。

## AC自动机、卡特兰数

AC自动机解决：在一个大文章中，我有多个候选串，我想知道这个文章中命中了哪些候选串。

先把这么多个候选串全部都加到前缀树上。但是前缀树的结点多了一个字段，叫做fail指针。头节点的fail指针认为规定指向空。第一级孩子的fail指针认为规定指向头。

fail指针的设置时机是当你把所有的候选串都加好了之后，再通过宽度优先遍历的方式设置fail指针。

1. 初始情况，head.fail=null。

2. 当来到一个结点x，如果x.fail==null，那么直接把x结点的孩子的fail指针指向头

3. x.fail != null。如果x的某个孩子X是b，如果x.fail 也有某个孩子Y是b，那么x的这个孩子X的fail就指向Y。

   如果x的某个孩子X是b，但是x.fail 没有某个孩子Y是b。那么就继续到x.fail.fail继续去找看看有没有某个孩子是b。依次类推，如果走到null都没有找到，那么就指向头。

   

fail字段的本质是什么？我们知道前缀树的一个结点代表一个前缀字符串X，以及一个结尾字符x。fail字段代表的是，如果必须以字符x结尾，哪一个另外的前缀串和我以e结尾的后缀串相等并长度最大。

上面那个流程本质上就是动态规划。子节点如何设置fail指针？通过父节点的fail指针来设置。

fail指针多次跳转的含义就是最大可能性不行就去找次大可能性

有什么用？fail指针跳转就意味着从某一个位置开始要找到匹配串失败了！fail的跳转可以让我们节省从下一个位置开始的匹配次数。

- 过程是一个层序的贪心

![image-20221118203746607](image/image-20221118203746607.png)

如何收集答案？每到一个结点顺着fail指针去收集一圈黑，顺便把黑（黑的含义就是有一个字符串以当前这个结点代表的字符结

尾）的改白。

如果在匹配的时候连续时候，一直到开头的时候，说明a、b、c三个位置都失败，从t开始重新匹配。

![image-20221118204619215](image/image-20221118204619215.png)





# 算法思想题目

## 分治法

### 求n点距离最近的两点

问题1：给出平面上n个点(X1,y1) , (x2,y2) ... (Xn,yn),求这n个点中距离最近的两个点和其距离

<img src="image/image-20230222191549744.png" alt="image-20230222191549744" style="zoom:50%;" />

<img src="image/image-20230222191600510.png" alt="image-20230222191600510" style="zoom:50%;" />

<img src="image/image-20230222191613264.png" alt="image-20230222191613264" style="zoom:50%;" />

<img src="image/image-20230222191624207.png" alt="image-20230222191624207" style="zoom:50%;" />

---

题目2：



## 动态规划

### 单源最短路径

题目1：单源最短路径问题

<img src="image/image-20230222193719644.png" alt="image-20230222193719644" style="zoom:50%;" />



---



题目2：资源分配问题

思想：F(x,y)=max{G(x,i)+F(x-1,y-i)}。G(x,i)代表给第x项工程投资i元的利润，F(x,y)表示只给0~x的工程投资y元的最大利润

<img src="image/image-20230222210859422.png" alt="image-20230222210859422" style="zoom:50%;" />

<img src="image/image-20230222210938738.png" alt="image-20230222210938738" style="zoom:50%;" />



# 经典面试题目

## Interview Coding 01

### 绳子盖点

题目1：

- 给定一个有序数组arr,从左到右依次表示X轴上从左往右点的位置
  **给定一个正整数K,返回如果有一根长度为K的绳子，最多能盖住几个点**
  绳子的边缘点碰到X轴上的点，也算盖住

思路1：

- 首先我们要考虑绳子放在哪？如下图，我们可以把绳子的开头放在1位置，也可以把绳子放在1.5位置。但是很明显，我们绳子的开头一定要放在arr数组中的点，例如1,3,7,10,13，才会使得压中的结点数最多。

- 定下了绳子的开头之后我们可以把问题拆分为，绳子开头在1时候的最大压中数量、绳子开头在3时候的最大压中数量、绳子开头在7时候的最大压中数量。。。。按照绳子的开头来进行求解答案，所有答案的最大值一定是全体的最大值。
- 有无单调性？有！如果在某一个位置的绳子已经无法盖住前面的点了，一定也无法盖住后面的点。所以我们可以利用滑动窗口来求解。每当arr[R]大于arr[L]+k的时候就更新一次全局的max，此时绳子以arr[L]开头，最大覆盖的点的个数就是R-L+1。

![image-20221119103210529](image/image-20221119103210529.png)

思路2：

- 和思路1一样，我们也把问题拆分为绳子以1,3,7,9开头分别求出最大然后求整体的最大。
- 不同的是，我们不使用滑动窗口来解。我们通过绳子的开头7以及绳子的长度3可以算出绳子的末尾10。我们只需要在arr数组的下标2~arr.len-1 部分求<=10最右的位置即可。
- 在一个数组的a~b部分求<=某个数最右的位置可以用二分法搞定！这样时间复杂度是nlogn

![image-20221119103744099](image/image-20221119103744099.png)





---

### 括号有效配对

题目2：

- 括号有效配对是指：
  1)任何一个左括号都能找到和其正确配对的右括号
  2)任何一个右括号都能找到和其正确配对的左括号
  有效的：(())  ()()  (()())  等
  无效的：(()  )(  等
  
  **问题一：怎么判断一个括号字符串有效？**
  **问题二：如果一个括号字符串无效，返回至少填几个字符能让其整体有效**

问题一思路：

- 只需要一个变量就能判断，不需要用栈，也不需要左右指针。
- 假设这个字符串只有左括号和右括号。只需要准备一个整型变量count，从左到右遍历这个字符串，遇到左括号就++，遇到右括号就--。如果在遍历的过程中count<0了，直接返回false。如果遍历结束之后count的值不等于0也返回false。否则就返回true。
- 为什么可以这样？如果count在任意时刻都不小于0，说明在任意一个位置，右括号的数量都不比左括号的数量多。并且如果最后count等于0了，就说明所有的左括号都可以找到一个右括号配对。

问题二思路：

- 和思路1一样，准备一个count变量，还有一个额外的need变量。从左往右遍历字符串，遇到左括号就++，遇到右括号就--，如果中途count== -1 ，就让need++，让count重新归为0，然后继续遍历。如果最后count>0，那么返回结果就是need+count。
- 原理：如果中途有count== -1 的情况，说明我需要在前面的某个位置补充一个左括号。如果最后count>0,说明我需要在后面的某个位置补充count个右括号。



---



题目3：

- 括号有效配对是指：
  1)任何一个左括号都能找到和其正确配对的右括号
  2)任何一个右括号都能找到和其正确配对的左括号
  **返回一个括号字符串中，最长的括号有效子串的长度**
- 有可能给你一个无效的字符串，但是它的一部分子串是有效的，要返回最长的有效子串的长度。( **( ) ( )** ( **( ( ) )** 的最长有效子串是4

- 思路：这是一道动态规划。首先看到子串、子数组的问题。一个很自然的拆分思路就是枚举每一个位置开头或者结尾的答案，答案一定在其中。这样拆分，我们就可以把之前求过的位置都记在一个数组中，看看能不能帮助我现在这个位置求出答案。动态规划就是类似的思路，你在求0~i的答案的时候看看能不能用0~i-1的答案来帮助你。

  假设dp[i]代表0~i范围上，以i位置结尾的最长有效子串的长度。现在要求0~i范围的答案，**如果第i个位置是左括号，那么这个位置的答案就是0**，因为以左括号结尾一定是非法的。

  那么**如果i位置是右括号**？由于已经知道了dp[i-1]，那么我们就从i-1位置倒推dp[i-1]长度到达另外一个位置p，位置p是不在范围dp[i-1]的有效范围里面的。**如果`str[(i-1)-dp[i-1]]`是右括号，那么dp[i]等于0**

  现在有个难点，为什么p位置不是左括号dp[i]就一定是0？要理解“最长”，如果p位置是右括号的话，那么p之前就不可能出现如下图的一个方块外加一个左括号的结构，因为如果出现了这样的结构，那么dp[i-1]就求错了！矛盾。

  4里面的块也不可能有一小块和i位置的右括号匹配的，因为只有4里面的左括号才能和这个右括号匹配，但是4里面的左括号早就被4块中自己的右括号匹配光了！

  综上，只有p位置是左括号才能和i位置的右括号配对，其它情况都不可能匹配。

<img src="image/image-20221124200041645.png" alt="image-20221124200041645" style="zoom:33%;" />

- 所以，如果i位置是左括号，dp[i]=0。如果i位置是右括号，并且p位置是右括号，dp[i]=0。
- 但是如果i位置是右括号，并且p位置是左括号，那么dp[i]至少等于dp[i-1]+2。它可能会更长！！我们继续看p-1位置然后加上dp[p-1]。



还有一个题，在代码中为deep方法

问的就是有效子串中最深的嵌套层数。很简单，还是只要一个count，遇到左括号++，遇到右括号--，count到达的最大值就是最大嵌套层数。前提是count到达这个最大值后还能够到达0.



---

### 正方形涂色

题目4：

- 有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色，这个正方形的颜色将会被覆盖。目标是在完成染色之后，每个红色R都比每个绿色G距离最左侧
  近。返回最少需要涂染几个正方形。
  如样例所示：s=RGRGR我们涂染之后变成RRRGG满足要求了，涂染的个数为2，
  没有比这个更好的涂染方案。

题意：

- 意思就是要把RGRRGRR这样的正方形排列，经过涂色变成左边都是R，右边都是G。左边几个R右边几个G不关系，我要求的是涂色的次数最少可以变成这样的效果。例如RRRRGGG/RRRRRRR/RRGGGGG都是合法的。但是要的是涂色次数最少的涂法。

思路：

- 这题可以枚举分界线。定下分界线，左边的G的个数加上右边的R的个数就是这个分界线的答案。
- 技巧：利用预处理数组来快速得到G和R的数量。gcount[i]代表从0~i范围上有几个G。rcount[i]代表从i~len-1范围上有几个R。但是其实我们只要知道gcount和rcount中的一个即可。另外一部分可以在遍历的过程中用一个变量抓住。
- 其实一个变量也可以实现count数组的作用。例如我要知道i~len-1的R的数量，那么我们先遍历一遍得到R的总数totol，当我来到一个位置如果这个位置是R那么totol就--，这样totol的含义就变成了右侧还有几个R。





---

### 矩阵中最大正方形

题目5：

- 给定一个N*N的矩阵matiⅸ，只有0和1两种值，返回边框全是1的最大正方形的边长长度。
  例如：
  01111
  01001
  01001
  01111
  01011
  其中边框全是1的最大正方形的大小为4*4，所以返回4。



 可以直接计算得到数量的阶数。长方形的数量有更简单直观的估计方式，就是在矩阵中任意找两个点。正方形的估计就是任意找一个点，然后往两边扩。

![image-20221125110413765](image/image-20221125110413765.png)

因为正方形的总数为O(N³)，所以算法的时间复杂度肯定也是O(N³)，因为你至少要把所有的正方形看过一遍才能知道答案

所以我们至少需要三个循环嵌套，前两个循环定一个点，第三个循环延长边。我们能优化的地方在于如果验证某个正方形是不是边框都是1。

所以我们使用额外的结构来加速我们验证正方形合法性的过程。r[i] [j] 代表在(i,j)这个点右边（连同自己在内）有多少个连续的1。d[i] [j] 代表在(i,j)这个点下面有多少个连续的1。很明显，我们只需要O（N²）的时间就可以得到这两个辅助结构。



---

笔试：

- C、C++ 10^8~10^9 常数级别的操作 1~2s内能过。java、python3~4s内能过。
- 如果数据量是10^6，那么如果你的算法是O(N²)，那么肯定过不了，因为你的常数级别操作就到了10^12的量级，超过了10^8~10^9。

---

### 构造数组

题目6：

- 给定一个正整数M,请构造出一个长度为M的数组arr,要求
  对任意的i、j、k三个位置，如果i<j<k,都有arr[i]+arr[k]!=2*arr[j]
  返回构造出的arrr

- 思路：分治。假设现在你有一个达标数组X，根据X数组，对X数组进行两次变化。分别是奇变换和偶变换，分别变换出A数组和B数组。A数组里面都是通过2x+1变换出来的奇数。B数组里面都是通过2x变换出来的偶数。A和B拼凑成一个新的数组AB，AB数组左半边和右半边分别达标。跨越A和B的边界也是达标的，因为A和B分别选一个相加为奇数，而AB数组中的任何一个数*2都是偶数，偶数一定不等于奇数。
- 空间复杂度不使用递归的话可以优化到O(1)。但是时间复杂度一定是最优了！
- 思考：想想看给你一个合格的，你怎么把它通过加工拼成一个更大的合格的。如果可以做到那么就可以分治了



---

### 二叉树路径

题目7：

- 给定一个二叉树的头节点head,路径的规定有以下三种不同的规定：
  1)路径必须是头节点出发，到叶节点为止，返回最大路径和
  2)路径可以从任何节点出发，但必须往下走到达任何节点，返回最大路径和
  3)路径可以从任何节点出发，到任何节点，返回最大路径和。（可以往上走）



思路

1. 第一种规定。可以不使用递归套路，如果使用递归套路的话需要注意，不能把null定为base case，要把叶子结点定位base case。

2. 第二种规定。 需要使用二叉树的递归套路。需要划分可能性：答案和头有关、答案和头无关。

   和头无关的时候会出现答案，例如头是负数的时候。此时我们需要左树的最大路径和以及右树的最大路径和（**不一定从头出发**）。

   和头有关的时候，有三种情况。a. 不往左走也不往右走，只有自己。b. 往左走。c.往右走。但是此时左右子树要给的信息是左右子树的最大路径和（**从头出发**，要和上面的情况区分开）。

   所以我们需要两种信息。第一个信息是和头无关的情况需要的，第二个信息是和头有关的时候需要的。分别是整棵树的最大路径和、从头结点出发的最大路径和。注意：**由于规定只能往下走，所以左右两边只能走一边**

3. 第三种规定。和第二种的区别就是路径可以往上走，但是沿途结点只能经过一次。

   依然是列可能性。第一种大情况是和头结点无关的时候，那么就往左右孩子要他们各自的最大路径。

   和头节点有关的时候。 a. 不往左走也不往右走，只有自己。b. 往左走。c.往右走。d. 既往左又往右。

4. 第四种规定：从任何结点出发但是一定要到叶子结点的最大路径和。


## Interview Coding 02

### 二维数组中寻数

题目1：

- 在行也有序、列也有序的二维数组中，找num,找到返回true,否则false



思路：

- 从左下角或者右上角开始走。如果从右上角开始走，那么只可能往左或者往下。
- 不能从左上角开始走，因为可能有两个方向，不好走。



---

### 打包机器

题目2：

- 有个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打包机上
  放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人将每个机器上的
  物品进行移动从而到达物品数量相等才能打包。每个物品重量太大、每次只能搬一个物品进
  行移动，为了省力，只在相邻的机器上移动。请计算在搬动最小轮数的前提下，使每个机器
  上的物品数量相等。如果不能使每个机器上的物品相同，返回-1。

  每一轮指的是每一台机器都可以选择往左或者往右扔包裹或者不扔包裹。

  例如[1,0,5]表示有3个机器，

  每个机器上分别有1、0、5个物品，[1,0,5]，经过这些轮后：
  第一轮：[1,1,4]；第三台机器往左扔包裹，其它机器不动。

  第二轮：[2,1,3]；第三台和第二台机器都往左扔包裹。

  第三轮：[2,2,2];  第三台机器往左扔包裹。
  移动了3轮，每个机器上的物品相等，所以返回3
  例如[2,2,3]表示有3个机器，每个机器上分别有2、2、3个物品，这些物品不管怎么移动，都
  不能使三个机器上物品数量相等，返回-1

思路：贪心算法（难证明，不需要证明）

- 首先我们可以知道任何一个i位置需要多少件衣服，总衣服数/机器个数。并且我们需要用到每个i位置的前缀和。

- 对于任意一个i位置，我们可以求出它的左边的盈余left，如果盈余>0说明左边的衣服多了，如果盈余<0说明左边的衣服少了。右边的盈余right也同理。

  分情况讨论：

  a. 如果left>0,right>0，那么说明左右两边衣服都多了，需要向i位置扔衣服。左右两边可以同时往i位置扔衣服，所以此时需要max(left,right)。

  b. 如果left<0,right>0 , 说明此时左边缺衣服，左边缺的衣服一定是从i来的，所以至少需要|left|次，left次完了之后right如果不等于0还需要继续往i送。所以此时需要的轮数为max(|left|,|right|)。

  c.  如果left>0,right<0，和b情况类似，需要的轮数为max(|left|,|right|)。

  d. 两边的衣服都不够，需要i往左右两边送。因为一次只能送一件，所以此时的轮数为|left|+|right|。

  

- 贪心思路：我们从左到右遍历机器数组的每一个位置，依次求出所需要的轮数。所有的轮数中最大的就是答案，因为它是整个系统的瓶颈。

- 由于是从左到右的遍历流程，所以前缀和数组我们都可以不用求出来，直接在遍历的过程中求即可。空间复杂度只需O(1)

- 上面的a、b、c三种情况都可以用max(|left|,|right|)来表示



---

### 左右最大值相减的最值

题目3：

- 给定一个数组arr长度为N,你可以把任意长度大于0且小于N的前缀作为左部分，剩下的作为右部分。
  但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的，左部分最大值减去右部分最大值的绝对值。



思路：

- 本人第一眼看到的想法是准备两个大根堆。
- 实际上不需要这么麻烦，左部分最大值和右部分最大值肯定有一个就是全局的最大值。如果最大值在左边，那么问题就变成怎么让右边的最大值尽可能小。要让一个数组的某个范围内的最大值尽可能小最好的方法就是让这个范围缩小！因为右边部分必须包含len-1位置，那么我就让右部分只有arr[len-1]这个元素。同理，如果最大值在右边，那么就让左边只有0位置的数。两种情况求最大值。
- 单调性：一个部分的范围变大，最大值只可能变大或者保持不变，如果这个部分还已经包含了全局的最大值，那么范围变大最大值只会保持不变。在这部分不变的情况下，要让左部分最大值减去右部分最大值的绝对值达到最大，只需要让没有全局最大值的那个部分的范围最小即可 ----》arr[0] 或者 arr[len-1]



---

### 容器储水

题目4：

- 给定一个数组arr,已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水

  容器两边的趋势认为是无限低的

  比如，r={3,1,2,5,2,4}根据值画出的直方图就是容器形状，该容器可以装下5格水
  
  再比如，arr={4,5,1,3,2},该容器可以装下2格水

<img src="image/image-20230101151432693.png" alt="image-20230101151432693" style="zoom: 50%;" />

- 思路：一个位置i可以放多少水，取决于左边最大高度以及右边最大高度当中的最小值。例如，左边最大值是12，右边最大值是15。那么这个位置就取决于12这个值。如果这个值大于等于12，那么放的水就为0，如果这个值小于12，那么可以放的水就等于12-这个位置的值。
- 只需要辅助数组,arr1[i]存放0~i位置的最大值，arr2[i]存放i~N-1的最大值。即可把时间复杂度降为线性。
- 还可以不需要辅助数组，直接用几个变量。L和R分别从第二个位置以及倒数第二个位置开始遍历，因为第一和倒一的位置肯定无法放水。用lm以及rm来表述此时0~L-1以及R+1~N-1的最大值。即使lm和rm是局部的最大值我们也可以对位置进行放水。每次遍历都选择lm和rm中较小的一边放水，例如lm小那么就往L位置放水，然后移动L。直到L和R相遇了。原理是尽管rm是局部的，如果lm已经小于rm了，那么lm肯定也小于全局的rm。

---

### 地形储水

题目5：

- 如果给你一个二维数组，每一个值表示这一块地形的高度
  求整块地形能装下多少水。

  认为每个格子只和自己的上下左右相连

- 流程：

  1. 准备一个堆，记录着当前数字来自于二维数组中的哪行哪列，也就是记录着三个指标，(num,row,col)，这是一个小根堆，根据num来排序。之前进堆过的元素不能重复进堆，用boolean类型的数组来记录。
  2. 先把二维数组边缘的所有元素放到堆中
  3. 设置一个全局变量max
  4. 从堆中弹出堆顶得到num，row，col。看看num能不能更新max。
  5. 把这个元素上下左右没有入过堆的都入堆，在boolean类型的数组中标记，并且结算水量，water累加上max-(up/down/left/right)num。

- 原理：

  1. 边缘放进去之后，堆顶就是短板。max就是此时的短板，只要没有更新max，后面弹出的元素都是以max作为短板。

  2. 当max更新说明你已经转到另一个局部区域了。例如下图，你从5区域转移到了6区域

     <img src="image/image-20230101165457861.png" alt="image-20230101165457861" style="zoom:50%;" />

- 时间复杂度：O(M * N * logK)，k为堆的大小

---

### 加和n元组

题目6：

- 给定一个**有序**数组arr,给定一个正数aim
  1)返回累加和为aim的，所有不同二元组
  2)返回累加和为aim的，所有不同三元组

  例如1122233356666777788899，aim=9，---》  (1,8)/(2,7)/(3,6)

思路：

1. 找出所有的二元组。左右指针，相加小于aim左指针动，大于aim右指针动。相等了，可以规定左指针动，如果此时arr[L-1]==arr[L]那么就不能收入答案，否则就收入答案。
2. 找出所有的三元组。只需要固定第一个，后面两个用找二元组的方法找即可。11122233344567，例如第一次固定了1，找出来之后，后面的两个1就可以省略了，因为后面两个1的范围比第一个1小，它们都被第一个1包括了。



---

### k小数值对

题目7：

- 长度为N的数组arr,一定可以组成N²个数值对。
  例如arr=[3,1,2],
  数值对有(3,3)(3,1)(3,2)(1,3)(1,1)(1,2)(2,3)(2,1)(2,2)
  也就是任意两个数都有数值对，而且自己和自己也算数值对。
  数值对怎么排序？规定，第一维数据从小到大，第一维数据一样的，第二维数组也
  从小到大。所以上面的数值对排序的结果为
  (1,1)(1,2)(1,3)(2.1)(2,2)(2.3)(3,1)(3,2)(3.3)
  给定一个数组arr,和整数k,返回第k小的数值对。

  注意：就算arr中有相同的元素，例如1,1,2,3,(1,2)和(1,2)看做是不一样的，因为分别是下标为0的1和下标为1的1.

思路：

1. 暴力方法，就是整出所有的数值对，然后排序，接着取第k个。
2. 我们可以做到O(N)的时间复杂度。假设arr有10个数，那么按照数值对的第一个元素来进行排列，每一排都有10个数值对。假设我们的每一排都是按照递增顺序，那么我们就可以根据这个来找到我们要找的数值对，如果排好了序应该在第几排。找出在第几排之后，那么需要知道它在第几列。这里的第几列不是严格的第几列，因为它可能大于10，因为数组中可能有重复值。所以我们需要除以它重复的个数。
3. 假设arr有序，首先定位序列的第一个数，arr[k-1/N]。找出小于arr[k-1/N]的数有多少个a，我们的目标变为找以arr[k-1,N)开头的第k-N*a（赋值为p）小。 如果arr[k-1/N]这个数有重复b次，如何知道我们要的来源于第几个这个重复的数---(p-1)/b。
4. arr没序了，想起我们之前的快排改进算法，可以找出一个无序数组的第k小的数，我们把其改成非递归，空间也省了。第一步，找k-1/N小的数，确定一个数。然后找(k-1/N)+(p-1/b)即可。

## Interview Coding 03

### 找工作

题目1：

- 每种工作有难度和报酬，规定如下
  class Job{
  	public int money;/该工作的报酬
  	public int hard:/该工作的难度
  }

  给定一个Job类型的数组jobarr,表示所有岗位，每个岗位都可以提供任意份工作
  选工作的标准是在难度不超过自身能力值的情况下，选择报酬最高的岗位
  给定一个int类型的数组arr,表示所有人的能力
  返回int类型的数组，表示每个人按照标准选工作后所能获得的最高报酬

思路：将工作排序，按照两个维度排序。第一个维度是难度，从小到大排序。第二个维度是钱数，从大到小排序。

第一步，将工作按照难度升序，钱数降序排列。

```
	public static class JobComparator implements Comparator<Job> {
		@Override
		public int compare(Job o1, Job o2) {//先按照工作的难度升序，再按照钱降序排列
			return o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money);
		}
	}
```

第二步，相同难度工作中留下一个钱最多的作为队长。

第三步，删掉队长中难度增加，钱减少的。

- 也就是只留组长，并且组长中必须保证难度上升报酬也在上升

<img src="image/image-20230225110147535.png" alt="image-20230225110147535"  />

这样做完之后难度是递增的，钱也是递增的了。然后把这些都放到一个有序表中，根据难度来排序，然后来一个人，就根据它的能力值，在有序表中查找<=他的能力值最近的那个工作，就是那个人应该选的工作。





---

### 零食（背包）

题目2：

- 背包容量为w
  一共有n袋零食，第i袋零食体积为v
  总体积不超过背包容量的情况下，
  一共有多少种零食放法？（总体积为0也算一种放法）。

在动态规划中，尝试的方法是最重要的。

尝试的方法有：从左往右的尝试模型。---从暴力递归的从左往右的尝试优化成动态规划。

暴力递归有三个参数`int[] arr,int index,int rest`，含义是arr的0~index-1范围的零食我已经选择过了，让你在背包容量还有rest的时候选择index~len-1范围的零食，看看有多少种方法。

- coding层面的问题，在返回0还是-1上面，自己要分得清无方案和值0的区别。如果你不希望上游用0，那么就使用-1自己进行判断。

递归写完之后去改动态规划就很简单



第二种方法：dp [ i ] [ j ] 代表0~i自由选择，凑成 j 的的方法数。可以写出最优子结构。最终结果就是sum{dp [n-1] [0...j]}。因为这里的dp的含义是刚好等于而不是<=





---

### 空间压缩

假设某一个动态规划问题在求dp [i] [j]的时候即依赖于它左边的格子又依赖于它右边的格子的时候，是否真的有必要申请一整张二维表的空间？能不能只申请一个数组呢？我们知道一个要填的dp二维数组中的第一行的值以及第一列的值是我们知道的。那么如果有一个策略可以使得我们可以从第i行的值退出第i+1行的值，那么我们就可以只要一个一位数组就够了。

看图可知，我们是可以通过一个数组迭代得到最后一行的值的。bcde可以从a得到，a'可以从a得到，b‘从b和a’得到。

![image-20230225151700356](image/image-20230225151700356.png)

那么如果依赖自己左上角的位置和上面的位置可以完成更新吗？也是可以的。不过这次数组是从右往左更新。

![image-20230225152102110](image/image-20230225152102110.png)

那么如果依赖自己的左边的，左上角的，上面的，有三个方向可以做到吗？依然可以。但是需要一个额外的变量来抓住被覆盖的之前的值

- 上下左右都要的就不能做空间压缩了。

如果需要自己左边的，上面的，跳一行左上角的，依然可以做到。但是需要三个数组交替的进行

![image-20230225153058299](image/image-20230225153058299.png)

但是如果二维数组行和列相差大，那么也可以用列申请一个数组，横着滚过去。

![image-20230225153446124](image/image-20230225153446124.png)



---



题目3：

- 给定一个二维数组matrix,其中每个数都是正数，要求从左上到右下
  每一步只能向右或者向下，沿途经过的数字要累加起来
  最后请返回最小的路径和
- 动态规划的空间压缩技巧！



---

题目4：

- 请注意区分子串和子序列的不同，给定两个字符串str1和str2,
  求两个字符的最长公共**子序列**
- 动态规划的空间压缩技巧！





---

题目5：

- 请注意区分子串和子序列的不同
  给定两个字符串str1和str2,求两个字符串的最长公共**子串**
- 动态规划的空间压缩技巧！

子串和子序列不同，子串是连续的。

所以这里dp [i] [j]的含义是同时以str1[i]位置结尾以及以str2[j]位置结尾，最长公共子串长度。这个和最长子序列的区别很大，因为最长公共子序列dp [i] [j]的含义是0~i 的str1和0~j的str2的最长公共子序列。造成这样的区别就是一旦str1[i]!=str2[j]的时候，子串的dp[i] [j]要清零，而子序列的dp[i] [j]不需要清零。

在最长子串问题中，答案是二维表中的最大值，而不是右下角的位置。

那么我们能否用子序列问题中的dp的含义来解子串问题？好像是不行的，因为子序列可以是跳跃的，所以dp [ i ] [ j ] 可以继承前面的值。如果子串问题继承前面的值是没有什么意义的，因为前面可能已经断掉了，判断是多少只能一个一个往前比对，这样就太低效了。

- 这题的最优解不是用动态规划，而是用求后缀数组的方法。这个在后面有

因为这题的dp只需要依赖左上角的值，所以我们用有限几个变量就可以了，都不需要数组。我们利用有限几个变量按照斜线的方式来进行更新。并且返回最大值以及返回是谁是一码事。

![image-20230225160952184](image/image-20230225160952184.png)



---

### 词频最大的前K个字符串

题目6：

- 给定一个由字符串组成的数组String[] strs,给定一个正数K
  返回词频最大的前K个字符串，假设结果是唯一的

先全部放到一个hash表中统计词频。接着把字符串和词频封装成一个对象。把这些对象全部放入一个大小为k的小根堆中。在小根堆中剩下的就是top k。

![image-20230225162712437](image/image-20230225162712437.png)



---



题目7：

- 请实现如下结构：
  ```
  TopRecord{
      public TopRecord(int K):构造时事先指定好K的大小，构造后就固定不变了
      public void add(String str):向该结构中加入一个字符串，可以重复加入
      public List<String>top():返回之前加入的所有字符串中，词频最大的K个
  }
  ```

  要求 ：
  add方法，复杂度O(Iog k):
  top方法，复杂度O(k)

- 固定只能要top k，不能一会top 2，一会top 3

 用自己实现的堆结构来实现。自己实现的堆结构在基础班第四节。

系统实现的堆只能做到你给他一个（string ，integer），它帮你插入到堆中。但是没有办法帮你定位到string所在堆中的位置，然后直接把它的词频+1，接着做堆结构的调整。要实现这个功能我们需要有一个额外的结构，例如hash table帮助我们记录下string对应在heap中的位置。另外一个hash table帮助我们string与词频的对应关系，这样我们就不需要一个额外的类。但是创建一个Node也是可以的，看个人的偏好，区别就是判断在堆上移动的标准是从times表中拿还是从Node本身拿。

来一个字符串就在index表中看看这个字符串在不在堆上，如果在堆上，那么直接在对应的times表上+1，并且做堆结构的调整。如果不在堆上，那么仍然是times表上对应加一，然后直接插入小根堆，接着从小根堆中弹出一个。如果times表上找不到这个字符串，那么就在times表和上创建，然后插入小根堆。

- 另外一种思路：先遍历一遍，在hash表中统计词频。统计完了之后string和次数封装起来放到一个数组中，然后利用bfprt算法找到第k小的。接着遍历一遍数组把符合的全部挑出来，这样算法的复杂度是O（N)	

## Interview Coding 04

### 打印目录结构

题目1：

![image-20230307192547431](image/image-20230307192547431.png)

- 用前缀树。前缀树除了必须有一个指路结构之外，其它的结构都是看需求建立的。例如这题要打印目录结构，我们是来到一个结点之后打印的，所以我们就在结点中多记下我们是从那条路（这个路代表的就是某个字符或者是字符串，看题目）到这个结点的。如果每条路都是字符的话那么只需要26大小的数组即可，如果是字符串的话就要使用hash了。因为这里说的是同一级别要按照字典序，所以要使用TreeMap。
- java中\是转义。因为在正则表达式中`\\`表示匹配`\`，所以我们要在java中表示正则表达式的`\\`，就需要在正则表达式中的每个`\`前面多加一个`\`也就是`\\\\`



### 搜索二叉树转双向链表

题目2：

- 双向链表节点结构和二叉树节点结构是一样的，如果你把last认为是left，next认为是next的话。给定一个搜索二叉树的头节点head，请转化成一条有序的双向链表，并返回链表的头节点。

![image-20230317160947873](image/image-20230317160947873.png)

思路：可以用递归套路。用一个f(head)返回[start,end]。



### 先序、中序数组求中序数组

题目3：

![image-20230317135544493](image/image-20230317135544493.png)

思路：建树的话就慢了。这里我们搞一个函数f(arr pre,0,6,arr in,0,6,arr post,0,6)，先序数组给你0~6这段，中序数组也给你0~6这段，然后你帮我生成好后序数组0~6。

这题就是一个递归设计题，先序遍历的第一个数就是后序遍历的最后一个数，先填好，然后到中序遍历中找到先序遍历的第一个数在中序数组中的什么位置，然后继续递归。

但是这个找先序数组第一个数在中序数组的什么位置，可以遍历，也可以预处理数组。利用一个map即可。用了预处理就是n的复杂度，如果不用就是n²了。



### 最长递增子序列(n logn)

题目4：

- 给一个数组arr，求最长递增子序列

什么叫最长递增子序列呢？必须严格递增,连相等都不行。然后子序列：可以不连续

dp[i]啥意思？如果子序列必须以i结尾，最长递增子序列是多长。

求法：求i位置的dp，首先找到arr中i左边比你小的，在它们中找到一个dp最大的，然后+1即可。例如arr=[1,4,8,11,9,**10**],例如求加粗的10这个位置的dp，那么就找到前面有[1,4,8,9]比你小，下标分别是[0,1,2,4]，然后看一个求max{dp[0],dp[1],dp[2],dp[4]}，这个值+1就是加粗10位置dp的答案

对上面的过程做一个加速，因为不做加速的话，找前面比你小的数的下标位置就是一个n复杂度的了。我们必须引入一个新的东西---ends数组。ends数组，它跟原来的这个array是等长的。ends[i]它的含义是：目前找到的所有长度为i+1的递增子序列中最小结尾是什么值。注意这个ends数组中，如果我没有填过的位置，认为是无效区。所以一开始ends都是无效区。只有在有效区里面的东西才有这个含义。然后ends有效区一定是有序的，因为如果无序，也就是ends[4]=8,ends[5]=6的话，说明我找到了一个长度为6的子序列，并且以6结尾是最小的。那么我直接少一个结尾6的话，长度为5的子序列的最小结尾肯定是小于6的，而这里是8，所以矛盾了！故一定有序。

ends[i]和dp[i]是一起更新的，如何更新？在ends的有效区中，找到最左的大于等于arr[i]的位置，找到了就把这个位置改成arr[i]，然后数一数这个位置左边包括自己在内有几个数，有几个，dp[i]就填几。如果ends找不到最左的大于等于arr[i]的位置，那么就扩充有效区，然后把自己填进去。接着数这个位置左边包括自己在内有几个数，然后填进去。

- 如果只要最长递增子序列的长度，dp都可以省略了，只需要用一个max抓住即可。ends代表每种长度下最长递增子序列的结尾是多大。显然既然是最长递增子序列，如果尾巴的数越小，那么对于后面获得最长就越有利。所以每次来一个数，就去更新ends中大于等于它的最左边。

  你得到dp之后，遍历拿到的最大值就是最长的递增子序列的长度。如果要得到最长的递增子序列具体是什么，需要拿着dp去加工。

![image-20230317151316720](image/image-20230317151316720.png)

题目5：

- 每个信封都有长和宽两个维度的数据，A信封如果想套在B信封里面，A信封必须在长和宽上都小于B信封才行。如果给你一批信封，返回最大的嵌套层数

思路：第一维的数据从小到大，第二维的数据从大到小。

![image-20230317152145332](image/image-20230317152145332.png)

然后把二维数据单独拎出来做一个最长递增子序列就知道答案了。一维数据从小到大保证了底从小到大，然后二维数据打破了同底的递增序，这样一来只有是不同底的在二维数据中才可能递增。

我再给你举个例子。我给你一些二维的点，每一个点给你一个x方向的值，给你一个y方向的值。我问你我想找到一条线，一条曲线，这条曲线一定要严格的不断的往右上方窜的一条曲线。它不能够往下走，也不能够往左走，它只能往右或者往上走，或者平着来，或者往上走，怎么找到这么一条曲线穿过的点最多？这是不是信封套娃的问题啊？



### 子数组最大累加和

题目6

- 给定一个数组arr，返回子数组的最大累加和。

子数组：连续

用两个变量即可，一个变量cur，一个变量max。cur从左往右遍历数组，遇到一个数就加上去，然后看看能不能更新max。如果cur加得都<0了，那么就把cur置为0，然后继续遍历。

这个算法在数组是全负的时候也是对的。有负数和0的时候也是对的。现在证明三个都有的时候也是对的，我们假设数组的[m...n]是最大的累加和子数组，那么[m....i]和[i....n]这边上两段一定不小于0。并且[k...m-1]的累加和也小于0。所以说当我们的cur遍历到m位置的时候，cur一定是0，因为之前的[k...m-1]一定小于0。

设计流程！



### 子矩阵的最大累加和

题目7：

- 给定一个整型矩阵，返回子矩阵的最大累加和

子矩阵在大矩阵里面就是一个长方形。

思路：列举行的情况。0~0/0~1/..../0~n-1     1~1/1~2/.../1~n-1

然后在每种行的情况求一下列怎么囊括。列怎么囊括用子数组最大累加和即可。例如求0~3行情况的最大，那么把0~3行中的每一列加起来，压缩到一个数组里面，然后在哪个压缩数组里面求子数组的最大累加和。每次行情况求出来结果都用max看看能不能更新。

- 小优化：考虑行列的差异。



## Interview Coding 05

### 删成子串问题

code1：

- 给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串 ?

  比如 s1 ="abcde”，s2 =“axbc"。返回1。s2删掉x就是s1的子串了

思路1：如果s2比较小，那么就列出s2的所有子序列，然后和s1去kmp。原理是子序列删掉中间那些就连起来了。

思路2：把s1的所有子串搞出来，和s2去做编辑距离问题，这个编辑距离问题只能删除。或者反过来对称的，只有插入行为。和题目二的动态规划很像，只不过情况少了，只能删除了。

小优化：没有优化之前，子串N²，做编辑距离问题N*M复杂度，总复杂度O（N³ * M）。但是我们发现，我们从0~n子串到0~n+1的情况的时候，可以只加一行的dp就行。所以复杂度可以优化为O（N² * M）。那么我们可以利用没有优化之前的dp算法，返回一个dp数组出来，然后最后一列就是我们需要的答案。

### 编辑距离问题

code2：

![image-20230317161534200](image/image-20230317161534200.png)

比如说大家在用某搜索引擎搜索的时候，你搜了一个父亲节礼物。然后他给你联想了一个父亲节的礼物。他怎么做到的？编辑距离问题。他就把这个候选串中高频的候选串，看你的输入跟它有多少相似度。你编辑距离很小的，他先推荐。

思路：这题的插入和删除我们都认为在哪个位置插入和删除的代价都是一样的。这是一个样本做行一个样本做列的对应模型。

![image-20230317163832221](image/image-20230317163832221.png)



### 完全二叉树的结点个数

code3：

- 求完全二叉树节点的个数
  要求时间复杂度低于O(N)

思路：

1. 求树的总深度，假设有N层
2. 去看看head的右树的最左的结点是不是在第N层。如果在的话，那么说明head的左树是满的。如果没有在，那么说明右树是满的，只不过高度比左树满的情况少了一层。
3. 递归去求

复杂度：

- 在深度上玩等差数列，所以是O(  (log n)²  )

---



- 牛客网--面经。

- 北欧人--全

- career cup --- 国外的热门

### LRU

code4：

LRU算法：假设一个结构只能放三条数据。每个数据我都对应一个时间戳。每次查询或者修改的时候都更新为现在的时间戳。然后如果结构满了，又有新数据要进来，那么就找时间戳离现在最远的那个数据删掉，把新数据换进来。那么要你实现这么一个结构，通过k的方式给你，告诉你这个结构最多只能放k条记录。然后如果超过了，就按照上面说的来进行替换。只有put和get两种操作。要求put和get时间复杂度都是O(1)。

如果是堆和有序表实现的话，那么O(log n)是逃不了的。这个是LRU的算法设计。很难的是LFU--训练营第五期。这种数据结构设计题，它基本上也是用到讲过的结构拼出来的，我讲过哪些结构：队列、栈、哈希表、双链表、有序表。就这些玩意儿。

我们是双链表加哈希表的设计。一张表叫哈希表，这个哈希表的key就是用户给你的key，例如用户叫你把("abc",20)这条记录放到结构里，"abc"就是hash表的key，把“abc”这个字符串和20你给我怼到一起，做成一个node，作为hash表的value。这个node包含了用户的记录，还包含了两个指针---双链表。

当结构没满的时候，用户put记录，那么就把记录直接记到hash表中。例如用户记录为("a",10)，那么hash表的key就是“a”,value就是包含了记录的一个node结点，这个node结点是双向链表的一部分。如果现在用户get了，那么就可以直接从hash表中取出结果，结果都在node里。然后由于hash表可以直接找到node的位置，那么就把这个node直接从双向链表中间的位置拿出来，放到双向链表的最后位置，然后要把原本双向链表连好。双向链表中越尾巴的就是越近操作的。改双向链表的操作都是O(1)的时间复杂度。

你如果只有单链表，你单链表你通过中间的node，找前面那个你找不到，你没有办法把node分离出来之后，前面环境跟后面的环境连好，所以不能用单链表。



### 打印所有最短变换路径

code5：

![image-20230325134205404](image/image-20230325134205404.png)

- 这题的操作全是替换。start和end和list中的每一个字符串的长度都是一样长的。
- 这题就是一个宽度优先遍历结合深度优先遍历。

我们先解决一个什么问题，list中所有的字符串，离star的最近距离是什么？先把这个整个这个list给我变成一张图，图中每一个字符串就是一个点。那两个点之间怎么样去知道有没有边呢？如果两个字符串只通过改动一个位置的字符，能相互变到，我就认为它有边。如下图所示。

abc邻居：akc、abb

abb邻居：acb、akb、abc

。。。。

然后我们就可以生成一张hash 表，hash表的key就是字符串，value就是一个list，里面放的是key的所有邻居。但是怎么去生成list中字符串的所有邻居呢？如果你是一个一个遍历，str1去看看和str2、str3、... 、strn有没有路径，所有都这么过一遍，需要O(N²)的复杂度，如果字符串长度是k，那么总体需要O(N² * k)的时间复杂度。太慢了！

来看看另一种思路。你把list里面所有的字符串都放到一个hashset里面。例如现在要找str1="abc"的邻居。要知道，有路代表abc中只能变一个，那么a可以变成b/c/d/e/f/.../z，总共有25个。字符串的每一位都有25种变法。那么str1是三个字符，那么就有3 * 25种变法。你去hashset中看看没有，如果有，那么它就是你的邻居。如果字符串长度为k，那么就有k * 25种候选邻居。str1~strn都去hashset里面查，时间复杂度降为O(N * k * 25)，降了一阶。但是这个时间复杂度是在认为在set中查找的代价为O（1）的情况下。但是由于hashset要把字符串的所有字符遍历一下，去求hash值，所以和k有关。所以我们认为在hashset中找存不存在是O（k）的复杂度，故最终复杂度为O(N * k²)，25忽略。如果字符不只是小写字母，如果是ASCII字符，那么也就是128 * k。所以实际上是O(N * k²)大还是O(N² * k)大，根据具体的数据去决定。

<img src="image/image-20230325135734411.png" alt="image-20230325135734411" style="zoom:67%;" />

coding问题：要返回一个list的list。因为我们需要返回所有的路径，一个路径就是一个list，返回所有的list就需要list的list。

- 当我们不能忽略hashset中单样本大小的时候，在hashset中求这个样本的hash值的时候，时间复杂度就是O(K)。因为算String的hashcode需要遍历string中的每一个字符串。

所以现在我们有所有结点的邻居。然后求了start到所有结点的最短距离---宽度优先。然后根据知道的最短距离去深度优先遍历收集答案，在深度优先遍历的时候，只有让距离增大的邻居我才去走，父保证子的递归是合法的。要记得恢复现场。

### 图结构练习题

code6：

![image-20230325145422675](image/image-20230325145422675.png)



## Interview Coding 06



### 异或和问题

题目1：

- 一个数组的异或和是指数组中所有的数异或在一起的结果给定一个数组arr，求最大子数组异或和。

它是一道比较难的题。首先我没有说这个数组正负零这回事儿。那你就可以认为这个数组中什么值都可能会出现。而且它不是什么累加和最大，它也不是什么乘积最大，它是异或和最大，这个运算它跟乘跟加可不一样。两个超小的数异或起来可能超大，两个超大的数异或起来可能超小，一个两个中不溜的数异或起来可能超大或者超小。你完全无法摸住这个这个运算的性质。

你看到这种子数组的问题，你把你流程定成啥呀。每个位置开头的情况下怎么怎么样，每个位置结尾的情况下怎么怎么样，如果我都求出来，每个位置结尾或者开头时候的答案，那么我总答案不会错过。

暴力流程。我们枚举以每个位置结尾的子数组的异或和，然后求出最大的。0位置结尾的就是0~0。1位置结尾的就有0~1,1~1。这样去枚举肯定可以求出答案。异或这个运算太魔性了，我们摸不出什么规律。我们不摸这个规律我们怎么做比较快呢？如果是暴力的话，子数组个数是N²，然后遍历子数组求异或和是N的复杂度，所以总的求子数组的最大异或和的时间复杂度就是O（N³）。

这道题最终可以做到O（N）的复杂度！

我们先从我们的流程入手。我们前面暴力解在求异或和的时候是遍历子数组求异或和的，但是其实0~i的异或和其实等于0~i-1的异或和再异或arr[i]。所以我们可以用一个前缀异或和的预处理数组来加速我们的流程。求异或和数组只需要O（N）的复杂度，子数组个数依然是N²，但是求子数组的异或和只需要O（1）的复杂度了。所以总的复杂度可以降为O（N²）。eor[i]代表0~i的前缀异或和。那么arr[i...j]的异或和就是eor[j] ^ eor[i-1]。

我们不能优化的原因就是我们不知道我们之前算的哪一个异或和是有用的，是可以让后面异或和更大的。所以我们只能去枚举。这是慢的根本原因。

异或就是二进制的不进位相加。现在你要求5结尾的最大异或和。此时你知道0~5的前缀异或和eor[5]。按照我们之前的流程，我们是让eor[5]一个一个的和eor[0]/eor[1]/.../eor[4]去异或，看看哪个比较大的。但是由于异或是不进位相加，eor[5]的二进制是0110。我们肯定希望eor[0]~eor[4]中有1001。即便没有，我们在选择的时候也是从左到右优先的去选，例如1110就比0001好。1110只有第一个符合我们的预期，即便0001有三个符合我们的预期，但是也是1110最好。所以说我们可以把之前求的所有的前缀异或和按照二进制的形式全部加到前缀树里面。然后按照预先的决策，朝着最有可能最大的路去走。例如我们现在把eor[0]~eor[4]的前缀和的按照二进制的形式全部加到前缀树里面。然后我们希望按照1001的决策去走。也就是在头节点先看看有没有走向1的路。如果有就走，如果没有就走另外一边。然后第二次选路的时候就优先选走向0的路，以此类推，最后走到的位置我们拿到走向它的路径。去和eor[5]异或一下，就是以5结尾的子数组异或和的最大值了。

所以给了我们一个启发，如果你的优化思路和前缀预处理结构有关，那么前缀树可能是你解题的突破口。

![image-20230325160433611](image/image-20230325160433611.png)

但是还要继续推广。因为我们上面讨论是无符号的整数的情况。int类型是有正负的。我们肯定希望最后的结果是一个正数，也就是最高位是0。那么如果最高位是1，我们希望异或一个最高位也是1的让它变成0。如果最高位是0，那么希望异或一个最高位是0的。如果最高位可以满足变成0，那么我们希望从左到右异或完之后是1，这样可以保证结果最大。如果最高位只能是1，那么由于计算机里面是补数的概念，全1表示-1，也就是我们还是希望从左到右异或完是1，这样结果不会那么小。

所以我们的贪心策略是：我们希望高位和xor[i]一样，然后剩下的位从左到右最好能和xor[i]异或完之后能都是1。

---

加一道题，但是和异或有关的。在训练营四期

给你一个数组，你可以随便划分，划分成多少块都行，问你划分出来的块，异或和为0的块，最多能有几块？

假设dp[i]为arr[0...i]进行划分，异或和为0的块的最大数量。假设eor[i] ^ eor[j] = arr[j+1^...^i] = 0。很显然arr[j+1...i]可以划分为一个块，异或和是0 ,那么dp[i]=max{dp[i-1],dp[j]+1}。分类原则就是看i位置的数所在的块，是不是异或和为0的，如果不是，那么这块就没有用，dp[i]=dp[i-1]。如果是异或和为0的，那么就找到最近的异或和等于eor[j]==eor[i]的，然后就等于dp[j]+1。这两种情况求最大值。

- 我自己的尝试思路：如果arr[i]=0，那么就可以自己单独成块！至少是dp[i-1]+1。如果自己是1，那么就找到最近的异或和等于eor[j]==eor[i]的，然后就等于dp[j]+1。两种情况求最大值。（正确性待验证）
- 假设答案法，分析最后一个位置和答案有关还是无关。
- 注意，你划分出来的块不都是0，只是说你划分出来为0的块最多就行了

### 运算顺序组合

题目2：

![image-20230325163720451](image/image-20230325163720451.png)

- 你可以利用小括号得到所有的运算顺序，假设通过你加小括号总共有all种运算次序。问你这all中运算次序中能返回true的有几种。

一开始偶数位置上的东西不是0就是1，奇数位置上是与、或、异或。整个字符串的长度是奇数

- 动态规划，范围上的尝试模型

定义f(str,l,r,desired)。代表在str[l...r]的范围上，期待结果是desired总共有多少方式。假设f(str,0,10,desired)，那么就可以按照某个运算符作为最后一个运算来划分。假设以str[1]的运算符来作为最后一个运算符、以str[3]的运算符来作为最后一个运算符、...   、 然后根据这些位置的运算符是什么，来确定递归的左右两边分别期待什么结果。

l和r都是压中字符“0”和字符“1”的位置，不可能压中逻辑符号的位置，因为我们进递归之前都检查了字符串的合法性。暴力递归搞定，动态规划就出来了。f有三个可变参数，但是有一个参数只有两个可能的值，所以两张二维表可以搞定，一张true表，一张false表。

表是一个正方形。因为l<=r，所以表只有一半有用。由于l和r都是偶数位置，所以表中的奇数位置也没用。

照着递归直接改动态规划

### 跳格子问题

题目3：

- 给出一组正整数arr，你从第0个数向最后一个数，每个数的值表示你从这个位置可以向右跳跃的最大长度，计算如何以最少的跳跃次数跳到最后一个数。

思路：5步内能跳到的右边界是多少，可以由4步内能跳到的右边界决定的。base case就是0步内只能跳到0。准备三个变量，step代表现在走了几步，curR代表当前步数能到达的右边界，next是下一层能到达的右边界。从左往右遍历，遍历到9位置的时候step就是答案。从左往右的尝试模型。

### topk两数累加和

题目4：

- 给定两个有序数组arr1和arr2，再给定一个正数K，求两个数累加和最大的前K个，两个数必须分别来自arr1和arr2。

这里说的不能重复不是说12+14=26这个值不能重复，而是说两个数组中下标组合不能重复。

<img src="image/image-20230325194743718.png" alt="image-20230325194743718" style="zoom:67%;" />

思路是一个样本做行一个样本做列的模型。

最开始先把最右下角的放进大根堆，大根堆用累加和来排序。然后以后每次都从大根堆中弹出一个node作为一个答案，然后把node的左边和上边都压进大根堆。但是要防止重复压入大根堆，所以需要有一个二维的boolean数组来判断是否已经压入过。

复杂度是O（k * logk）

![image-20230325200143068](image/image-20230325200143068.png)

### 切分累加和相等的数组

题目5：

![image-20230325201017954](image/image-20230325201017954.png)

这道题其实非常简单啊O（N）搞定。然后只用一张哈希表。这也不是啥动态，要分辨能不能动态规划有时候还挺麻烦。有一个很大的套路，是关于动态规划的，二叉树也是递归套路也是动态规划，在树上做动态规划，几种什么套路模型也是搞动态规划的。那你面对这种设计怎么算的这种算法呢？其实还挺难找感觉，只能练。

思路：我先把所有的前缀和。全记在这个哈希表里。注意，它是正数数组。其实如果不是正数数组的话，也有办法做，我们先说一下正数数组，因为正数数组它分析起来很简单。这个正数数组，那么它所有的前缀和都是不一样的，是递增的前缀和。用一个map记录每个位置结尾的前缀和。

首先你要知道。你切出来的部分得有数。你又是严格是切三刀。画出四个部分来。所以你知道你这个数组长度一定是大于等于七的。我们枚举什么呢？我们从1位置开始枚举。枚举的是第一刀的位置。为什么不从零枚举？因为零它做不了第一刀零，它要做第一刀，它左边没东西。我第一刀枚举的位置应该到哪？恐怕不是到n- 1。因为这样剩下的几刀没法放了。例如上面的arr[3,2,4,1,4,9,5,10,1,2,2]，假设第二刀下标在N-2，第三刀在N-4，那么第一刀只能枚举到N-6。也就是说第一刀枚举的位置是1~N-6。

如果第一刀的位置是i，如果有第二刀j，假设sum[i]代表前缀累加和数组，那么sum[i-1]=sum[j-1]-sum[i]，转化一下，也就是sum[j-1]=2 * sum[i-1] + arr[i] 。如果有第三刀z，那么就再看看sum[z-1]=3 * sum[i-1] + arr[i] + arr[j] 。我们是用hashmap来记录前缀和了，用数组记录也是一样的。在第一刀定了之后，中间如果有任何一个环节不对，那么说明第一刀放在那个位置是不行的。由于你只枚举了第一个位置，后面所有的位置成不成立都是在map中查的，所以复杂度为			O（N）。

![8ed9f9b79c20a69b78f3263c24224ec](image/8ed9f9b79c20a69b78f3263c24224ec.jpg)

### 判断交错组成字符串

题目6：

![image-20230325204044740](image/image-20230325204044740.png)

如果str1和str2没有重复字符，那么就可以用两个指针搞定。但是如果有重复字符就不行了，因为你没有办法判断这个重复字符属于哪个str。

思路：动态规划。首先过滤，str3的长度一定是str1和str2长度之和。还是一个做行一个做列的模型。还是一张二维表，但是行和列是0~N和0~M了。dp [i] [j] 的含义是str1前缀i的长度，str1[1...i-1]。str2拿j长度出来，也就是str2[0...j-1]。问能否交错组成str3的i+j长度，str3[0...i+j-1]。dp表中填的是布尔类型的变量。dp [N] [M]就是答案。

接下来就是填格子。dp [0] [0] 就是str1和str2都是空串，肯定是true。第一行和第一列都是看前缀是不是和str3的前缀一样，如果一样就一路true。一旦不等后面都是false。然后填普遍位置的顺序就是从上往下，从左往右。这样填每个格子的时候左边和上面的格子都是填好了。

接下来整理可能性。如果dp [i] [j]来自于dp [i-1] [j] ，那么dp [i] [j]=dp [i-1] [j] && str3[i+j-1]==str1[i]。如果dp [i] [j]来自于dp [i] [j-1] ，那么dp [i] [j]=dp [i] [j-1] && str3[i+j-1]==str2[j]。

### 最少的回文部分数

题目7：

再来一个范围上的尝试模型题目：一个字符串中，最少把字符串分为几个部分，能让分出来的部分全是回文串。

当然有一种方法是把每一个字符都切开，这一定是回文串。

这个几个尝试模型。你比如说从左往右的尝试模型。太多了，背包问题，每个位置要不要这种展开的。包括我们这个题，其实它利用的是从左往右的尝试模型加范围上尝试模型解决的。那么一般来讲，我们练的稍微多一点的是一个样本做行一个样本做列的对应模型。当你解题的时候，你发现前缀串只讨论结尾字符的可能性，能够把所有可能性列全，而且能试出来，那就是一个样本做行一个样本做列的对应模型。

他还是从尝试来的，就有一个东西就非常关键，可能性的组织。我发现我讨论前缀串的结尾的情况是能讨论干净的。这个尝试能做，那就是一个样本做行一个样本做列的对应模型。所谓的范围上尝试的模型是什么样？一种尝试思路就是在整个串或者一个样本上，我选择各种不同的分割点。这样的可能性展开，它最后就对应到范围上尝试的模型。因为你有分割点的话，你意味着左侧一个范围，右侧一个范围。

所以所谓的一个样本做行一个样本做列的对应模型，还是我们范围上尝试的模型，只是可能性的组织方式不同。就是如果我发现我利用前缀串可能性的组织，只讨论前缀串的结尾，类似于这种样的讨论。不需要再通过枚举，什么割裂点，分割点这种玩意儿，能够讨讨论干净，那就是一个样本做行一个样本做列的对应模型，但是如果发现我在一个范围上，我在讨论可能性的时候，我必须把它找若干个分割点去求这个答案的话，它就是范围尝试的模型。

这题f(arr,i),含义为arr[i...N-1]最少能划出几个部分让这几个部分都是回文。假设现在要求f(arr,i)，假设i位置以后的字符串是ababckkcb121。那么看看以i位置为前缀开头，能有多少个回文串，都去尝试一下，凑出答案。例如a自己就是一个回文，所以dp[i+1]+1就是一个答案。ab不是回文，所以dp[i+2]就不用考虑。aba是回文串，所以dp[i+3]+1也是一个答案。最后这些可能的答案求一个最小值。如果我们是遍历的方式去检查回文，那么复杂度就是N，你填dp表的时候需要列举后面所有的可能，复杂度是N²，所以总的复杂度是N³。

- 因为我们的复杂度组成是N² * N，如果我们可以用N²的复杂度，设计出一个预处理结构，可以把后面的O（N）变成   O（1），那么总的复杂度就变为N²。

但是如果我有一张表，是一个二维数组，可以告诉你这个数组l~r是不是一个回文。那么复杂度就低了。我们来看一下怎么生成呢？范围上的尝试，对角线单独填好，左下半区没用。然后一个普遍的位置dp [i] [j] ，i~j范围上要是回文，首先i位置的字符要等于j位置的字符。并且i+1~j-1的范围上也是回文。所以一个普遍的点(i,j)依赖左下角的点。所以我们可以一条对角线一条对角线的填。



## Interview Coding 07

### 需要排序的最短子数组

code1：

- 给定一个无序数组arr，如果只能在一个子数组上排序
  返回如果让arr整体有序，需要排序的最短子数组长度

1,2,3,7,6,5,4,8,9。这样的数组只需要7,6,5,4排序即可，所以返回4。如果数组是4,3,2,1那么就只能整体排序。

流程：先从左往右遍历，然后从右往左遍历。从左往右遍历的时候，来到了i位置，一路更新0~i位置的最大值max，一旦你发现i位置的数小于max了，那么说明递增断掉了，i位置不合格。找到最右的不合格的位置r。从右往左遍历的时候我们想要数组是递减的，所以要记录min，一路更新i~N-1的min，然后找到最左的不合格的位置l。l~r就是我们要排序的范围。

原理：我们利用max可以找到非递增区间，利用min找到非递减区间。在这两个区间之外的就是从左往右递增，从右往左递减，是不需要排序的。从左往右遍历打上叉号意思就是以后需要给比自己大的让路。从右往左遍历打上叉号意思就是以后需要给比自己小的让路。两边的就是不需要让路的，自然就不用动了。

![image-20230325212206366](image/image-20230325212206366.png)

### 最小不可组成和

code2：

![image-20230325212854800](image/image-20230325212854800.png)

- 背包问题。dp[i] [j]代表arr[0...i]能不能组成j的累加和。如果dp [i-1] [j] = true ，dp [i] [j] = true。

  否则dp [i] [j] = dp [i-1] [j-arr[i]] 

直接做进阶。之前的所有条件都不变，多加一个条件，arr中一定有1这个数，问有没有更快的解法。

先排序。然后有一个变量range表示1~range所有的数都可以加出来，range一开始设置为1。来到一个位置i的时候，假设这个位置的值是a。有两种情况，a>range+1 和 a<=range+1。在面对第二种情况的时候，range=range+a，因为range的含义就是0~range的所有我都能得到，所以如果a比我range+1小，那么此时range就能够凑成更大范围的数了。如果中了第一种，那么直接返回答案，答案就是range+1，因为往后的数都不能用了，因为太大了，range+1永远都得不到了。那么如果一直没违规，那么把数组处理完之后的range+1就是答案。



### 加和全覆盖

code3：

![image-20230325215512409](image/image-20230325215512409.png)

用题目2的技巧来解题目3。先看arr如果没有，我们缺几个数----二进制！(1,2,4,8,16.....)。

如果你已经达到了1~range所有的数你都能累加出来了，但是你还没有达到aim，那么你永远缺的是range+1这个数，它一定是最省且最经济的数。加上之后，你能到达的范围就从1~range变成了1~2 * range+1 了。

思路：在遍历的过程中如果我来到了i位置，值是a，那么我在这之前一定要完成1~a-1的这个范围才行，否则就缺数了！range在遍历的过程中会变大，变大的来源是你补上了缺的数字，或者你使用了arr中的数字。只要你的range在遍历的过程中达到了aim，那么就停，返回答案。如果你遍历完数组之后还是没有达到aim，那么就每次补上range+1，最经济的去接近aim。



### 返回数组中独立的域

code4：

- 一个数组中，如果两个数的公共因子有大于1的，则认为这两个数之间有通路返回数组中，有多少个独立的域

3和6有一个公共因子3,3和21也有一个公共因子3，所以可以认为3和6和21是连在一块的，连在一块的称为一个域。问你一个数组中，互不相连的域有几个。

<img src="image/350d1f6b5b8da8614d979472898bd23.jpg" alt="350d1f6b5b8da8614d979472898bd23" style="zoom:67%;" />

- 思路肯定是并查集，关键是怎么用并查集。假设并查集你已经实现了，并查集的操作复杂度是O（1）。对于一个arr，先把arr里面所有的数都加到这个并查集里面，每个数都是单独的集合。然后0下标和1下标、0下标和2下标、0下标和3下标、。。。、0下标和n-1下标看最小的因子是不是大于1的，是的话两个集合就union。然后最后看看并查集里面有几个集合就是有几个域。这种方法的复杂度是O（N²）

- 接下来换一个思路。如果我告诉你arr里面的数值范围不是很大。假如我现在拿到了第一个数20，下标是0，那么20背后的质数因子就是2和5。那么就用一个map记录(2,0)/(5,0)。第二个数是7，下标是1，map记录下(7,1)。第三个数14，下标2，指数因子是2和7，一查在map里面有，那么map就不需要记录了，map只有在没有的时候才添加。在map里面一查，发现之前下标0的那个元素对应的结合里面有质数因子2，所以就把2下标的集合与0下标的集合合在一起。同理，2下标的集合与1下标的集合也合在一起。这样等价于012下标对应的集合都合在一起了。 

  要得到一个数V的所有质数因子，需要O（V）的复杂度，因为你需要从1一直遍历到V才知道。整个算法的时间复杂度变为O（N * V）。如果V比n小，那么就可以用这种方法。

- 还有更好的方法，最终可以优化成O（N * 根号V）。其实遍历最多只需要遍历到根号V即可，我们不找指数因子，找所有因子。下面是证明。 也就是我要找17的所有因数，我们从1开始试，从1一直试到根号17下取整，也就是16。我们只找到了一对 1 * 17=17，我们把1忽略，只放17进去。

  ![f24c5f38493655f42468e944d5f6e8a](image/f24c5f38493655f42468e944d5f6e8a.jpg)

- 补充一个知识点：如果求a和b的最大公约数？辗转相处法！一行代码。唯一的约束就是初始调用的时候保证m和n都不是0。假设求30和20的最大公约数。gcd(20,30)-->gcd(30,20)-->gcd(20,10)--->gcd(10,0)--->10，20和30的最大公约数就是10。

  ```JAVA
  public static int gcd(int m, int n) {
     return n == 0 ? m : gcd(n, m % n);
  }
  ```

  证明：
  
  ```
  辗转相除法，也称欧几里得算法，可以用来求两个正整数a和b的最大公约数（Greatest Common Divisor，缩写为GCD）。当a和b不是正整数时，辗转相除法可能会失效，因此a和b必须是正整数。
  
  辗转相除法的基本思想是：假设a>=b，则a和b的最大公约数等于b和a%b的最大公约数。如果a%b=0，则b即为a和b的最大公约数。如果a%b不等于0，则继续对b和a%b进行相同的操作，直到a%b等于0为止。
  
  由于负整数的余数可能为负数，所以当a或b为负整数时，辗转相除法的结果可能不是最大公约数，因此a和b必须是正整数。
  
  证明：
  对于两个自然数 a 和 b,若存在正整数 q,使得 a=bq,则 b 能整除 a,记作 b | a,我们叫 b 是 a 的因数,而 a 是 b 的倍数.
  那么如果 c | a,而且 c | b,则 c 是 a 和 b 的公因数.
  
  由此,我们可以得出以下一些推论:
  
  推论一:如果 a | b,若 k 是整数,则 a | kb.因为由 a | b 可知 ha=b,所以 (hk)a=kb,即 a | kb.
  
  推论二:如果 a | b 以及 a | c,则 a | (b±c).因为由 a | b 以及 a | c,可知 ha=b,ka=c,二式相加,得 (h+k)a=b+c,即 a | (b+c).同样把二式相减可得 a | (b-c).
  
  推论三:如果 a | b 以及 b | a,则 a=b.因为由 a | b 以及 b | a,可知 ha=b,a=kb,因此 a=k(ha),hk=1,由於 h 和 k 都是正整数,故 h=k=1,因此 a=b.
  
  辗转相除法是用来计算两个数的最大公因数,在数值很大时尤其有用而且应用在电脑程式上也十分简单.其理论如下:
  
  如果 q 和 r 是 m 除以 n 的商及余数,即 m=nq+r,则 gcd(m,n)=gcd(n,r).
  
  证明是这样的:
  
  设 a=gcd(m,n),b=gcd(n,r)
  
  则有 a | m 及 a | n,因此 a | (m-nq)(这是由推论一及推论二得出的),即 a | r 及 a | n,所以 a | b (其中a和b都是最大公约数（为所有不同公约数的乘积），故若a是n和r的公约数，那么a必然能整除n和r的最大公约数b，即a | b)
  
  又 b | r 及 b | n,所以 b | (nq+r),即 b | m 及 b | n,所以b | a.因为 a | b 并且 b | a,所以 a=b,即 gcd(m,n)=gcd(n,r).
  ```
  
  
  
  

### 保留单个字符使结果字典序最小

code5：

![image-20230331141243320](image/image-20230331141243320.png)

- 字典序

  ```
  显然的做法是先按照第一个字母、以 a、b、c……z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，sigh 和 sight），那么把短者排在前。
  ```

- 假设你有一个str，里面有三种字符，那么你就去删，删的最后里面还是三种字符（你不能给我删成两种字符了），但是要求字典序最小。
- 其实删除的顺序等价于一个挑选的次序。因为客观上就是你在原本的str中挑选几个下标下面的字符，这几个字符是互不相同的，并且满足挑出来的这几个字符组成的字符串字典序最小。
- 贪心流程：
  1. 首先统计词频，记在一个map里面。
  2. 然后从左往右遍历，遍历到str[i]就把map里面对应str[i]的词频-1。
  3. 假设从左往右遍历到k位置的时候第一次发现你把map中某个字符c词频减成0了，那么你就需要在0~k之间的位置挑选一个位置字符的作为你答案的第一个字符，因为在k位置往后开始挑的话你就没有c这个字符了，因为c的词频已经在k位置减成0了。0~k位置这么多字符我挑哪个作为我答案的字符呢？挑选0~k中字典序最小的，且最靠左的字符。例如0~k位置的str为dccdbc，我们就选择b。
  4. 把3.中你挑选的那个字符a的位置，假设是index位置，在str[index+1....N-1]位置中把所有的a字符去掉，重新生成一个str，回到1. ，继续挑选。直到重新生成的字符串是空串。

### 最长不重复子串

code6：

![image-20230325220727308](image/image-20230325220727308.png)

思路：动态规划！看到子串子数组，想每个位置开头的子串怎么怎么样，或者每个位置结尾的子串怎么怎么样。我们现在就求子串必须以i位置结尾的情况下， 最长的无重复字符的子串长度是多少？求出以i结尾的子串答案是什么，0~N-1的答案你都求完之后，答案就在其中。影响你i结尾往前推到多少，取决于你str[i]这个位置的字符（a）上次出现的位置，如果上一次出现字符a的位置是k，那么从i位置最多推到k-1。用map来记录每个字符最近一次出现的位置。如果dp[i-1]最多推到k位置，那么dp[i]一定也不会推超过k位置。所以dp[i]=max{dp[i-1],map.get(str[i])}，离你近的就是瓶颈，用max函数。

![image-20230325223543389](image/image-20230325223543389.png)

- 我自己在做的时候想到的是滑动窗口。--Code2718



code7：

- 给定两个数组arrx和arry，长度都为N。代表二维平面上有N个点，第i个点的x坐标和y坐标分别为arrx[i]和arry[i]，返回求一条直线最多能穿过多少个点?

如何尝试：假设二维平面总共有(a,b,c,d,e,f,g)这几个点，我们尝试直线必须经过a的情况下求一个答案，必须经过b的时候求一个答案，。。。，最终答案一定在其中。遍历一遍数组，统计和a重合的点，和a的x坐标相同的点，和a有一个斜率的点---记在一个map，key就是斜率，value就是这个线经过了几个点。共y的情况就是斜率为0的情况，也记在map里面。最后从map中取出一个最大和共x的pk，取出一个max，max+重合的点的数量就是这条线经过的点的数量。这个流程太慢了，求必须经过某个点的经过二维平面上点最多的直线，是一个N的过程，总的就是N²的过程。

重合的点算不算取决于题目。

上面的过程能不能优化一下，你在求直线必须经过c点的时候，其实a和b就不需要考虑了，因为直线经过c又经过a的情况已经在直线经过a的时候就求了一个max了。即便如此，复杂度还是O(N²)

但是这道题还有一个很大的问题就是map中的那个斜率你怎么表示？你如果用double来表示斜率，有可能因为精度误差导致你明明不是一个斜率的直线，你认为是同一个直线了。所以我们就不要把x/y算成double值当成斜率，我们把x/y记成一个字符串或者一个Node来表示斜率。但是x和y我们要约分一下，约到不能再约，例如100/300，我们就除他们的最大公约数100（辗转相处法），然后把1/3记成一个字符串“1_3”，这样可以保证万无一失。可以用一个map(分子,map(分母，次数))来统计。要注意，辗转相除法计算的时候m和n都要是正整数。负数的话你就分为规定分母上带负号还是分母上带负号。



## Interview Coding 08





### 打怪兽问题

code4：

![image-20230331155654746](image/image-20230331155654746.png)

这道题它是根据输入数据的状况看菜下饭的题。动态规划有两种猜法。

第一种尝试方法：从递归开始f(d,p,ability,index)，尝试的方式就是从左往右尝试。如果你当前的能力值小于当前index的怪兽，那么你只能贿赂。如果你的能力值大于这个怪兽，那么你可以贿赂，也可以不贿赂，依次递归你这个怪兽贿赂和不贿赂需要花多少钱，从贿赂和不贿赂中选一个最省的。base case就是来到N了，也就是没有怪兽了，那么你一块钱也不用花。

- 你不好直接憋动态规划，你就先去写递归！

但是发现上面这个递归，如果要做成一个动态规划，ability的变化范围是所有怪兽能力值的累加和，如果怪兽的能力值都很大，那么你那张二维表也就很大，你可能填不完，甚至直接溢出了！

第二种尝试方法：dp [i] [j]定义为，我从0一直**通关**到i位置，必须**严格花够j元**，所到达的最大能力是多少。多一分少一分都不行。那么dp[i] [j]一个普遍的位置如何填写呢？如果dp[i-1] [j] >= d[i]，那么dp[i] [j]=dp[i-1] [j]，也就是如果上面的格子累计的能力值够我用，那么我就继承上面格子的能力。如果上面那个格子的能力值不够，那么我说明我得贿赂这个怪兽了，也就是在贿赂了的情况下是花了j元，那么就看看dp[i-1] [j-p[i]]是不是为-1，如果不是，那么说明我们我们可以通过贿赂的方式通过这个怪兽，且dp[i] [j] =dp[i-1] [j-p[i]]+d[i]，否则就不能，不能通过就为-1。在贿赂和不贿赂的方式中选择max。最终答案就是在dp中的最后一行找到第一个不是-1的那个行号就是你最少的钱数。

这种尝试方法的二维表就是N * 钱数累加和。这种方法适合钱数不是特大的时候。

这题当时腾讯给的数据规模是，N可能是0~500，能力值可能是10~10^6，钱数是1~200。此时毫无疑问选择第二种尝试。



### 任意位置添加字符形成回文串

code6：

- 给定一个字符串，如果可以在字符串任意位置添加字符，最少添加几个能让字符串整体都是回文串。 

f(l,r)定义为，str[l...r]最少添加多少让整体都变成回文串。那么答案就是f(0,N-1)。如果这个暴力递归可以顺利写出来，改成动态规划就是一个二维表。这就是一个范围上的尝试。依然是只能l<=r，也就是说左下半区是没有用的。那么在填写dp [i] [j] 的时候，初始化我们先填第一个对角线，上面全都是0，因为自己就是一个回文串。填第二条对角线的时候，如果str对应的两个位置的字符相等就填0，如果不相等就填1。因为aa就不用添加，ab就添加一个变成aba。然后考虑dp [i] [j]怎么由dp[i-1] [j]或者dp[i] [j-1] 得到。假设从dp [i-1] [j]来的，你已经把str[i-1 ... j]变成了回文串，我们现在要str前面多了一个i位置字符，我只需要在最后一个位置添上和i位置一样的字符即可，也就是此时dp [i] [j] =dp [i-1] [j] +1 。
