# 排序算法

## 选择排序

第一步先把捣乱的数组剔除，没法排或者直接就有序。

for循环要做的就是从i到n-1上选一个最小值，并且把最小值放到i上去。我们先假设最小值的指针是minIndex（数组的下标），然后如果j位置上的值比minIndex位置上的小那么我就把j赋值给minIndex。出了for循环之后，我们就把minIndex位置上的值和i位置上的值做交换，这样完成了一趟选择。完成n-1趟选择之后数组就有序了。

外层for循环控制第几趟，内层for循环控制每一趟。

```java
public static void selectionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 0 ~ N-1  找到最小值，在哪，放到0位置上
		// 1 ~ n-1  找到最小值，在哪，放到1 位置上
		// 2 ~ n-1  找到最小值，在哪，放到2 位置上
		for (int i = 0; i < arr.length - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j < arr.length; j++) { // i ~ N-1 上找最小值的下标 
				minIndex = arr[j] < arr[minIndex] ? j : minIndex;
			}
			swap(arr, i, minIndex);
		}
	}
```

## 冒泡排序

想象一堆水下的泡泡，我从最底下开始，两两比较，小的上移，这样一来完成一趟 之后最小的就在最上面了。然后循环往复，最终实现有序。

这边的交换利用异或来实现，因为利用异或运算的交换律和结合律即可轻松证明，异或运算就是不进位相加，既然是不进位相加，那么最终某一位的结果和某一位上1的个数(奇偶)有关，所以当然满足交换和结合。可以得到一个结论：同一批数异或在一起不所谓谁先谁后，结果一定一样。**但是这边的交换要注意：i和j一定不能相等，因为这是在数组里面，如果相等那么就是在同一块内存空间来做这件事情，会把这片内存空间的数据抹成0。**

```JAVA
public static void bubbleSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 0 ~ N-1
		// 0 ~ N-2
		// 0 ~ N-3
		for (int e = arr.length - 1; e > 0; e--) { // 0 ~ e
			for (int i = 0; i < e; i++) {
				if (arr[i] > arr[i + 1]) {
					swap(arr, i, i + 1);
				}
			}
		}
	}

	// 交换arr的i和j位置上的值
	public static void swap(int[] arr, int i, int j) {
		arr[i] = arr[i] ^ arr[j];
		arr[j] = arr[i] ^ arr[j];
		arr[i] = arr[i] ^ arr[j];
	}
```

## 插入排序

> 插入排序细节的讲解与复杂度分析
> 时间复杂度O(N^2)，额外空间复杂度0(1)算法流程按照最差情况来估计时间复杂度

插入排序在完全逆序的情况下，时间复杂度是O(N²)。在完全有序的情况下，时间复杂度是O(N)。所以我们所说的时间复杂度是最差情况下的时间复杂度。大θ是平均时间复杂度，大Ω是最好时间复杂度。大O是最差。

选择排序和冒泡排序是严格的O(N²)，而插入排序在某些数据状况下并不用严格的O(N²)。

```JAVA
public class Code03_InsertionSort {

	public static void insertionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 不只1个数
		for (int i = 1; i < arr.length; i++) { // 0 ~ i 做到有序
			for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
				swap(arr, j, j + 1);
			}
		}
	}
```

第二种方法是浙江大学插牌法，而非交换。

```JAVA
public static void insertionSort_02(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int p,i;
		for (p=1;p<arr.length;p++){
			int temp = arr[p];
			for (i=p;i>0&&temp<arr[i-1];i--){
				arr[i]=arr[i-1];
			}
			arr[i]=temp;
		}
	}
```



## 归并排序 

### 代码

#### 递归

```java

    private static void mergeSort(int[] arr){
        if (arr==null||arr.length<2)
            return;
        mergeSort(arr,0,arr.length-1);
    }

    private static void mergeSort(int[] arr, int l, int r) {
        if (l>=r)return;
        int mid=l+((r-l)>>1);
        mergeSort(arr,l,mid);
        mergeSort(arr,mid+1,r);
        merge(arr,l,mid+1,r);
    }

    /**
     *
     * @param arr:在arr数组的相应下标进行merge
     * @param ls:merge的左边数组的开始下标
     * @param rs:merge的右边数组的开始下标
     * @param re：merge的右边数组的结束下标
     */
    private static void merge(int[] arr, int ls, int rs, int re) {
        int[] help =new int[re-ls+1];
        int p1=ls;
        int p2=rs;
        int i=0;//help的辅助指针
        while(p1<=rs-1&&p2<=re){
            help[i++]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];
        }
        //出来就是p1和p2有其中一个越界了，下面的两个while循环只会进入一个
        while(p1<=rs-1)
            help[i++]=arr[p1++];
        while(p2<=re)
            help[i++]=arr[p2++];
        for (i=0;i<help.length;i++){
            arr[ls+i]=help[i];
        }
    }
```



### 非递归

这个版本会对数组频繁的创建销毁

```java
 //先给用户提供一个接口
    private static void mergeSort(int [] arr){
        if (arr==null||arr.length<2)
            return;
        mergeSort(arr,0,arr.length-1);
    }
    //arr在[l,r]范围上排好序
    private static void mergeSort(int[] arr, int l, int r) {
        /**
         * 两两合并子列，子列长度一开始是1
         */
        for (int len=1;len<=arr.length;len*=2){
            mergePass(arr,l,r,len);
        }
    }

    private static void mergePass(int[] arr, int l, int r, int len) {
        /**
         * i是merge的左边的起点，rs就是i+len是merge的右边的起点，l+2len-1是右边的终点
         */
        int i=0;
        for(;i<=arr.length-2*len;i+=2*len){
            int rs=i+len;
            merge(arr,i,i+len,i+2*len-1);
        }
        if(i+len<arr.length){//说明还有两个子列
            merge(arr,i,i+len,arr.length-1);
        }
    }

    /**
     * 直接把arr中的[l,rs-1]和[rs,r]merge起来。要注意的是这里我们是的help数组是建立在merge函数里面的。
     * @param arr，数组
     * @param l ，merge的左边的起点
     * @param rs ，merge的右边的起点
     * @param r ，merge的右边的终点
     */
    private static void merge(int[] arr, int l, int rs, int r) {
        int help[]=new int[r-l+1];
        int p1=l,p2=rs;//定义2个指针一个指向左边数组的头，一个指向右边数组的头
        int i=0;//指向help数组的头
        while(p1<=rs-1&&p2<=r){
            help[i++]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];
        }
        //退出while说明有其中一个越界了
        while(p1<=rs-1){//如果左边没有越界
            help[i++]=arr[p1++];
        }
        while(p2<=r){
            help[i++]=arr[p2++];
        }
        for(i=0;i<help.length;i++){
            arr[l+i]=help[i];
        }
    }
```



这个版本不会对数组频繁销毁

```java
/**
 * 这里的while里面拷贝了两次是因为我们在merge中为了节约时间，没有把help数组里面的数组拷贝回arr
 * 所以这里反过来调用，让help的数组再传输回arr
 * @param arr
 */
private static void mergeSort(int [] arr){
    if (arr==null||arr.length<2)
        return;
    int help[] =new int[arr.length];
    int len=1;
    while(len<arr.length){
        mergePass(arr,help,len);
        len*=2;
        mergePass(help,arr,len);
        len*=2;
    }
}

private static void mergePass(int[] arr, int[] help, int len) {
    int i=0;
    for(;i<=arr.length-2*len;i+=2*len){
        merge(arr,help,i,i+len,i+2*len-1);
    }
    if (i+len<arr.length){
        merge(arr,help,i,i+len,arr.length-1);
    }else{
        while(i<arr.length){
            help[i]=arr[i++];
        }
    }
}

private static void merge(int[] arr, int[] help, int l, int rs, int r) {
    int p1=l,p2=rs;//定义2个指针一个指向左边数组的头，一个指向右边数组的头
    int i=0;
    while(p1<=rs-1&&p2<=r){
        help[i+l]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];
        i++;
    }
    //退出while说明有其中一个越界了
    while(p1<=rs-1){//如果左边没有越界
        help[i+l]=arr[p1++];
        i++;
    }
    while(p2<=r){
        help[i+l]=arr[p2++];
        i++;
    }
}
```

### 归并排序的扩展 

- 归并排序的扩展 

  小和问题和逆序对问题

  小和问题

  在一个数组中，数组中每一个数的左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和

  例子: [1,3,4,2,5] 1左边比1小的数，没有; 3左边比3小的数，1; 4左 边比4小的数，1、3; 2左边比2小的数，1; 5左边比5小的数，1、3、4、 2; 所以小和为1+1+3+1+1+3+4+2=16 

  逆序对问题  ： 在一个数组中，左边的数如果比右边的数大，则这两个数 构成一个逆序对，请打印所有逆序 对或找到逆序对的数量。

#### 分析

这道题原本是要求所有数左边比它小的数的和，既然左边的数比右边的数小，那么对于左边这个数来说，右边的数就比左边的数大。所以这个问题就变成求每一个数在右边有多少个比它大，假设这个数是n，右边有m个比它大，那么整个数组的小和的一部分就是nm。

我在归并排序merge的时候，左右指针的值比较，左侧小的时候就产生了一个小和。也就是在归并排序的merge中增加一个功能，就是当左侧的数往help数组里面放的时候就产生了一个小和，因为这时候右边指针的值比左侧的大。为什么这样不会遗漏呢？因为我在merge的过程中一定会把右侧范围扩大到整体的。为什么不重复？因为经过merge之后右侧的数已经被纳入了整体，在内部是不会重复产生小和的。只是因为左组和右组merge的时候因为左组的某一些数比右组的小才会产生新的小和。

来看3的经过：3和1merge的时候因为它是以右组的姿态参与merge，所以一定不会产生3的小和。但是merge完之后1,3会进一步和4去merge，这个时候就求出有一个数比3大了。然后1,3,4又和2，5去merge，又求出有一个数比3大，所以求解谁比3大也是不遗漏不重算的。

同理一开始1,3和4merge，4是以右组的姿态，所以不会产生关于4的小和。接下来1,3,4和2,5merge，产生了一个关于4的小和。

另外，merge的过程中是通过R-j+1来直接计算出右边有多少数比左边的这个数大。这种算法是建立在merge的两组是有序的情况下。

<img src="./image\image-20220324220939418-16521057085641.png" alt="image-20220324220939418" style="zoom:80%;" />

这道题的merge的原来归并的merge有不同的地方，也就是当i和j指向的值相等的时候我一定是拷贝右边的，因为如果我拷贝了左边了，那么我就会丢失左边的这个数的小和---我不知道右边有多少个数比它大，我还不能拷贝左边。原本的归并排序先拷贝左边是因为要保证这个排序是稳定的，但是现在我们在只需要算出小和就行，所以先拷贝右边。只有当右边的数严格的比左边的数小，我才能够算出右边有多少个数比左边这个数小。

- 我们随便拿一个数，看看它的心路历程，无论他在哪里，merge的时候只有它是属于左边的那一组才有可能产生它的小和，在一步步的merge中，求它的小和的范围是不断的往右边扩展的。所以右边一定会拓展到头，所以这个数一定不会漏算。而为什么不会漏算，因为一旦这个数和一个组合并了（也就是因为这个组产生小和了），一个组内部是不会产生小和的。只有做左组和右组PK的时候才会产生小和。对于所有的数来说都是这个过程

#### 代码

```java
private static int smallSum(int[] arr) {
    if (arr == null || arr.length < 2)
        return 0;
    return mergeSort(arr, 0, arr.length - 1);
}

private static int mergeSort(int[] arr, int l, int r) {
    if (r == l)
        return 0;
    int mid = l + ((r - l) >> 1);
    return mergeSort(arr, l, mid) + mergeSort(arr, mid + 1, r) + merge(arr, l, mid, r);
}

private static int merge(int[] arr, int l, int mid, int r) {
    int[] help = new int[r - l + 1];
    int p1 = l;
    int p2 = mid + 1;
    int i = 0;
    int res = 0;
    while (p1 <= mid && p2 <= r) {
        res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= mid)
        help[i++] = arr[p1++];
    while (p2 <= r)
        help[i++] = arr[p2++];
    for (i = 0; i < help.length; i++) {
        arr[i + l] = help[i];
    }
    return res;
}
```

### 逆序对

右边的数比左边的数小就是一个逆序对。小和问题是求右边有多少个数比左边的数大，现在的问题就是要求右边有多少数比左边的数要小。也就是merge的时候右边的数往help数组里面放的时候，逆序对就要增加了。





## 堆排序

### 堆结构

堆排序远没有堆结构重要。我们用heapsize来描述完全二叉树的大小。如果是从数组的0位置开始连续放置，i结点的左孩子是2i+1，右孩子是2i+2，父亲结点是i-1/2.如果是从1位置开始连续放置，那么左孩子就是2i，右孩子就是2i+1.父节点是i/2.

堆是特殊的完全二叉树。分为最大堆和最小堆。现在问题来了，我可以把数组连续出发的一段理解成完全二叉树，但是我怎么把数组连续出发的一段弄成堆？用户给的第一个数本身自己是最大堆，然后后面每次来一个数我就顺着放在完全二叉树的下一个结点，往上去比，调整成一个最大堆。

如果现在用户要叫你给它一个最大值，并且把最大值从堆中去掉。因为这个时候我们的size要减小，并且第一个数要删掉，所以一个很自然的想法就是把最后一个数放到0位置，我们用一个变量把0位置的数先记住--后面是要返回给用户的。现在的问题就是要把现在完全二叉树再次调整成最大堆。从头节点开始，找它的左右孩子中最大的---如果有的话，如果2i+1<=heapsieze-1的话说明至少有一个左孩子。只要向下比较，知道我没有左孩子了，或者说左孩子和右孩子中最大的都比我的小就停。

所以现在我们知道了，insert操作就是向上比较。delete操作就是把最后一个调上去然后往下比较。那么现在我们要直接把中的某一个i位置的值改变，叫你再把它调整成最大堆，我们只要知道它是变大了还是变小了就行，变大了就向上去比较，变小了就往下比较就行。

- 左程云的代码的insert就是向上调整。heapify就是向下调整。

如果用户已经给了N个数，现在要再给一个数，那么调整的代价就是logN。

> 堆
>
> 1，堆结构就是用数组实现的**完全二叉树**结构 
>
> 2，完全二叉树中如果每棵子树的最大值都在顶部就是大根堆 
>
> 3，完全二叉树中如果每棵子树的最小值都在顶部就是小根堆 
>
> 4，堆结构的heapInsert与heapify操作 
>
> 5，堆结构的增大和减少 
>
> 6，优先级队列结构，就是堆结构



---

### 分析

堆排序无非就是用户给你一个数组。你先认为堆大小就是1，也就是0下标位置的数自己构成堆。然后1~N-1位置的数一个一个insert，让堆的大小慢慢变大。这样一来就完成了堆的构建，代价是NlogN。这样一来我们构建成了最大堆，接下来我们只需要一个一个删除最大值即可，因为最大值删除之后按照我们的思路最大值是可以保存在原本的堆的最后的，而我们要的排序是从小到大，这正好符合我们的要求，随后size--让现在这个排好的最大值断掉和最大堆的联系，删除之后调整成最大堆，然后继续刚刚的操作----删掉最大值然后继续调整size--。

整个过程没有递归，没有生成大的数组结构，insert和delete方法也都是O(1)的。所以整个的堆排序的空间复杂度是O(1)。在时间复杂度是NlogN的排序里面只有堆排序能做到。

其实如果用户一次性给你一个数组，你的目标就是把这个数组调整成最大堆的结构，那么这一步有更好的方法，不需要一个一个去调整。相当于给你一个完全二叉树叫你去调整成堆的结构。我们可以把堆看成是一个根节点和子堆构成的。那么我们可以从下面开始，从最小的子堆开始，往下调整。最终整体有序。就类似于删除操作把最后一个换到第一个的往下调整的过程，因为你把最后一个换到第一个，第一个的左右两边都是子堆，都是调整好的。所以是一个思想。第一种方法就是insert的向上调整，这种方法就是delete的向下调整。

这种方法好，因为这种方法只需要一个线性的时间复杂度。叶子结点有N/2个看一眼......。快的根本原因就是向下调整的话完全二叉树的越下面结点越多，这种方法就是把更多的结点用更少的步骤解决了。

所以我们从数组的右边开始，也就是尾部开始，一个一个的向下调整。后面的操作没有变，只是把一个数组调整成一个堆的速度变快了。

![image-20220327145108284](./image\image-20220327145108284.png)

> 堆排序 
>
> 1，先让整个数组都变成大根堆结构，建立堆的过程: 1)从上到下的方法，时间复杂度为O(N*logN) 2)从下到上的方法，时间复杂度为O(N) *
>
> *2，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调 整堆，一直周而复始，时间复杂度为O(N*logN) 
>
> 3，堆的大小减小成0之后，排序完成

### 代码

```java
private static void heapSort(int[] arr){
    if (arr==null||arr.length<2)
        return;
    for (int i=arr.length-1;i>=0;i--){
        percDown(arr,i,arr.length);
    }
    for (int i=arr.length-1;i>=1;i--){
        swap(arr,0,i);//这边的i代表下标
        percDown(arr,0,i);//这边的i代表大小
    }
}

/**
 * 从i的地方开始向上调整成最大堆。不需要知道size因为向上的边界自动是0
 * @param arr
 * @param i
 */
private static void insert(int[] arr, int i) {
    int child=i,temp=arr[i];
    for (;child>0&&arr[(child-1)/2]<temp;child=(child-1)/2)
        arr[child]=arr[(child-1)/2];
    arr[child]=temp;
}

/**
 * 从index的地方向下调整成最大堆，堆的大小为size。这里需要知道size，因为我们需要确定
 * 向下调整时候的边界。
 * @param arr
 * @param index
 * @param size
 */
private static void percDown(int[] arr, int index, int size) {
    int child,parent=index,temp=arr[index];
    for (;parent*2+1<size;parent=child){//迭代如果不是唯一的，那么就需要额外变量
        child=parent*2+2<size&&arr[parent*2+2]>arr[parent*2+1]?parent*2+2:parent*2+1;
        if (temp<arr[child])
            arr[parent]=arr[child];
        else
            break;//如果temp>=arr.[child]说明找到了，退出
    }
    arr[parent]=temp;
}

private static void swap(int[] arr, int a, int b) {
    int temp=arr[a];
    arr[a]=arr[b];
    arr[b]=temp;
}
```

### 堆排序扩展

> 堆排序扩展题目 
>
> 已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元 素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的 排序算法针对这个数据进行排序。

因为每个元素移动的距离不超过k，所以数组的最小值一定在0-6的下标范围上。那么我就建立一个最小堆，每一次弹出最小的元素，放到数组的前面去，然后再从后面新增加一个数，再调整成最小堆。周而复始。时间复杂度为NlogK，因为这个k很小，甚至我们可以认为是一个O(N)的算法。

![image-20220327151043594](./image\image-20220327151043594.png)

在java中优先级队列就是最小堆---PriorityQueue，甚至都不用自己实现。这里有一个问题是扩容代价，我一共有N个数，总的扩容代价是NlogN,但是如果均摊到每一次的代价就是logN了。扩容这件事并不会影响最终的表现。

另外一点如果你使用了系统提供的对结构，那么你就只能用它给你的add和pull方法，添加一个值或者是给你弹出一个最小值并且删除它。你不能指望系统的已经在内部调整好的堆结构你给它中间某一个值改了还要他用很轻的代价像我们手写的堆结构一样去看看向上insert还是向下heapify。你就把系统的heap看成是一个黑盒，你给一个数，它给你一个数，你不要到内部去搞，这会让它搞乱，或者是调整回来的代价高。如果你自己有需求，那么就自己写一个堆。这就是为什么在很多面试场合必须要手写堆，因为在有些情景下必须要手写堆才能做到高效。

但是对于我们这道题来说，我们不涉及到要手写堆的需求，所以我们用这个黑盒就行了。

#### 代码

```java
private static void sort(int[]arr ,int k){

    PriorityQueue<Integer>heap=new PriorityQueue<>();
    int index=0;//用来放进堆
    for (;index<Math.min(arr.length,k+1);index++){
        heap.add(arr[index]);
    }
    int i=0;//用来指示排序的进度
    for (;index<arr.length;i++,index++){
        arr[i]=heap.poll();
        heap.add(arr[index]);
    }
    while(i<arr.length){
        arr[i++]=heap.poll();
    }

}
```



## 快排

### 荷兰国旗问题

#### 问题一 

- 给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的 数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N) 

思想就是小于等于区域推着大于等于区域一直往右边走，在i和小于等于区域中间的就是大于区域，当i越界了，也就是大于等于区域到数组的头了，那么我们就完成了划分。

情况1：如果arr[i]<=num，那么arr[i]和小于等于区域的下一个数做交换，小于等于区域往外扩，i++.

情况2：如果arr[i]>num，那么i++，相当于大于等于区域直接往外扩。

![image-20220327103302411](./image\image-20220327103302411.png)

```java
private static void twoArea(int []arr,int num){
    int less=-1;
    for (int i=0;i<arr.length;i++){
        if (arr[i]<=num){
            swap(arr,less+1,i);
            less++;
        }
    }
}
```



#### 问题二(荷兰国旗问题) 

- 给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放 在数组的中间，大于num的数放在数组的 右边。要求额外空间复杂度O(1)，时间复杂度 O(N)

原本小于等于区域是不分家的，现在我要把小于等于区域再分为小于区域和等于区域。小于和大于区域不要求有序但是要让数组的严格分成三块----这就是荷兰国旗问题。

思想就是在原本的基础上多一个大于区域---大于区域从数组的右边开始，小于区域从数组的左边开始。夹在中间的就是等与区域。大于区域和小于区域分别用一个变量，相等于比问题一多用了一个变量。让i从数组的头开始走，表示当前数的下标。

情况1：如果当前数arr-i比num小，那么和小于区域的下一个数交换，小于区域往右扩，i++

情况2：如果当前数arr-i与num相等，i++

情况3：如果当前数arr-i比num大，那么和大于区域的前一个数交换，大于区域往左扩，i不动。

i不动的原因是大于区域前面的数我还没有看过，i不能++。

i根据现在自己来到的数，如果等于num，那么就让等于区域直接扩充。如果i是小于区域的，那么就把i放到小于区域的下一个，把等于区域的第一个拿过来，然后扩充小于区域。相当于小于区域推着等于区域往右边走。如果这个i是大于区域的，那么就把i换到大于区域的前一个，让大于区域左扩，新来的谁重新来到i的位置，继续看。当你小于区域推着等于区域和大于区域撞上的时候就完成了。要么i左走，小于区域推着等于区域右走，要么i右走，大于区域左扩。

![image-20220327121219637](./image\image-20220327121219637.png)

```java
private static int [] flag(int []arr,int l,int r,int num){
    int less=l-1;
    int more=r+1;
    while(l<more){
        if (arr[l]<num){
            swap(arr,++less,l++);
        }else if (arr[l]>num){
            swap(arr,--more,l);
        }else {
            l++;
        }
    }
    return new int[]{less+1,more-1};
}
```



### 不改进的快速排序

> 不改进的快速排序 : 
>
> 1）把数组范围中的最后一个数作为划分值，然后把数组通过荷兰国旗问题分成三个部 分： 左侧<划分值、中间==划分值、右侧>划分值 
>
> 2）对左侧范围和右侧范围，递归执行 
>
> 分析 :
>
> 1）划分值越靠近两侧，复杂度越高；划分值越靠近中间，复杂度越低 
>
> 2）可以轻而易举的举出最差的例子，所以不改进的快速排序时间复杂度为O(N^2)

快排1.0是说，在整个数组中，我拿最后一个值做划分值。最后这个数就是我们前面的num。0-n-2位置划分成<=和>区域，划分完成之后最后这个数和>区域的第一个数做交换即可。然后让左侧和右侧重复这个行为---递归。我每次划分的时候都会有一个数被排好，所以递归下去总有有序的时候。

![image-20220327122309910](./image\image-20220327122309910.png)

快排2.0就是利用了荷兰国旗问题。一开始在整个范围上拿最后一个数num做划分，让前面的范围做到</=/>，这样让num和>num的第一个数做划分，那么我等于的区域就可以不用动了，在<和>的区域继续做递归。这种方法一次可以搞定一批数---一批等于NUN的数。

不管是快排1.0还是快排2.0时间复杂度都是O(N²)。因为我们可以举出最差的例子，在数组完全逆序或者是完全有序的时候，一次的划分只搞定了一个数。所以必然有一个快排3.0.

划分值打的很偏会产生差情况。最好的情况是划分值打在几乎中间的位置，因为这样一来左右两侧递归的规模差不多。这时候T(N)=2T(N/2)+O(N).划分值如果打偏，就会退化成N²的算法。

快排3.0，在数组l-r的范围上，我拿谁做划分？随机选一个数做划分，随机选了一个数之后我把它和最后一个数做交换，然后拿最后的这个数做划分，现在这个最后的数和1.0和2.0的最后一个数可不一样，它是我们随机选出来的数。既然是随机选的，那么好情况和坏情况就被分摊了---好坏都是概率事件。这个时候就不能构建出最坏情况了。

快排的1.0版本和2.0版本的空间复杂度是O(N)级别的，因为如果我的数据完全有序。我每次的patition之后num的位置要告诉quickSort，所以要为这个num的位置开一个int。这种情况下就要开N个int给num----开了N层。如果加了随机行为那么就退化到O(logN)。左侧递归使用的空间可以给右侧递归使用，所以主要就是看开了几层。

现在的问题就是如果我是用非递归来写的话，能不能省掉这个空间？不行！因为这个位置是我具体算出来的，我去解决子问题的时候，我先要记住母问题的这个位置，回到母问题的时候才能根据这个位置继续去解决右边的问题。所以即便改成迭代了，这个中点的位置也是要记录的，无非就是在递归里面是递归帮你压栈的，改成迭代的话就是要自己做一个栈，然后自己压栈，所以无论如何空间都没有办法省略。写递归只是因为好理解。所以这个问题变成了我划分值的位置决定了我额外空间的多少，最差是N，最好是logN，由于随机，还是一个概率的累加，最终还是收敛到logN的水平。



### 随机快速排序

> 随机快速排序（改进的快速排序） 
>
> 1）在数组范围中，等概率随机选一个数作为划分值，然后把数组通过荷兰国旗问题分 成三个部分： 左侧<划分值、中间==划分值、右侧>划分值 
>
> 2）对左侧范围和右侧范围，递归执行 
>
> 3）时间复杂度为O(N*logN)

### 代码

```java
public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}

	// arr[L..R]上，以arr[R]位置的数做划分值
	// <= X > X
	// <= X X
	public static int partition(int[] arr, int L, int R) {
		if (L > R) {
			return -1;
		}
		if (L == R) {
			return L;
		}
		int lessEqual = L - 1;
		int index = L;
		while (index < R) {
			if (arr[index] <= arr[R]) {
				swap(arr, index, ++lessEqual);
			}
			index++;
		}
		swap(arr, ++lessEqual, R);
		return lessEqual;
	}

	// arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值
	// <arr[R] ==arr[R] > arr[R]
	public static int[] netherlandsFlag(int[] arr, int L, int R) {
		if (L > R) { // L...R L>R
			return new int[] { -1, -1 };
		}
		if (L == R) {
			return new int[] { L, R };
		}
		int less = L - 1; // < 区 右边界
		int more = R; // > 区 左边界
		int index = L;
		while (index < more) { // 当前位置，不能和 >区的左边界撞上
			if (arr[index] == arr[R]) {
				index++;
			} else if (arr[index] < arr[R]) {
//				swap(arr, less + 1, index);
//				less++;
//				index++;						
				swap(arr, index++, ++less);
			} else { // >
				swap(arr, index, --more);
			}
		}
		swap(arr, more, R); // <[R]   =[R]   >[R]
		return new int[] { less + 1, more };
	}

	public static void quickSort1(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process1(arr, 0, arr.length - 1);
	}

	public static void process1(int[] arr, int L, int R) {
		if (L >= R) {
			return;
		}
		// L..R partition arr[R] [ <=arr[R] arr[R] >arr[R] ]
		int M = partition(arr, L, R);
		process1(arr, L, M - 1);
		process1(arr, M + 1, R);
	}

	
	
	
	
	
	public static void quickSort2(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process2(arr, 0, arr.length - 1);
	}

	// arr[L...R] 排有序，快排2.0方式
	public static void process2(int[] arr, int L, int R) {
		if (L >= R) {
			return;
		}
		// [ equalArea[0]  ,  equalArea[0]]
		int[] equalArea = netherlandsFlag(arr, L, R);
		process2(arr, L, equalArea[0] - 1);
		process2(arr, equalArea[1] + 1, R);
	}

	
	
	
	
	
	
	public static void quickSort3(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process3(arr, 0, arr.length - 1);
	}

	public static void process3(int[] arr, int L, int R) {
		if (L >= R) {
			return;
		}
		swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
		int[] equalArea = netherlandsFlag(arr, L, R);
		process3(arr, L, equalArea[0] - 1);
		process3(arr, equalArea[1] + 1, R);
	}
```



## 桶排序

桶排序是一个思想

### 计数排序

我们前面说的归并排序、插入排序、选择排序、冒泡排序、快速排序这些排序都是基于比较的排序。如果我现在有一个数组，数组里面是员工的年龄，年龄的话最多0-150.那么就开一个151大小的数组，下标代表年龄，数组的值代表这个年龄的员工有多少人。遇到一个员工是几岁，对应下标的位置就++。然后再把这个统计年龄的数组还原到原数组即可。但是这种排序只有在待比较的的数的范围在一个可以接受的范围内我才能做

所以说不基于比较的排序都是根据数据状况做的排序，他没有基于比较的排序有那么广的运用范围。不管是人对象还是动物对象，只要我告诉它两个对象怎么比大小就可以很自然的实现比较的排序。 不基于比较的排序路很窄，一定要根据数据状况来定制。

```java
//0~200
private static void countSort(int[] arr){
    int max=arr[0];
    for (int a:arr){
        max=a>max?a:max;
    }
    int count[]=new int[max+1];
    for (int a:arr)
        count[a]++;
    for (int i=0,j=0;i<count.length;i++){
        while(count[i]!=0){
            arr[j++]=i;
            count[i]--;
        }
    }
}
```

### 基数排序

先看最大数的位数，其它数补齐位数。是几进制就准备几个桶。然后从个位数到高位数进出进出。这种排序依然要基于数据状况，因为你要排序的东西要和进制有关系。

实际上再代码实现的时候没有真的弄了很多个桶。我只需要一个数组，利用前面计数排序先得到每一个数有多少个，然后和前面的累加，变成<=某个数的数有多少个。因为进桶的顺序是从左到右，所以出桶的顺序是从右往左（假设12,22,32,42这几个数在原来数组的相对顺序是这样的，那么它们在出2这个桶的时候就是42,32,22,12这样的顺序出桶的，这样出桶是因为我们假设是队列出桶，这样可以保证不交换，稳定）。现在我们假设<=2的数有9个，那么也就是说包括了12,22,32,42这几个数，那么这几个数只能排在数组的[5,8]，就让42排在9位置上，然后修改这个累加数组2下标的值，让它--。也就是对于任何一个数n，我去找到对应的累加数组arr[N]然后它的前一个也就是help[arr[n-1]]上就可以放数值了。

从右往左是因为我们要满足先入桶的先出，保证顺序相对位置不变。可以理解成累加之后的数组提供了某个位数是n的那一堆数的右边界，我知道右边界我当然是从原数组的右边开始遍历，这样我的相对位置才不会变。



```jAVA
private static void radixSort(int [] arr){
    if (arr==null||arr.length<2)
        return;
    int maxDigit=maxDigit(arr);
    radixSort(arr,0,arr.length-1,maxDigit);
}

private static int maxDigit(int[] arr) {
    int max=arr[0];
    boolean flag=false;
    for (int a:arr){//找arr中最大
        if (a<0) flag=true;
        if (a>max) max=a;
    }
    if (flag) return -1;//如果有小于零
    int res=0;
    while(max!=0){
        res++;
        max/=10;
    }
    return res;
}

/**
 *
 * @param arr
 * @param l
 * @param r
 * @param maxDigit:确定要出入桶几次，maxDigit是arr数组中最大的位数，个位数是1，十位是2....
 */
private static void radixSort(int[] arr, int l, int r, int maxDigit) {
    final int radix=10;
    int i,j;
    int[] help=new int[r-l+1];
    for (i=1;i<=maxDigit;i++){//进出桶的轮数控制
        int[] count=new int[radix];//十进制0-9
        for (j=l;j<=r;j++){
            count[getDigit(arr[j],i)]++;
        }
        for (j=1;j<count.length;j++){
            count[j]+= count[j-1];
        }
        for (j=r;j>=l;j--){
            help[--count[getDigit(arr[j],i)]]=arr[j];
        }
        for (j=0;j< help.length;j++){
            arr[l+j]=help[j];
        }
    }
}
```



## 排序算法的稳定性及其汇总

![image-20220331114418338](./image\image-20220331114418338.png)

## 常见的坑

归并排序变成了额外空间复杂度为1但是它会因此丧失稳定性，还不如直接用堆排序。

快排可以改成稳定的，但是会让时间复杂度变成N²，不如直接用归并。

![image-20220331114427919](./image\image-20220331114427919.png)

- 面试大坑

  我们在快排的时候是把<=左边，>的放右边，这是01标准，一个数不是小于一个划分值就是大于一个划分值。这就等同于把奇数放左边偶数放右边。也就是说这道题是要做到01标准的stable sort，快排都做不到，这是论文级别的难度。

- 稳定性

  在基础数组中稳定性没有什么用。在什么地方有用呢---非基础类型。

  有很多学生，先按照年龄排序，然后按照班级号进行排序。最后进行的班级号的排序如果是稳定的，那么在一个班级内部，也就是班级号相同的学生中是按照年龄大小来排序的，也就是说不会打乱之前的排序结果。

  ![image-20220331115342195](./image\image-20220331115342195.png)

  1. 选择排序不是稳定的。

     ![image-20220331115951385](./image\image-20220331115951385.png)

  2. 冒泡是稳定的

  3. 插入也是稳定的。

  4. 归并也是稳定的，关键就是mege的时候，左右两边相等先拷贝左边的。我们在做小和问题的时候，右边是先拷贝，所以小和问题的时候修改过的merge就没有稳定性了，但是整个排序是对的。

  5. 快排不是稳定的。两种类型的partition都做不到稳定。patition中i位置在和小于区的下一个做交换的时候就已经做不到稳定了，和选择排序道理一样。

  6. 堆排序在调整成最大堆的时候已经不能做到稳定了。堆中的结点只和自己和父亲和孩子玩，很轻易就能破坏 稳定。

  7. 计数排序和基数排序是稳定的，因为可以做到先入桶的先出桶。他们不是基于比较的排序，是一个萝卜一个坑，我只要这个桶内部次序维持好就能做到稳定。

  一般来说使用快速排序，因为通过实验，快排的常数项指标是最低的。

  如果你要稳定性，那么势必要N的空间。如果你要速度快，那么势必会失去稳定性。

  ![image-20220331121611526](./image\image-20220331121611526.png)

  



## 工程上对排序的改进

我们可以在小样本量是利用插入排序常数项低的优势，在大样本量上利用快速排序调度上的优势，综合两个排序算法，这叫做综合排序。

Java系统内部给你的排序，Arrays.Sort它发现如果你是基础类型就给你用快速排序。如果它 发现你是自己定义的非基础类型，就会给你用归并。原因就是因为稳定性。各个语言内部的排序都很复杂，因为他在利用各个排序算法的优势往一起拼装。但是一般来说都是往下面这两个角度来做优化。

![image-20220331114436721](./image\image-20220331114436721.png)