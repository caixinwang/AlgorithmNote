# 暴力递归到动态规划

![image-20220522213623215](./image\image-20220522213623215.png)

## 汉诺塔问题



![image-20220522213520843](./image/image-20220522213520843.png)

### 代码

```java
private static void Hanoi1(int n){
    LeftToRight(n);
}

private static void LeftToRight(int n){
    if (n==1){
        System.out.println("left to right");
        return;
    }
    LeftToMid(n-1);
    System.out.println("left to right");
    MidToRight(n-1);
}

private static void MidToRight(int n) {
    if (n==1){
        System.out.println("mid to right");
        return;
    }
    MidToLeft(n-1);
    System.out.println("mid to right");
    LeftToRight(n-1);
}

private static void MidToLeft(int n) {
    if (n==1){
        System.out.println("mid to left");
        return;
    }
    MidToRight(n-1);
    System.out.println("mid to left");
    RightToLeft(n-1);
}

private static void LeftToMid(int n) {
    if (n==1){
        System.out.println("left to mid");
        return;
    }
    LeftToRight(n-1);
    System.out.println("left to mid");
    RightToMid(n-1);
}

private static void RightToMid(int n) {
    if (n==1){
        System.out.println("right to mid");
        return;
    }
    RightToLeft(n-1);
    System.out.println("right to mid");
    LeftToMid(n-1);
}

private static void RightToLeft(int n) {
    if (n==1){
        System.out.println("right to left");
        return;
    }
    RightToMid(n-1);
    System.out.println("right to mid");
    MidToLeft(n-1);
}
//==========================================================================

private static void Hanoi2(int  n){
    process(n,"left","right","mid");
}

private static void  process(int n,String from,String to,String other){
    if (n==1){
        System.out.println(from+" to "+to);
        return;
    }
    process(n-1,from,other,to);
    System.out.println(from+" to "+to);
    process(n-1,other,to,from);
}
```



## 逆序一个栈

![image-20220522213709335](./image\image-20220522213709335.png)

### 代码

```java
/**
 * 抓住栈底的元素，其它的元素往下沉。利用递归栈帮我们存信息。reverse函数控制不会传空栈
 *
 * @param stack
 * @return
 */
private static int f(Stack<Integer> stack) {
    int res = stack.pop();

    if (stack.isEmpty()) {
        return res;//栈的最后一个元素返回
    } else {
        int last = f(stack);//最终会last会抓住最后一个元素
        stack.push(res);
        return last;//把最后一层递归抓到的栈底元素一路往上扔到最开始的递归
    }
}

/**
 * 从宏观的来看，空栈不用翻。先从栈底抽一个，然后把剩下的翻转，然后再放回去。
 * @param stack
 */
private static void reverse(Stack<Integer> stack) {
    if (stack.isEmpty()) {
        return;
    }
    int p=f(stack);
    reverse(stack);
    stack.push(p);
}
```



## 打印一个字符串的全部子序列

![image-20220522213730379](./image\image-20220522213730379.png)

### 代码

```java
private static List<String> subs(String str){
    char[] arr=str.toCharArray();
    String path="";
    LinkedList<String> list=new LinkedList<>();
    process(arr,0,list,path);
    return list;
}

/**
 * 在index位置分两种情况，一种是要了index位置，一种是不要index位置。
 * @param chars:这是一个固定参数
 * @param index:从index位置开始把后面的决定做完。0~index-1位置已经做好了决定
 * @param res:不需要返回值，我们把决定的结果放到res中
 * @param path:记录之前做决定的状态
 */
private static void process(char[] chars, int index, LinkedList<String> res, String path) {
    if (index==chars.length){//base case,已经把决定做好了，直接加入到res中，返回
        res.add(path);
        return;
    }
    String yes=path+ chars[index];
    process(chars,index+1,res,yes);
    String no=path;
    process(chars,index+1,res,no);
}
```





## 打印一个字符串的不重复子序列

我们把收集的容器变成set而不是list就行了。如果结果要List，我们就再把set遍历一遍。、

- 思考：如果不要你给出所有的不重复的子序列，我只要你给出不同的子序列的个数。怎么求？---动态规划

### 代码

```java
private static LinkedList<String> subsNoRepeat(String str){
    char[] arr=str.toCharArray();
    LinkedList<String> list=new LinkedList<>();
    String path="";
    HashSet<String> set=new HashSet<>();//去重
    process2(arr,0,set,path);
    for(String s :set){
        list.add(s);
    }
    return list;
}

private static void process2(char[] chars, int index, HashSet<String>res, String path) {
    if (index==chars.length){//base case,已经把决定做好了，直接加入到res中，返回
        res.add(path);
        return;
    }
    String yes=path+ chars[index];
    process2(chars,index+1,res,yes);
    String no=path;
    process2(chars,index+1,res,no);
}
```

## 打印一个字符串的全部排列

- 要注意还原现场

### 代码

```java
/**
 * @param str
 * @return
 */
private static LinkedList<String> permutation1(String str) {
    if (str == null || str.length() == 0) {
        return null;
    }
    char[] s = str.toCharArray();
    ArrayList<Character> rest = new ArrayList<>();
    for (char c : s) {
        rest.add(c);
    }
    String path = "";
    LinkedList<String> res = new LinkedList<>();
    process1(rest, path, res);
    return res;
}

/**
 * 不需要返回值，这里相当于返回值加到res里面了
 *
 * @param rest:从rest中选一个放到path中。当rest空了就说明path就是其中一个答案
 * @param path:记录之前选过的路径
 * @param res:当rest为空的时候把path放入到res中
 */
private static void process1(ArrayList<Character> rest, String path, LinkedList<String> res) {
    if (rest.isEmpty()) {//base case
        res.add(path);
        return;
    }
    for (int i = 0; i < rest.size(); i++) {
        char c = rest.get(i);
        rest.remove(i);
        process1(rest, path + c, res);//这里我们不写成path=path+c然后里面是path。如果这样写我们也需要恢复现场
        rest.add(i, c);//上面破坏了rest，这里从递归中返回需要恢复现场
    }
}


private static LinkedList<String> permutation2(String str) {
    if (str == null || str.length() == 0) {
        return null;
    }
    char[] s = str.toCharArray();
    LinkedList<String> res = new LinkedList<>();
    process2(s, 0, res);
    return res;
}

/**
 *
 * @param s:直接在s上面做操作
 * @param index:index~len-1位置选一个和index做交换
 * @param res：index走到了最后一个坐标len的时候就是一个结果
 */
private static void process2(char[] s, int index, LinkedList<String> res) {
    if (index == s.length) {
        res.add(String.valueOf(s));
    }else {
        for (int i=index;i<s.length;i++){//从这些位置中选一个和index做交换
            swap(s,index,i);
            process2(s,index+1,res);
            swap(s,index,i);
        }
    }

}

private static void swap(char[] s, int a, int b) {
    char temp=s[a];
    s[a]=s[b];
    s[b]=temp;
}
```

## 打印一个字符串的不重复的全部排列

- 也可以通过集合来实现

- 但是有一个更加优雅的实现，分支限界。在每一层的递归中用一个set记录，阻止一些分支的进行。

### 代码

```java
/**
 * 和上面的不一样的是这个版本给出的是不重复的排列
 * @param str
 * @return
 */
private static LinkedList<String> permutation3(String str){
    if (str == null || str.length() == 0) {
        return null;
    }
    char[] s = str.toCharArray();
    LinkedList<String> res = new LinkedList<>();
    process3(s, 0, res);
    return res;
}

private static void process3(char[] s, int index, LinkedList<String> res) {
    if (index == s.length) {
        res.add(String.valueOf(s));
    }else {
        boolean[] visited=new boolean[26];//26个字母，如果量大可以用集合来代替
        for (int i=index;i<s.length;i++){
            if (!visited[s[i]-'a']){
                visited[s[i]-'a']=true;
                swap(s,index,i);
                process3(s,index+1,res);
                swap(s,index,i);
            }
        }
    }
}
```

## 数字字符串转化成字母字符串

```
ConvertToLetterString
```

![image-20220523195341417](./image\image-20220523195341417.png)

![image-20220524161857455](./image\image-20220524161857455.png)

### 代码

```java
private static int number(String str){
    if (str == null || str.length() == 0) {
        return 0;
    }
    char[] s=str.toCharArray();
    return process1(s,0);
}

/**
 *
 * @param s:固定参数，参与的数字串
 * @param index:s数组0~index-1范围已经决定好。现在要返回从index~len-1范围上组织有多少方式
 * @return
 */
private static int process1(char[] s, int index) {
    if (index == s.length) {//base case，从最底层的调用返回1给上层收集
        return 1;
    }
    if (s[index]==0){
        return 0;
    }
    int ways=process1(s,index+1);
    if (index+2<=s.length&&(s[index] - 'a') * 10 + s[index + 1] - 'a' <= 26) {
        ways+=process1(s,index+2);
    }
    return ways;
}

private static int dp1(String str) {
        char[] s = str.toCharArray();
        int N = s.length;
        int[] dp = new int[N + 1];
        dp[N] = 1;
        for (int index = N - 1; index >= 0; index--) {
            //默认就是0，所以第二个if语句默认已经初始化好了
            dp[index] = dp[index + 1] + (index + 2 <= N && (s[index] - 'a') * 10 + s[index + 1] 				- 'a' <= 26 ?dp[index + 2] : 0);
        }
        return dp[0];
    }
```

##  背包问题--从左到右尝试模型

**![image-20220523195418657](./image\image-20220523195418657.png)**

很显然背包问题是有很多计算的，所以我们改成动态规划是有意义的。

回想之前背包问题，index位置是从0~n-1，但是由于在暴力递归代码里我们用index到达了n来判断结束，所以index实际上可以到达n。所以我们就让index多来一行。

二维的数组。两层for循环，暴力递归怎么调，动态规划就怎么填。

动态规划转移方程其实就是暴力尝试中是如何组织决策的。

### 代码

```java
private static int maxValue(int[] weight, int[] value, int bag) {
    if (weight == null || value == null || value.length == 0 || weight.length == 0 || bag <= 0) {
        return 0;
    }
    return process1(weight, value, 0, bag);
}

/**
 * @param weight:固定参数，代表货物的重量，数组的长度代表货物的种类，数组的长度一定和value数组的长度一样
 * @param value:固定参数，代表货物的价值
 * @param index:代表index之前的货物已经做过选择了。
 * @param rest:还剩下多少空间可以装载货物
 * @return :返回的是rest背包种类，对从index下标开始货物做选择能得到的最大价值
 */
private static int process1(int[] weight, int[] value, int index, int rest) {
    if (index == weight.length) {//base case 已经没有货物可以选了
        return 0;
    }
    int p1 = process1(weight, value, index + 1, rest);//不选index位置的货物所能得到的最大值
    int p2 = rest - weight[index] >= 0 ?
            process1(weight, value, index + 1, rest - weight[index]) + value[index] : 0;
    return Math.max(p1, p2);
}

private static int dp1(int[] weight, int[] value,int bag){
    if (weight == null || value == null || value.length == 0 || weight.length == 0 || bag <= 0) {
        return 0;
    }
    int[][] dp=new int[weight.length+1][bag+1];
    //weight.len行默认就是0，已经初始化完毕
    for (int index=weight.length-1;index>=0;index--){//index
        for (int rest=0;rest<=bag;rest++){//bag
            dp[index][rest]=Math.max(dp[index+1][rest],
                    rest - weight[index] >= 0 ? dp[index + 1][ rest - weight[index]] + value[index] : 0);
        }
    }
    return dp[0][bag];
}
```

## 拿牌的获胜者--范围上的尝试模型

![image-20220523195538262](./image\image-20220523195538262.png)

![image-20220524161911026](./image\image-20220524161911026.png)

### 代码

```java
private static int scoreOfWinner1(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int first = f1(arr, 0, arr.length - 1);
    int second = s1(arr, 0, arr.length - 1);
    return Math.max(first, second);
}

private static int f1(int[] arr, int l, int r) {
    if (r == l) {
        return arr[l];
    }
    int case1 = s1(arr, l + 1, r) + arr[l];
    int case2 = s1(arr, l, r - 1) + arr[r];
    return Math.max(case1, case2);//一定给自己最有利的情况
}

private static int s1(int[] arr, int l, int r) {
    if (r == l) {
        return 0;
    }
    int case1 = f1(arr, l + 1, r);
    int case2 = f1(arr, l, r - 1);
    return Math.min(case1, case2);//对手是坏蛋，一定给你最差的情况
}

/**
 * 使用傻缓存方法
 *
 * @param arr
 * @return
 */
private static int scoreOfWinner2(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }

    int N = arr.length;
    int dpf[][] = new int[N][N];
    int dps[][] = new int[N][N];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            dpf[i][j] = -1;
            dps[i][j] = -1;
        }
    }

    int first = f2(arr, 0, arr.length - 1, dpf, dps);
    int second = s2(arr, 0, arr.length - 1, dpf, dps);
    return Math.max(first, second);
}

private static int f2(int[] arr, int l, int r, int[][] dpf, int[][] dps) {
    if (r == l) {
        return arr[l];
    }
    if (dpf[l][r] != -1) {
        return dpf[l][r];
    }
    int case1 = s2(arr, l + 1, r, dpf, dps) + arr[l];
    int case2 = s2(arr, l, r - 1, dpf, dps) + arr[r];

    dpf[l][r] = Math.max(case1, case2);//一定给自己最有利的情况
    return dpf[l][r];
}

private static int s2(int[] arr, int l, int r, int[][] dpf, int[][] dps) {
    if (r == l) {
        return 0;
    }
    if (dps[l][r] != -1) {
        return dps[l][r];
    }
    int case1 = f2(arr, l + 1, r, dpf, dps);
    int case2 = f2(arr, l, r - 1, dpf, dps);

    dps[l][r] = Math.min(case1, case2);//对手是坏蛋，一定给你最差的情况
    return dps[l][r];
}

/**
 * 动态规划版本
 *
 * @param arr
 * @return
 */
private static int scoreOfWinner3(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int N = arr.length;
    int dpf[][] = new int[N][N];
    int dps[][] = new int[N][N];
    for (int i = 0; i < N; i++) {
        dpf[i][i] = arr[i];
    }
    for (int l = N - 2; l >= 0; l--) {//从下往上
        for (int r = l+1; r < N; r++) {//从左往右
            dpf[l][r] = Math.max(dps[l + 1][r] + arr[l], dps[l][r - 1] + arr[r]);
            dps[l][r] = Math.min(dpf[l + 1][r], dpf[l][r - 1]);
        }
    }
    return Math.max(dps[0][N - 1], dpf[0][N - 1]);

}
```



## 人过河问题

![image-20220523195604498](./image\image-20220523195604498.png)



## 海盗分硬币问题

![image-20220523195628625](./image\image-20220523195628625.png)



## 村内送信问题

![image-20220523195655511](./image\image-20220523195655511.png)





## N皇后问题

- 题目：N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列,也不在同一条斜线上给定一个整数n,返回n皇后的摆法有多少种。

  n=1，返回1

  n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0

  n=8，返回92

- 方法：

  规定每一行只能放一个皇后，也只能这样

  每一行皇后的位置，横纵坐标记在一个结构里。每一行有一个结构。每次要新增加一个皇后都要和之前所有的皇后都不共行也不共列。如果发现某一层没有皇后可以摆了，那么就退到上一层去，让上一层的皇后换地方。

  这里的结构使用一个数组即可，数组的下标代表行数，数组的值代表列数。

  Process1的返回值的含义代表前面皇后是那样摆的情况下能摆出多少种。

- 如何验证皇后不打架。在我们的设定中，皇后一定不同行，所以我们不需要验证皇后共行问题。我们验证共列问题。共斜线问题：(a,b)和(c,d)只要满足|a-c|==|b-d|即可。



- 算法常数项的改进。 位运算。

![image-20220523213031388](./image\image-20220523213031388.png)

  ### 代码

  

```java
private static int num1(int n) {//n皇后
    if (n < 1) {
        return 0;
    }
    int[] record = new int[n];
    return process1(n, 0, record);
}

/**
 * @param n:总共有n个皇后要排
 * @param index:目前已经把0~index-1的皇后排好了，现在要看看在之前决策的基础上，从index~n-1有多少种排法 index对应于行
 * @param record:index之前的皇后的布局放置在record中，用来判断index位置的皇后能放在哪里         record[i]=j代表的是第i行的皇后放在了j列位置
 * @return :返回从index~n-1有多少种排法---在之前的基础上
 */
private static int process1(int n, int index, int[] record) {
    if (index == n) {//顶层递归收集底层递归的这些1
        return 1;
    }
    int sum = 0;
    for (int i = 0; i < n; i++) {
        if (isOk(record, index, i)) {
            record[index] = i;
            sum += process1(n, index + 1, record);
        }
    }
    return sum;
}

/**
 * @param record:0~index-1的皇后在棋盘上的位置
 * @param index:index行想放入一个皇后
 * @param colum:判断把皇后放在index行的colum位置可不可行。
 * @return
 */
private static boolean isOk(int[] record, int index, int colum) {
    boolean ok = true;
    for (int i = 0; i < index; i++) {
        if (record[i] == colum || index - i == Math.abs(colum - record[i])) {
            ok = false;
            break;
        }
    }
    return ok;
}

private static int num2(int n) {
    if (n < 1) {
        return 0;
    }
    int limit = (1 << n) - 1;
    return process2(limit, 0, 0, 0);
}

/**
 *
 * @param limit:对于n皇后问题所对应的特定限制
 * @param col:列限制
 * @param left:左斜线限制
 * @param right:右斜线限制
 * @return:
 */
private static int process2(int limit, int col, int left, int right) {
    if (col==limit){
        return 1;
    }
    int sum=0;//累加种数
    int pos=~(col|left|right)&limit;//limit作用是让未越界的位保持不变，越界的位清零，因为我们我们要从右到左一个一个取1
    int mostRightOne=0;
    while(pos!=0){
        mostRightOne=(~pos+1)&pos;//pos最右边的1被我们拿到
        pos-=mostRightOne;
        sum+=process2(limit,col|mostRightOne,(left|mostRightOne)<<1,(right|mostRightOne)>>1);
    }
    return sum;
}
```



## 套路

![image-20220524161923223](./image\image-20220524161923223.png)



## 动态规划

- 怎么尝试—件事?
  1)有经验但是没有方法论?
  2)怎么判断一个尝试就是最优尝试?
  3)难道尝试这件事真的只能拼天赋?那我咋搞定我的面试?

  4)动态规划是啥?好高端的样子哦…和尝试有什么关系?
  后面给你带来最强的私货! ->暴力递归到动态规划的套路!解决任何面试中的动态规划问题!

- 什么暴力递归可以继续优化?
  有重复调用同一个子问题的解,这种递归可以优化
  如果每一个子问题都是不同的解，无法优化也不用优化

- 常见的4种尝试模型
  1)从左往右的尝试模型
  2)范围上的尝试模型
  3)多样本位置全对应的尝试模型
  4)寻找业务限制的尝试模型

## 机器人走路问题

- 题目：假设有排成一行的N个位置，记为1~N，N一定大于或等于2

  开始时机器人在其中的M位置上(M一定是1~N中的一个)

  如果机器人来到1位置，那么下一步只能往右来到2位置;

  如果机器人来到N位置，那么下一步只能往左来到N-1位置;

  如果机器人来到中间位置，那么下一步可以往左走或者往右走;

  规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个)的方法有多少种给定四个参数N、M、K、P，返回方法数。



- 我们有一种暴力递归的写法。但是这种写法会有上面所说的重复计算问题，这里可以优化，我们可以把之前计算得到过的放到一个缓存里面。暴力递归函数有两个可变参数，那么我们就准备一个二维数组，存入可变参数对的答案。这个优化就是动态规划。这是动态规划里面最粗糙的一种解法，叫做记忆化搜索。这是一种傻缓存的形式
- 动态规划实际上就是把参数的组合弄成结构化的缓存。缓存里面的依赖关系就来自于某一个暴力递归。能改成动态规划的暴力递归一定是有很多重复计算的。一旦已经写出了暴力递归就已经不用管原始题意了，根据递归就可以直接改成动态规划。

### 代码

```java
private static int ways(int n, int start, int end, int k){
    if (n<=1||start>n-1||start<0||end>n-1||end<0||k<0){
        return 0;
    }
    return process1(n,start,end,k);
}

private static int process1(int n, int cur, int end, int rest) {
    if (rest==0){//base case，上层收集这些1
        return cur==end?1:0;
    }
    int goLeft=cur>0?process1(n, cur-1, end, rest-1):0;
    int goRight=cur<n-1?process1(n, cur+1, end, rest-1):0;
    return goLeft+goRight;
}

private static int ways2(int n, int start, int end, int k){
    if (n<=1||start>n-1||start<0||end>n-1||end<0||k<0){
        return 0;
    }
    int [][]dp=new int[n][k+1];//0~n-1  0~k
    for (int i=0;i<dp.length;i++){
        for (int j=0;j<dp[0].length;j++){
            dp[i][j]=-1;
        }
    }
    return process2(n,start,end,k,dp);


}

private static int process2(int n, int cur, int end, int rest, int[][] dp) {
    if (rest==0){//base case，上层收集这些1
        return cur==end?1:0;
    }
    if (dp[cur][rest] != -1) {
        return dp[cur][rest];
    }
    int goLeft=cur>0?process1(n, cur-1, end, rest-1):0;
    int goRight=cur<n-1?process1(n, cur+1, end, rest-1):0;
    dp[cur][rest]=goLeft+goRight;
    return goLeft+goRight;
}

private static int ways3(int n, int start, int end, int k){
    if (n<=1||start>n-1||start<0||end>n-1||end<0||k<0){
        return 0;
    }
    int dp[][]=new int[n][k+1];//[cur][rest]
    dp[end][0]=1;//rest=0已经初始化
    for (int rest=1;rest<=k;rest++){
        for (int cur=0;cur<n;cur++){
            int goLeft=cur>0?dp[cur-1][rest-1]:0;
            int goRight=cur<n-1?dp[cur+1][rest-1]:0;
            dp[cur][rest]= goLeft+goRight;
        }
    }
    return dp[start][k];
}
```

## 凑金额

![image-20220524161935933](./image\image-20220524161935933.png)

- 单参数的方法可以实现返回最小或者最大的硬币数量（通过计算树展开的深度）。但是没办法返回方法的总数，因为例如{2,3}凑10,2323和2233其实是同一种方法。

### 返回多少种凑成的方法--代码

```java
/**
 * @param amount:硬币的面额
 * @param aim:目标
 * @return :返回的是最少的硬币数
 */
private static int minCoins(int[] amount, int aim) {
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    return process1(amount, 0, aim);
}

/**
 * @param amount:固定参数面额
 * @param index:index之前的硬币已经决定使用多少
 * @param rest:需要用index及其往后的硬币凑成rest
 * @return :返回凑成rest需要的最少硬币
 */
private static int process1(int[] amount, int index, int rest) {
    if (index == amount.length) {//需要用返回值来区分一个调用是否合法
        return rest == 0 ? 0 : Integer.MAX_VALUE;
    }
    int min = Integer.MAX_VALUE;
    for (int i = 0; amount[index] * i <= rest; i++) {//i代表amount[index]硬币选了几个
        int next = process1(amount, index + 1, rest - amount[index] * i);
        min = Math.min(next != Integer.MAX_VALUE ? i + next : Integer.MAX_VALUE, min);
    }
    return min;
}

private static int minCoinsDp1(int[] amount, int aim) {
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    int N = amount.length;
    int[][] dp = new int[N + 1][aim + 1];//[index][rest]
    for (int rest = 1; rest <= aim; rest++) {//初始化第N行
        dp[N][rest] = Integer.MAX_VALUE;
    }
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            int min = Integer.MAX_VALUE;
            for (int i = 0; amount[index] * i <= rest; i++) {//i代表amount[index]硬币选了几个
                int next = dp[index + 1][rest - amount[index] * i];
                min = Math.min(next != Integer.MAX_VALUE ? i + next : Integer.MAX_VALUE, min);
            }
            dp[index][rest] = min;
        }
    }
    return dp[0][aim];
}

private static int minCoinsDp2(int[] amount, int aim) {
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    int N = amount.length;
    int[][] dp = new int[N + 1][aim + 1];//[index][rest]
    for (int rest = 1; rest <= aim; rest++) {//初始化第N行
        dp[N][rest] = Integer.MAX_VALUE;
    }
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            dp[index][rest] = dp[index + 1][rest];//一张都不选
            if (rest - amount[index] >= 0 && dp[index][rest - amount[index]] != Integer.MAX_VALUE) {//至少有一张的话利用空间感可以优化
                dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - amount[index]] + 1);
            }
        }
    }
    return dp[0][aim];
}
```

- minCoins  minCoinsDp1    minCoinsDp2时间比较

  ![image-20220527165559733](./image\image-20220527165559733.png)

  可以看到暴力递归的会比下面两个动态规划慢很多

- minCoinsDp1    minCoinsDp2时间比较

  ![image-20220527165800486](./image\image-20220527165800486.png)

  可以看到优化后的动态规划又比没有优化的动态规划快了很多

- 上面的这段代码是按照硬币的种类来展开递归的，递归的深度就是硬币的种类数



```java
/**
 * 用另一种递归过程来实现。每一层按照是否能够使用每一种硬币来展开，每层都只能使用一个.这种递归方式会导致调用得很深
 * 会有非常非常多的重复计算，数据量大的话很可能跑不完。所以一定要改成动态规划。
 *
 * @param amount:面额数组
 * @param aim:要凑成的金额
 * @return
 */
private static int minCoins2(int[] amount, int aim) {
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    return process3(amount, aim);
}

private static int process3(int[] amount, int rest) {
    if (rest == 0) {//顶层调用收集这些1
        return 0;
    }
    if (!restIsOk(amount, rest)) {
        return -1;
    }
    int min = Integer.MAX_VALUE;
    for (int coin : amount) {
        if (rest - coin >= 0) {
            int next = process3(amount, rest - coin);
            if (next == -1) {
                continue;
            }
            min = Math.min(min, 1 + process3(amount, rest - coin));
        }
    }
    return min == Integer.MAX_VALUE ? -1 : min;
}

private static boolean restIsOk(int[] amount, int rest) {//至少有一个硬币可以用
    boolean ok = false;
    for (int coin : amount) {
        if (rest >= coin) {
            ok = true;
        }
    }
    return ok;
}

private static int minCoins2Dp(int[] amount, int aim) {//最优解！！！
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    int[] dp = new int[aim + 1];
    dp[0] = 0;
    for (int rest = 1; rest <= aim; rest++) {
        if (!restIsOk(amount, rest)) {
            dp[rest]= -1;
            continue;
        }
        int min = Integer.MAX_VALUE;
        for (int coin : amount) {
            if (rest - coin >= 0) {
                int next = dp[rest - coin];
                if (next == -1) {
                    continue;
                }
                min = Math.min(min, 1 + dp[rest - coin]);
            }
        }
        dp[rest]= min == Integer.MAX_VALUE ? -1 : min;
    }
    return dp[aim];
}
```

- 这段代码是每一层都使用一个硬币来展开。递归的深度可能会非常的恐怖！所以一定一定要改成动态规划。这种暴力递归的方法速度会被上一种暴力的递归的速度慢很多！！！

- minCoins2Dp  minCoinsDp2速度进行比较

  ![image-20220527170322350](./image\image-20220527170322350.png)

  可以看到下面这一种尝试方式虽然说暴力递归的情况速度很垃圾，但是它的动态规划版本完爆上面已经改进过的动态规划版本。因为下面这种版本的变量只有rest一个。是一个二维的数组。

### 凑成最少要多少个硬币-代码

```java
/**
 *
 * @param amount:面额数组，每种硬币可以使用无数个
 * @param aim:要凑成的目标
 * @return :凑成aim一共有多少种方法
 */
private static int ways(int[] amount, int aim) {
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    return process2(amount, 0, aim);
}

/**
 * @param amount:
 * @param index:
 * @param rest:
 * @return :返回的是有多少种方法凑成rest
 */
private static int process2(int[] amount, int index, int rest) {
    if (index == amount.length) {
        return rest == 0 ? 1 : 0;
    }
    int sum = 0;
    for (int i = 0; amount[index] * i <= rest; i++) {//i代表amount[index]硬币选了几个
        int next = process2(amount, index + 1, rest - amount[index] * i);
        sum += next;
    }
    return sum;
}

private static int waysDp1(int[] amount, int aim) {
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    int N = amount.length;
    int dp[][] = new int[N + 1][aim + 1];
    dp[N][0] = 1;//第N行初始化完毕
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            int sum = 0;
            for (int i = 0; amount[index] * i <= rest; i++) {//i代表amount[index]硬币选了几个
                int next = dp[index + 1][rest - amount[index] * i];
                sum += next;
            }
            dp[index][rest] = sum;
        }
    }
    return dp[0][aim];
}

/**
 * 去for循环的方法：如果至少可以用一个硬币就可以使用规律。如果一个都不用就保留dp[index+1][rest]
 * @param amount:
 * @param aim:
 * @return
 */
private static int waysDp2(int[] amount, int aim) {
    if (amount == null || amount.length == 0 || aim < 0) {
        return 0;
    }
    int N = amount.length;
    int dp[][] = new int[N + 1][aim + 1];
    dp[N][0] = 1;//第N行初始化完毕
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            dp[index][rest]=dp[index+1][rest];
            if (rest-amount[index]>=0){
                dp[index][rest]+=dp[index][rest-amount[index]];
            }
        }
    }
    return dp[0][aim];
}
```



## 贴纸问题

![image-20220524161944339](./image\image-20220524161944339.png)

我们这里要规定每一次都先搞定原始字符串的第一个字符，防止贴纸没有符合的会导致递归跑不完。最终的结果和你先搞定那个字符是无关的。所以我可以规定每一次都先搞定第一个字符。我也可以使用一个函数来判断贴纸至少可以解决一个字符我才进去。

这个暴力递归明显有重复过程。但是这里我们只能用记忆化搜索的方式就够了，因为String参数的变化范围是无穷的，我们没有办法进行精细化。本质上动态规划就是把傻缓存细粒度结构化的样子。

- 第一种尝试的方法也是一颗多叉树展开的方法，但是是按照使用了哪一种贴纸进行的多叉树展开。我们还有第二种尝试的方法，我们按照使用了多少张某一种贴纸来展开![image-20220524165258708](./image\image-20220524165258708.png)

- 第二种尝试的方法需要有另一个参数index记录贴纸，多了一个参数，不如第一种尝试。把可变参数的数量减下来，依次增加缓存的命中率。



### 代码

```java
private static int minStickers1(String[] sticker, String aim) {
        if (sticker == null || sticker.length == 0 || aim == null) {
            return 0;
        }
        return process1(sticker, aim);
    }

    private static int process1(String[] sticker, String rest) {
        if (rest.length() == 0) {
            return 0;
        }
        int min = Integer.MAX_VALUE;
        for (String str : sticker) {
            String s = minus(rest, str);
            if (s.length() != rest.length()) {//贴纸有用才递归
                int next = process1(sticker, s);
//                if (next==Integer.MAX_VALUE){
//                    continue;
//                }
//                min=Math.min(1+next,min);
                min = next == Integer.MAX_VALUE ? min : Math.min(min, next + 1);//和上面这段可以互换
            }
        }
        return min;
    }

    /**
     * 观察到这里的减法是先转化成数组才进行的。所以自然可以想到，如果我们一开始就把贴纸和目标转化成数组的话就可以剩下转化的时间。
     *
     * @param a
     * @param b
     * @return
     */
    private static String minus(String a, String b) {//a-b
        String res = "";
        char[] charsA = a.toCharArray();
        char[] charsB = b.toCharArray();
        int[] alphabet = new int[26];
        for (char c : charsA) {
            alphabet[c - 'a']++;
        }
        for (char c : charsB) {
            alphabet[c - 'a']--;
        }
        for (int i = 0; i < alphabet.length; i++) {
            if (alphabet[i] > 0) {
                while (alphabet[i]-- != 0) {
                    res += (char) (i + 'a');
                }
            }
        }
        return res;
    }

    private static int minStickers2(String[] stickers, String aim) {
        if (stickers == null || stickers.length == 0 || aim == null) {
            return 0;
        }
        int[][] charsSticker = new int[stickers.length][26];
        for (int i = 0; i < stickers.length; i++) {//对每一个字符串
            for (char c : stickers[i].toCharArray()) {//转化成字符类型的数组，然后对此数组进行遍历
                charsSticker[i][c - 'a']++;//第i的字符串对应的特定字符的位置+1
            }
        }
        return process2(charsSticker, aim);
    }

    private static int process2(int[][] stickers, String aim) {
        if (aim.length() == 0) {
            return 0;
        }
        char[] charsAim = aim.toCharArray();
        int[] aimCount = new int[26];
        for (char c : charsAim) {
            aimCount[c - 'a']++;
        }
        int min = Integer.MAX_VALUE;
        for (int[] charsSticker : stickers) {//每张贴纸都试
            if (charsSticker[charsAim[0] - 'a'] > 0) {//目标的第一个字符先变为0.这是一步贪心。只有能消去目标的第一个字符的贴纸我才选
                int next = process2(stickers, minus2(charsSticker, aim));
                min = next == Integer.MAX_VALUE ? min : Math.min(min, next + 1);
            }
        }
        return min;
    }

    private static String minus2(int[] sticker, String rest) {
        char[] charsRest = rest.toCharArray();
        int[] restCount = new int[26];
        for (char c : charsRest) {
            restCount[c - 'a']++;
        }
        for (int i = 0; i < sticker.length; i++) {
            if (sticker[i] > 0) {
                restCount[i] -= sticker[i];
            }
        }
        String res = "";
        for (int i = 0; i < restCount.length; i++) {//对于每一个字母
            for (int j = 0; j < restCount[i]; j++) {//把字母加restCount[i]次到res上
                res += (char) (i + 'a');
            }
        }
        return res;
    }

    private static int minStickers3(String[] stickers, String aim) {
        if (stickers == null || stickers.length == 0 || aim == null) {
            return 0;
        }
        int[][] charsSticker = new int[stickers.length][26];
        for (int i = 0; i < stickers.length; i++) {//对每一个字符串
            for (char c : stickers[i].toCharArray()) {//转化成字符类型的数组，然后对此数组进行遍历
                charsSticker[i][c - 'a']++;//第i的字符串对应的特定字符的位置+1
            }
        }
        HashMap<String, Integer> dp = new HashMap<>();
        dp.put("",0);
        return process3(charsSticker, aim, dp);
    }

    private static int process3(int[][] stickers, String aim, HashMap<String, Integer> dp) {
        if (dp.containsKey(aim)){
            return dp.get(aim);
        }
        char[] charsAim = aim.toCharArray();
        int[] aimCount = new int[26];
        for (char c : charsAim) {
            aimCount[c - 'a']++;
        }
        int min = Integer.MAX_VALUE;
        for (int[] charsSticker : stickers) {//每张贴纸都试
            if (charsSticker[charsAim[0] - 'a'] > 0) {//目标的第一个字符先变为0.这是一步贪心。只有能消去目标的第一个字符的贴纸我才选
                int next = process2(stickers, minus2(charsSticker, aim));
                min = next == Integer.MAX_VALUE ? min : Math.min(min, next + 1);
            }
        }
        dp.put(aim,min);
        return min;
    }
```

## 总结

![image-20220528134326851](./image\image-20220528134326851.png)

## 两字符串最长公共子序列

![image-20220528134412297](./image\image-20220528134412297.png)





### 代码

```JAVA
    private static int longestCommonSubsequence(String a, String b) {
        if (a == null || b == null || a.length() == 0 || b.length() == 0) {
            return 0;
        }
        char[] string1 = a.toCharArray();
        char[] string2 = b.toCharArray();
        return process1(string1, a.length() - 1, string2, b.length() - 1);
    }

    /**
     * @param a:固定参数
     * @param index1:0~index1 的字符串
     * @param b:固定参数
     * @param index2:0~index2 的字符串
     * @return :返回a的0~index1的字符串和b的0~index2的字符串的最大公共子序列长度
     */
    private static int process1(char[] a, int index1, char[] b, int index2) {
        if (index1 == 0 && index2 == 0) {
            return a[index1] == b[index2] ? 1 : 0;
        } else if (index1 == 0) {
            return a[index1] == b[index2] ? 1 : process1(a, index1, b, index2 - 1);
        } else if (index2 == 0) {
            return a[index1] == b[index2] ? 1 : process1(a, index1 - 1, b, index2);
        } else {//至少都有两个字符
            //p1这里一定有一个前提条件就是a[index1]==b[index2]
            int p1 = a[index1] == b[index2] ? process1(a, index1 - 1, b, index2 - 1) + 1 : 0;//最长公共子序列的最后一个字符都在a和b的最后
            int p2 = process1(a, index1, b, index2 - 1);//最长公共子序列的最后一个字符在a不在b
            int p3 = process1(a, index1 - 1, b, index2);//最长公共子序列的最后一个字符在b不在a
            //p4这种情况可以不存在，因为p4一定小于p1,p2,p3.p2/p3的子串范围都大于p4，或者说p4已经包含在p2或者p3的决策中了。
//            int p4=process1(a,index1-1,b,index2-1);
            return Math.max(Math.max(p2, p3), p1);
        }
    }

    private static int longestCommonSubsequence2(String str1, String str2) {
        if (str1 == null || str2 == null || str1.length() == 0 || str2.length() == 0) {
            return 0;
        }
        char[] a = str1.toCharArray();
        char[] b = str2.toCharArray();
        int[][] dp = new int[str1.length()][str2.length()];
        dp[0][0] = a[0] == b[0] ? 1 : 0;
        for (int index2 = 1; index2 < b.length; index2++) {
            dp[0][index2] = a[0] == b[index2] ? 1 : dp[0][index2 - 1];
        }
        for (int index1 = 1; index1 < a.length; index1++) {
            dp[index1][0] = a[index1] == b[0] ? 1 : dp[index1 - 1][0];
        }
        for (int index1 = 1; index1 < a.length; index1++) {
            for (int index2 = 1; index2 < b.length; index2++) {
                int p1 = a[index1] == b[index2] ? dp[index1 - 1][index2 - 1] + 1 : 0;
                int p2 = dp[index1][index2 - 1];
                int p3 = dp[index1 - 1][index2];
                dp[index1][index2]= Math.max(Math.max(p2, p3), p1);
            }
        }
        return dp[str1.length() - 1][str2.length() - 1];
    }
```

## 洗咖啡杯问题

![image-20220528134449517](./image\image-20220528134449517.png)
