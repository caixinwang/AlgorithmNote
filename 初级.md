# 初级

## 位运算

- **题目：打印一个数（可正可负）在底层的二进制存储形式。**

  **例如：-1打印1111···1111，总共32个1.**

根据下图可知，总体的思想就是利用1左移i位来得到掩码，利用掩码判断第i为是0还是1.利用for循环，循环32次就可以把一个int类型的数的二进制表示打印出来。

![image-20220504181522434](./image\image-20220504181522434.png)

### 代码

```java
public static void print(int num){
        for (int i=31;i>=0;i--){//i等于31，因为从高位开始
            System.out.print((num&(1<<i))==0?"0":"1");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        print(4165454);
    }
```

## 算法

所谓的算法就是解决一个具体问题的具体流程，还有一些评价这些流程的可量化的指标。

算法的分类：1. 明确知道怎么算的流程，比如3+4。 2. 明确知道怎么尝试的流程，比如求一个数的所有的因子。

- **题目：给定一个数N，返回1!+2!+...+N!**

看下面的代码可以很明显的看出两种不同的算法的优劣。

### 代码

```java
	/**
	 * 返回1！+2！+...+N!
	 * @param N
	 * @return
	 */
	public static long f1(int N) {
		int res=0;
		for (int i=N;i>=1;i--){
			res+=factorial(i);
		}
		return res;
	}

	/**
	 * 求N!
	 * @param N:求N！，也就是返回n*(n-1)*(n-2)*...*1
	 * @return
	 */
	public static long factorial(int N) {
		int res=1;
		for (int i=N;i>=1;i--){
			res*=i;
		}
		return res;
	}

	public static long f2(int N) {
		int res=0;
		int cur=1;
		for (int i=1;i<=N;i++){
			cur*=i;//cur每次都乘上i
			res+=cur;
		}
		return res;
	}

	public static void main(String[] args) {
		int N = 10;
		System.out.println(f1(N));
		System.out.println(f2(N));
	}
```

## Java中的Math.random()

1. 首先要知道Math.random()返回的是[0,1)范围中的一个double类型的数，因为double类型是有精度的，所以Math.random()的值域是一个有限集。
2. 显而易见，Math.random()* k，其中k是一个整数，那么Math.random() *k就返回一个[0,k)范围内的double类型的数
3. 在2的基础上如果我们对Math.random()* k取整，(int)(Math.random()* k)返回的就是一个[0,k-1]范围内的一个整数。
4. 因而我们如果需要随机返回一个[0,k]上的整数，我们只需要(int)(int)(Math.random()* (k+1))

代码如下：

```java
int ans = (int) (Math.random() * K); // [0,K-1]
```



---

**题目：现在我们要写一个函数，使得任意的x∈[0,1)，[0,x)上的数出现的概率变为x²。**

解析一下为什么，如果现在要返回的数<0.3，那么说明两个Math.random()都要<0.3才行，也就是说这是两个独立的事件。也就是说最终的数要小于0.3的概率是0.3²。

```java
public static double xToXPower2() {
   return Math.max(Math.random(), Math.random());
}
```

同理，如果我们现在要让概率变成x³，那么就调用三次Math.random()，他们的最大值要<x。



---

**题目：现在我们有一个函数f，它可以在1-5上等概率返回一个整数，也就是1,2,3,4,5中等概率返回一个。现在我们要你只使用这个f函数，实现一个另一个函数g，这个函数可以从1-7上等概率返回一个。**

分析：如果我们可以实现一个01等概率发生器，那么我们可以利用01等概率发生器，等概率产生2的k次方个数---这个01等概率发生器调用k次即可。然后我们让范围之外的数回卷，让概率均摊在我们想要的数的范围上。如何实现这个01等概率发生器呢？我们只需要让12返回0,45返回1，如果是3那么就重新调用一遍f。

```java
// lib里的，不能改！
public static int f1() {
   return (int) (Math.random() * 5) + 1;
}

// 随机机制，只能用f1，
// 等概率返回0和1
public static int f2() {
   int ans = 0;
   do {//利用do-while循环进行赋值可以保证赋值的结果一定不等于3
      ans = f1();
   } while (ans == 3);
   return ans < 3 ? 0 : 1;
}

// 得到000 ~ 111 做到等概率 0 ~ 7等概率返回一个
public static int f3() {//调用三次01等概率发生器，产生的三个数分别作为二进制的第1-3位
   return (f2() << 2) + (f2() << 1) + f2();
}

// 0 ~ 6等概率返回一个
public static int f4() {
   int ans = 0;
   do {//利用do-while循环进行赋值可以保证赋值的结果一定不等于7，返回结果为0-6
      ans = f3();
   } while (ans == 7);
   return ans;
}

public static int g() {+1返回1-7
   return f4() + 1;
}
```



---

**通过上面那题，我们能不能实现由a-b的等概率发生器实现c-d的等概率发生器？**

可以的。我们假设a-b一共有奇数个数。那么我们就让中间的那个数重来。例如9-19的话就让(9+19)/2=14重来。然后do-while返回一个不等于14的数。接着如果ans<14就返回0，>14就返回1。这样我们就得到了一个01等概率发生器。然后我们实现一个0-(d-c)的等概率发生器，我们找到大于d-c的最大2次方。然后让大于d-c的数全部重算即可。

```java
/**
 * 这个函数23-43随机返回一个整数，先从0-20返回一个整数，再加上23
 * @return
 */
public static int randomInt23to43(){
   return (int)(Math.random()*(20+1))+23;
}

/**
 * 只利用randomInt23to43()函数，实现从16-39中随机返回一个整数.先实现0-23随机返回一个
 * @return
 */
public static int randomInt16to39(){
   int ans=0;
   do {
      ans=(generate01UsingRandomInt23to43()<<4)
            +(generate01UsingRandomInt23to43()<<3)
            +(generate01UsingRandomInt23to43()<<2)
            +(generate01UsingRandomInt23to43()<<1)
            +generate01UsingRandomInt23to43();
   }while(ans>23);
   return ans+16;
}

/**
 * 利用randomInt23to43实现01等概率发生器
 * @return
 */
public static int generate01UsingRandomInt23to43(){
   int ans=0;
   do {
      ans=randomInt23to43();
   }while(ans==(23+43)/2);//最终出来的ans一定不等于33
   return ans<33?0:1;
}
```



---

现在我们给你一个x函数，这个x函数不等概率的返回01，如何只利用这个x函数来构造一个y函数01等概率发生器？

我们现在调用两次，返回00和返回11的概率是不一样的。但是返回01和10的概率是一样的。所以我们只要是00或者11就重做，让概率均摊到10和01上就能实现01等概率发生器。

```java
// 你只能知道，x会以固定概率返回0和1，但是x的内容，你看不到！
public static int x() {
   return Math.random() < 0.84 ? 0 : 1;
}

// 等概率返回0和1
public static int y() {
   int ans = 0;
   do {
      ans = x();
   } while (ans == x());
   return ans;
}
```



## 动态数组

### 是什么？

规定长度不变的数组叫做固定数组。在java中有一个arrayList是一个动态数组，它也是数组。但是arraylist如果超出长度了就会进行扩容。会新开拓一个比之前长一倍的数组，然后把老数组里面的值拷贝下来。

## 扩容行为的代价？

扩容行为会不会影响ArrayList整体的表现？假设我们现在放入了n个数。那么在这期间扩容的代价是1+2+4+...+(2^k)，其中2^k是接近n的。所以整体的代价就是O(N)的。均摊到n个数，每个数放入的时候时间复杂度还是O(1).所以扩容行为对整体的性能影响不大。

## 异或运算

- 面试题（异或）：（1）在一个整型数组中只有一种数出现了奇数次，其它的所有数都出现了偶数次，怎么找到出现了奇数次的数？(2)在这个数组中如果有两种数出现了奇数次其它所有的数都出现了偶数次，怎么样找到这两种数？

> 要求时间复杂度O(N)，额外空间复杂度O(1).

### 第一问

很简单，把数组上的数从头异或到尾的结果就是唯一的出现奇数次的那个数。

```JAVA
public static void printOddTimesOneNumber(int[] arr){
        int eor=0;
        for(int i:arr)  eor^=i;//出来之后eor就是我们要的
        System.out.println(eor);
    }
```

### 第二问

```JAVA
public static void printOddTimesTwoNumber(int[] arr){
        int eor=0;
        for(int i:arr)  eor^=i;//出来之后eor=a^b
        /**
         * 我们异或了所有的数得到了eor=a^b，现在要分别得到a和b还缺少一个条件。
         * 一个思路就是不去异或所有的数，我们只异或一部分的数，并且这一部分只包含 a和b的其中一个
         * 方法是找出a与b不同的那一位，利用掩码将a和b划分成两个子集，每个子集异或进去可以达到a或者是b。
         * 问题关键来到如何找出a和b不同的那一位，事实上a^b为1的那些位都是a和b不同的位，这里我们找a^b最右边的1
         * 小结论：一个数和它的补码的与运算得到的就是最右边的那一位---想想补码是怎么求的
         */
        int mask=eor&(~eor+1);//得到了掩码
        int aORb=0,another=0 ;
        for(int i:arr)  {
            if((i&mask)==mask) aORb^=i;
        }
        another=eor^aORb;
        System.out.println(another+" "+aORb);
    }
```



## 二分法的详解与扩展

> 1）在一个有序数组中，找某个数是否存在
>
> 2）在一个有序数组中，找>=某个数最左侧的位置
>
> 3）局部最小值问题

### 1）在一个有序数组中，找某个数是否存在

```java
public static boolean exist(int [] sortedArr,int num){
    if (sortedArr.length==0||sortedArr==null)
        return false;
    int left=0,right= sortedArr.length-1,mid;
    while(left <= right){
        mid=((right-left)>>1)+left;
        if (sortedArr[mid]>num)
            right=mid-1;
        else if (sortedArr[mid] < num)
            left=mid+1;
        else
            return true;
    }
    return false;
}
```

### 2）在一个有序数组中，找>=某个数最左侧的位置

这一题和第一题的区别就是1第一题它找到了这个数（也就是满足==条件了）就返回。但是这一题当它找到了一个数>=满足条件了，还是不返回，还是接着去二分，总之一定会**二分到底**，一直到某个范围已经没有数了。

不是只有找一个数可以二分，找>=最左侧的数或者是<=最右侧的位置也可以二分

```java
private static int nearestIndex(int[] sortedArray,int num){//大于num的最小数字
    if (sortedArray==null&&sortedArray.length==0)
        return -1;
    int left=0,right=sortedArray.length-1,mid=0,index=-1;
     while(left<=right){
         mid=((right-left)>>1)+left;
         if (sortedArray[mid]>num){
             index=mid;
             right=mid-1;
         }
         else
             left=mid+1;
     }
     return index;//如果没有找到那么index就是等于-1
}
```



### 3）局部最小值问题

局部最小值说的是这样一件事：在一个数组中，arr无序，但是告诉你任何两个相邻的数不相等。要求局部最小，局部最小就是比两边小（端点只要比一个小就行）。在这样的数组中我只求一个局部最小的位置。要求时间复杂度好于O(N)。

先判断首尾是不是局部最小，如果有其中一个是局部最小那么就直接返回。如果都不是局部最小，那么0位置处导数小于0，N-1位置的导数大于0，这里说导数不科学，但是方便理解。0-1是减的趋势，N-2~N-1是增加的趋势，中间一定有一个地方会从一开始减的趋势过渡到增的趋势。然后我从中间找一个位置，假设是M，如果M不是局部最小，那么就至少比左右两边其中一边要大，比左边大就递归左边，比右边大就递归右边。最终就可以找到局部最小。并不一定只有有序才能二分，要根据具体的数据状况，二分之后能不能归结到同一类问题来求解。

优化有两种情况：一种是数据状况、一种是问题流程。数据特殊你可以优化，问题特殊你也可以优化。当构建出排他性的时候就可以二分了，当你确定左右两边和你求的问题有关，并且确定可以甩掉一边（另一边一定有）。

```java
    private static int getLessIndex(int[] arr) {//这边的数组不要求是有序数组
        if (arr.length < 2 || arr == null)
            return -1;
        if (arr[0] < arr[1])
            return 0;
        if (arr[arr.length - 1] < arr[arr.length - 2])
            return arr.length - 1;
        //left和right设为1和len-2是为了防止后面判断局部最小的时候防止越界
        int left = 1, right = arr.length - 2, mid = 0;
        while (left <= right) {
            mid = ((right - left) >> 1) + left;
            if (arr[mid] > arr[mid + 1])
                left = mid + 1;
            else if (arr[mid] > arr[mid - 1])
                right = mid - 1;
            else
                return mid;
        }
        return -1;
    }
```

## 对数器

你实现了一个想测的方法a，有一个暴力的好实现的 方法b。生成一个随机样本产生器给你产生随机数据，产生的样本分别在a和b里面跑，比对结果。具体就是两段代码拿来对数器里面一直跑，跑个几万几十万次，两个结果一定要一样。如果跑出来都是一样的，那么就说明两个方法都对了。如果不对我可以调小范围， 在对数器里面增加打印来进行调试排除错误。

这种方法可以不依赖线上测试平台就能知道写的对不对

> 对数器的概念和使用
> 1，有一个你想要测的方法a
> 2，实现复杂度不好但是容易实现的方法b3，实现一个随机样本产生器
> 4，把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
> 5，如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b
> 6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

## Master公式

子问题 等规模的递归可以用master公式。

> 剖析递归行为和递归行为时间复杂度的估算 
>
> 用递归方法找一个数组中的最大值，系统上到底是怎么做的？ 
>
> master公式的使用 
>
> T(N) = a*T(N/b) + O(N^d) 
>
> log(b,a) > d -> 复杂度为O(N^log(b,a)) 
>
> log(b,a) = d -> 复杂度为O(N^d * logN)
>
> log(b,a) < d -> 复杂度为O(N^d) 
>
> 补充阅读:www.gocalf.com/blog/algorithm-complexity-and-master- theorem.html

返回数组某一个范围上的最大值的递归算法。

```java
public static int getMax(int[] arr) {
		return process(arr, 0, arr.length - 1);
	}
public static int process(int[] arr, int L, int R) {
   if (L == R) {
      return arr[L];
   }
   int mid = L + ((R - L) >> 1);
   int leftMax = process(arr, L, mid);
   int rightMax = process(arr, mid + 1, R);
   return Math.max(leftMax, rightMax);
}
```

## 认识复杂度

### 常数操作

常数操作：数组的寻址，a=arr[i]。数组是随机存取，这边时间和数据规模无关，不管你ar有多大，算一个偏移就把数组里面的数拿出来了；加减乘除；位运算；

什么时候不是常数操作，假如有一个链表，我要得到链表i位置的值，int a=list.get(i)，那么这个就不是一个常数操作。链表要遍历去找。虽然逻辑上是线性结构，但是实际在物理上不是连续的。所以这是一个和数据量有关的操作。

和数据量无关的就是常数操作，否则就不是。

时间复杂度估计的指标在数学上就是上限。当数据量很大的时候，这个上限就成为了一个流程速度快慢的瓶颈。例如n²+99999999n+80，假如常数操作的表达式是这个，时间复杂度依然是O（n²）。

如果两个算法都是On的话就要拼常数项，但是不能只按照常数项来估计，因为同样是常熟操作，乘法操作和加法操作的时间是不一样的。所以用理论值无法估计，要实际去运行来确定哪个更好。虽然你估计出明确的常数数量，但是每一种常数操作的时间还是有差别的。

> 认识时间复杂度
>
> 常数时间的操作
>
> 一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。
>
> **时间复杂度为一个算法流程中，常数操作数量的一个指标**。常用0(读作big 0)来表示。具体来说，先要对一个算法流程非常熟悉，然后去**写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式**。
>
> 在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f(N)，那么时间复杂度为0(f(N))。
>
> **评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。**

---

当你只需要有限几个变量就能完成算法，那么这个算法的额外空间复杂度就是O（1）。如果你需要申请一个和数据量等规模的数组的时候，那么这个算法的额外空间复杂度就是O(N)。

> 选择排序、冒泡排序细节的讲解与复杂度分析时间复杂度O(N^2)，额外空间复杂度0(1)



## 比较器

Java有一个比较器接口，我们可以去完成这个接口来设计一个比较器的对象。把比较器对象传进java自带的排序函数里面即可。返回负数第一个排前面，正数第二个排前面，0的话无所谓先后。Java的比较器等同于cpp的重载运算符。

这是降序。如果是O1在前面就是升序了。传a，b------如果return b-a那么堆就变成了最大堆了。

![image-20220327154954100](./image\image-20220327154954100.png)

> 1）比较器的实质就是重载比较运算符 
>
> 2）比较器可以很好的应用在特殊标准的排序上 
>
> 3）比较器可以很好的应用在根据特殊标准排序的结构上



## 哈希表

hashmap的put方法可以是增加也可以是更新，更新的是value。同样的hashmap也可以remove一个key，把key连同它的value一起删掉。哈希表在使用的时候认为时间复杂度都是常数级别---但是这个常数比较大。哈希表map和set都是一个东西，无非就是带不带value。

java里面是安值传递，你往里面放一个key，它会拷贝一份放进去。你自己创建的对象就是拷贝它的引用--内存地址进去。

![image-20220331124412199](./image\image-20220331124412199.png)

## 有序表

在Java里面叫做，treemap和treeset。map和set的区别就在于key带不带伴随。有序表的意思就是内部按照key来组织有序的。也就是哈希表能实现的功能有序表都能实现，而且有序表还能根据key有序这件事有新的功能--增加了一些新的API。性能上比哈希表要差一点，哈希表不管是什么数据量，增删改查都是常数级别的。但是有序表增删改查都是logN级别的。

放入有序表的东西，如果不是基础类型，必须要提供比较器，因为有序表需要利用到比较。

![image-20220331124419872](./image\image-20220331124419872.png)

## 有序表的操作

![image-20220331124427586](./image\image-20220331124427586.png)