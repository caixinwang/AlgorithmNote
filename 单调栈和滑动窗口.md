# 滑动窗口

> 滑动窗口是什么?滑动窗口是—种想象出来的数据结构:
> 
> ​	滑动窗口有左边界L和有边界R
> ​	在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分
> ​	L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口
> ​	L和R都只能往右滑

---

假如有一个数组，一开始窗口的左边界和右边界都在最左侧的位置，-1位置。没有包住任何一个数。

窗口运动遵循几个原则：

1. 右边界右移即R++，指的是新的一个数从右侧进入了窗口。
2. 左边界右移即L++，指的是已经进来的数从左侧出去了。
3. 任何时候L都要小于等于R。也就是不能跑到R的右边去。

---

每次L和R的移动都会导致窗口的状况改变。那么我如何知道每一个状况窗口的最大值或者是最小值？我能不能找一个不遍历的方法来实现这个功能。是可以的，这就是我们所说的窗口内最大值的更新结构，我做出一个结构，这个结构随着窗口的状况变化也随之变化，效果就是我每次想要达到窗口内的最大值我都能迅速的得到。

我们可以用单调双端队列（一个数可以从头进从头出，也可以从尾进从尾出）来实现这个结构---得到最大值，我们维持双端队列从头到尾是从大到小。

1. 在进数的时候也就是R++，从尾部加，如果队列为空或者前一个位置的数比自己大，那么就直接从尾部放入。如果加数的时候发现前面的数比自己小，就不停的从双端队列的尾部弹出数，直到双端队列为空或者前一个数比自己大了才从尾部进去
2. 在出数的时候也就是L++，看一下当前双端队列的头部的数是不是过期的那个数，例如L=5，L++变成了6，那么过期的那个数的下标就是5。此时看一下双端队列的头部是不是过期的那个数，如果是就弹出，如果不是就跳过，什么也不做。

这样做出来的双端队列头部的值就是我们现在窗口的最大值。可以看到，这个双端队列在进数的时候可以一直保证队列的头部是最大值。因为窗口可能会出数，所以利用L来推算出过期的数，这样就让双端队列的最左边一直保持的是不过期的（不过期说明这个数还在窗口里）最大值。

- 在R不动，L++的情况下，L位置的数过期了。此时双端队列里面的值代表的是哪些数回成为最大值的优先级---哪些位置会依次成为最大值。例如双端队列现在的情况是2,1。现在我们进入了一个3，根据我们的规则，1和2都要弹出。凭什么可以这样？因为这个时候L不动，我从L到R的最大值就是3，因为3晚过期，怎么都轮不到3前面的1和2当最大值。同理，如果下一个进来的数比3小的话例如1，我们可以把它入队，放到3的后面。因为一旦3过期了，最大值就是1了，因为这个时候只有1不是过期的。
- 值比你大，比你晚过期----直接把前面的扔了。值比你小但是比你晚过期，先留着。
- 相等也把前面的扔了
- 要把得到窗口的最小值我们只需要维持从头开始到尾部双端链表的值是从小到大就行了。
- 一个数要把从尾巴出去，要么从头出去。从尾巴出去就是后面进来了一个晚过期而且比它好的数（这个“好”取决于你要的是最大值还是最小值）。从头出去说明这个数是被过期掉的。每一个记录最多进双端队列一次，出双端队列一次。
- 窗口划过了N个数，双端队列的总代接是O（N），因为每个位置（index）最多进一次，最多出一次。平均下来每划过一个数的代价就是O（1）。
- 窗口用两个整型控制即可

## 固定大小窗口划过数组

- 题目：假设一个固定大小为W的窗口，依次划过arr。返回每一次滑出状况的最大值
  例如, arr = [4,3.5,4,3,3,6,7],W = 3

  返回:[5.5,5,4,6,7]

分析：根据前面的滑动窗口的结构，我们先让窗口滑动到R=w-1，记录下此时的最大值。之后每次都r++，l++再记录一次最大值。直到r越界了。

- java中LinkedList就是双端队列。前面在讲的时候双端队列里有index还有值。由于这里是arr，我们要值需要arr[index]即可。我一定不能只放值！！！因为我们有通过index来判断过期，有了位置我即可拿到值，也可以判断是否过期。靠近头部存放的位置所对应的值一定要是最大的。
- 窗口并不是要独立写一个数据结构才能用。只需要维持一套逻辑就能用。这道题固定窗口大小决定了过期位置是确定的。所以没有必要单独写一个L。



## 达标子数组问题

- 题目：给定一个整型数组arr，和一个整数num
  某个arr中的子数组sub，如果想达标，必须满足∶

  sub中最大值-sub中最小值<= num,
  返回arr中达标子数组的数量

### 分析

暴力解很显然，就是枚举每一个数组，看看每一个达不达标。枚举出每一个子数组-----N²，找出最大值最小值----N。合起来就是N³的解。

这里有一个隐藏条件：子数组A要满足条件，必须满足子数组A的子数组A1也要满足条件。因为子数组A如果满足条件，maxa>maxa1,mina<mina1。既然A都满足maxa-minb<=num，那么maxa1-mina1也必然<=num。

隐藏条件的拓展：如果小范围上的子数组已经不达标了，这个子数组扩充得到的大数组一定也不达标。

做法：做出两个窗口的更新结构，一个更新最大值，一个更新最小值。这样我就可以让窗口一直长大，一直到窗口不达标了我就停，不让那个会使得窗口不达标的数不进这个窗口。这样一来我们就可以知道以L开始的窗口的达标个数。然后让L往右边走，继续让R扩充，这样又可以求出L+1开始的窗口达标的有几个。有几个？----利用下标相减。

整个过程L和R不回退。代价为O（N）。



---

优化一个题有几个方向：

1. 数据状况
2. 问题本身

这题是属于两个方向结合做优化。首先要能够用窗口内最大值和最小值的更新结构的前提是它的求解流程得是一个窗口。这道题得益于我们的那两个隐藏条件。子数组达标外扩必定不达标。子数组达标，它的子数组必定达标。这样一来我们就把范围和问题本身建立了单调性-----不达标，扩大必定不达标。达标，缩小必定达标。

把范围和问题建立单调性经常可以用首尾指针或者滑动窗口写。



# 单调栈

给定一个数组，要你找出每一个数左右边离它最近的，比它小的数在哪。没有的话标记为-1。

我想求每一个位置，左边和右边离它最近的比它小的数的位置在哪这么一张表。这就是单调栈要解决的问题。

暴力解法是O（N²），单调栈可以做到O（N）。

流程：先假设这个数组没有重复值。栈底放的是比较小的数，因为这里我们要求的是左右边离最近的比它小的数。如果是要求比它大的数的话，栈底就放比较大的数。所以现在我们的栈从栈底到栈顶是从小到大的。

如果栈为空就直接进栈，如果不为空就检查目前的栈顶是不是比你小，如果比你小就直接进栈。如果比你大，那么栈顶就弹出，同时生成栈顶那个数的记录。谁让你出来的，谁就是右边离你最近的小于你的数。你底下压的是谁，谁就是左边离你最近的比你小的数。让栈顶一直弹出，弹出几个数就生成几个记录，直到这个数被放入栈中。

整个数组处理完了就开始单独处理栈里还剩下的东西。这个时候栈里的数就都没有右边离它最近比它小的数了，因为这个时候的栈里面的数是我让他弹出的，而不是因为有一个数要进来才导致它弹出的。这个数底下压的是谁，谁就是左边的最近的比它小的数。

在这一整个流程中，所有的数都是进一次出一次，所以整体的时间复杂度是O（1）。

