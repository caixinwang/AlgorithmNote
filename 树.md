# 树

## 递归序

递归序，每一个结点都回到自己三次。前中后序遍历本质上就是选择在第几次回到自己才打印。

非递归先序：1-从栈中弹出一个结点cur 2-弹出就打印 3-右左子树按顺序进栈，没有就什么也不做、

非递归后序：1-从栈中弹出一个结点cur 2-弹出就放到另外一个栈里面 3-左右子树按顺序进栈，没有就什么也不做、4- 打印所有另外一个栈里面的结点。（这里是利用栈的逆序把根右左变成了左右根）

非递归中序：1-整个树的左边界全部进栈 2-弹出就打印 3-对弹出结点的右子树重复流程。（整棵树的按照左边界分解掉了，但是右树的左边界后做）



对于二叉树来说它的先序遍历就是它的深度优先遍历。现在要看看二叉树的广度优先遍历怎么写，也就是按层来打印。

这里把上面的栈换成队列就行了，头先进，弹出就打印，先放左后放右，弹出就打印。



题目求一颗二叉树的最大宽度---也就是同层结点的最大个数。需要知道这一层是第几层还要知道这一层有多少个结点。可以利用hashmap将每一个结点和层数对应起来。分别用一个变量来记录当前在第几层。另外一个变量记录这一层有多少个结点。再来一个变量记录所有层中的最大结点数。如果当前的层和之前记录的层不一样了就说明之前那个层要和max去结算了。从新的这个层开始算。

也有不用哈希表的。我们设置三个变量，当前节点所在层的最后一个结点和下一层的最后一个结点，还有当前层。一开始当前层的最后一个结点设置为根节点，下一层的最后一个结点设置为null。根节点先进队，出来的时候先让左孩子进队，然后看看nextEnd为不为空，如果是空，就把它设置成当前入队的结点，再让右孩子进队，永远把当前入队的结点让它等于nextEnd。都入队之后，当前的结点的层就多发现了一个结点。然后看看当前结点是不是本层的最后一个结点，curEnd,如果是max就更新。然后迭代curend和nextend。

![image-20220409151640335](./image\image-20220409151640335.png)

### 代码-前中后序遍历和递归实现和非递归实现

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

public static void preOrderRecur(Node head) {
    if (head==null)
        return;
    System.out.print(head.value+" ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}

public static void inOrderRecur(Node head) {
    if (head==null)
        return;
    inOrderRecur(head.left);
    System.out.print(head.value+" ");
    inOrderRecur(head.right);
}

public static void posOrderRecur(Node head) {
    if (head==null)
        return;
    posOrderRecur(head.left);
    posOrderRecur(head.right);
    System.out.print(head.value+" ");
}

public static void preOrderUnRecur(Node head){
    System.out.print("preorder unrecur:");
    if (head==null)
        return;
    Stack<Node> stack =new Stack<>();
    stack.push(head);
    while(!stack.isEmpty()){
        head=stack.pop();
        System.out.print(head.value+" ");
        if (head.right!=null){
            stack.push(head.right);
        }
        if (head.left!=null){
            stack.push(head.left);
        }
    }
    System.out.println();
}

public static void preOrderUnRecur2(Node head){//ZheJiang
    if (head==null)
        return;
    Stack<Node> stack =new Stack<>();
    while(!stack.isEmpty()||head!=null){
        while(head!=null){
            stack.push(head);
            System.out.print(head.value+" ");
            head= head.left;
        }
        head= stack.pop();
        head=head.right;
    }
    System.out.println();
}

public static void inOrderUnRecur(Node head) {
    if (head==null)
        return;
    System.out.print("inorder unrecur:");
    Stack<Node> stack=new Stack<>();
    while(head!=null||!stack.isEmpty()){
        while(head!=null){
            stack.push(head);
            head= head.left;
        }
        head= stack.pop();
        System.out.print(head.value+" ");
        head=head.right;
    }
    System.out.println();
}

public static void posOrderUnRecur1(Node head){
    System.out.print("postorder unrecur:");
    if (head==null)
        return;
    Stack<Node> stack1=new Stack<>();
    Stack<Node> stack2=new Stack<>();
    while(head!=null||!stack1.isEmpty()){
        while(head!=null){
            stack1.push(head);
            stack2.push(head);
            head=head.right;
        }
        head=stack1.pop();
        head=head.left;
    }
    while(!stack2.isEmpty()){
        System.out.print(stack2.pop().value+" ");
    }
    System.out.println();
}

/**
 * 这里利用head来跟踪刚才打印过的结点，这样就能知道当前栈顶的结点的左子树处理完了没，右子树处理完了没。如果处理完了那么
 * 会打印孩子，这时候head也就跟踪了孩子。如果p.left!=head说明p的左孩子没处理过（注意这里p.right!=head因为右树处理完了就
 * 代表左孩子肯定处理完了），左孩子没有处理过那么我就去处理左孩子，就把左孩子压栈。如果p.right!=head那么就说明右孩子没有处理
 * 右孩子进栈。如果发现左右孩子都处理完了，那么我就打印自己。
 *
 * 代码有另外一种写法，就是先让左边界一条线压栈，然后打印，然后设置head。我们这里就是让head处理不会干扰我们的位置，
 * 这里“干扰”的含义就是不会干扰我们走逻辑分支，我们就是首先一条线左边界压栈了。head一开始是没有意义的，只要不干扰
 * 走逻辑分支1就行了。
 *
 * 核心思想就是利用head来标记现在栈顶的结点的子过程有没有完毕。
 * @param head
 */
public static void posOrderUnRecur2(Node head) {
    if (head==null)
        return;
    System.out.print("postorder unrecur :");
    Stack<Node> stack=new Stack<>();
    stack.push(head);
    Node p=null;
    while(!stack.isEmpty()){
        p= stack.peek();//瞥一眼栈顶，通过下面的逻辑分支来判断是三种情况的哪一种
        if (p.left!=null&&p.left!=head&&p.right!=head){//说明左子树还没有处理
            stack.push(p.left);
        }else if (p.right!=null&&p.right!=head){ //说明右子树没有处理
            stack.push(p.right);
        }else {//左右子树都处理完了，打印当前栈顶的结点。
            System.out.print(stack.pop().value+" ");
            head=p;//当第一次打印的时候，head才被赋予了它真正的含义
        }
    }
    System.out.println();
}

/**
 * 按照层序打印
 * @param head
 */
private static void printByLay(Node head){
    if (head==null)
        return;
    System.out.print("by lay:");
    Queue<Node> queue=new LinkedList<>();
    queue.add(head);
    while(!queue.isEmpty()){
        head=queue.poll();
        System.out.print(head.value+" ");
        if (head.left!=null){
            queue.add(head.left);
        }
        if (head.right!=null){
            queue.add(head.right);
        }
    }
    System.out.println();
}
```

### 代码-求最大宽度

```java
public static class Node {
   public int value;
   public Node left;
   public Node right;

   public Node(int data) {
      this.value = data;
   }
}

/**
 * 使用hashmap来实现最大宽度的求解
 * @param head
 * @return
 */
public static int getMaxWidth(Node head) {
   if (head==null)
      return 0;
   int max=-1;
   int curLay=1;
   int cur=0;
   Queue<Node> queue=new LinkedList<>();
   queue.add(head);
   HashMap<Node,Integer> hashMap=new HashMap<>();
   hashMap.put(head,1);
   while(!queue.isEmpty()){
      head=queue.poll();
      if (head.left!=null){
         queue.add(head.left);
         hashMap.put(head.left,curLay+1);
      }
      if (head.right!=null){
         queue.add(head.right);
         hashMap.put(head.right,curLay+1);
      }
      if (hashMap.get(head)!=curLay){
         max=Math.max(max,cur);
         curLay++;
         cur=1;
      }else{
         cur++;
      }
   }
   return max;
}

/**
 * 不使用哈希表实现最大宽度的求解，整体思路还是层序遍历
 * @param head
 * @return
 */
public static int getMaxWidth2(Node head){
   int max =-1;
   int curNum=0;
   Node cur=null;
   Node curLevel=head;//记录当前层的最后一个，一开始默认是头节点，因为头节点很自然的是第一层的最后一个结点
   Node nextLevel=null;//记录下一层的最后一个节点
   Queue<Node>queue=new LinkedList<>();
   queue.add(head);
   while(!queue.isEmpty()){
      cur=queue.poll();//每次弹出一个节点，把他的左右孩子入队（如果有的话）
      if (cur.left!=null){
         queue.add(cur.left);
         nextLevel= curLevel.left;//nextLevel的值就是最新入队的结点的值
      }
      if (cur.right!=null){
         queue.add(cur.right);
         nextLevel=curLevel.right;
      }
      curNum++;//cur的左右孩子都已经入队了之后把cur统计进当前层的结点总数
      if (cur==curLevel){//说明已经到大了当前层的最后一个结点了,结算max，并且迭代curlevel和nextlevel
         max=Math.max(max,curNum);
         curNum=0;//归零
         curLevel=nextLevel;
      }

   }
   return max;
}
```



## 判断是否是二叉搜索树

左树都比自己小右树都比自己大。

有一个方法，根据左小右大，我们用中序遍历可以保证不降序。原来打印的时机变成了和前面一个打印的结点比较的时机。我们把前面的结点用pre记下来。

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

/**
 * 二插搜索树的中序遍历打印的次序一定是非递减的，我们可以把打印行为替代为入队，然后按照从左到右一次检查
 * @param head
 * @return
 */
public static boolean isBST1(Node head) {
    if (head==null)
        return true;
    LinkedList<Node>list=new LinkedList<>();
    process1(head,list);
    int pre=Integer.MIN_VALUE;
    for (Node p:list){
        if (pre>=p.value)
            return false;
        pre=p.value;
    }
    return true;

}

/**
 * 服务isBST，作用是将以head为头的二叉搜索树以中序遍历的顺序入队
 * @param head
 * @param list
 */
public static void process1(Node head, LinkedList<Node> list) {
    if(head==null){
        return;
    }
    process1(head.left,list);
    list.add(head);
    process1(head.right,list);

}

public static boolean isBST2(Node head){
    if (head==null)
        return true;
    return process2(head).isBST;
}

/**
 * 一颗树要提供的信息有：它是不是二叉搜索树、它的最大值是多少、它的最小值是多少
 * 它是不是二插搜索树取决于它的左右子树是否都是二叉搜索树。并且根节点的值要大于左子树的最大值，小于右子树的
 * 最小值。这是一个可以递归的获取信息的过程。递归到null是一个基本情况，一个空结点我们认为它是一个二叉搜索树
 * 但是这里最大和最小值我们发现设置成什么都不合适。所以就让空节点返回一个空的Info
 */
public static class Info{
    public boolean isBST;
    public int max;
    public int min;

    public Info(boolean isBST,int max,int min){
        this.isBST=isBST;
        this.max=max;
        this.min=min;
    }
}

public static Info process2(Node head){
    if (head==null)
        return null;
    //获取信息
    Info left=process2(head.left);
    Info right=process2(head.right);
    //head的信息，要根据上面得到的左右子树的信息加工得到
    int min=head.value;//设置为自己，因为左右子树可能为空
    int max=head.value;//设置为自己，因为左右子树可能为空
    boolean isBST=true;
    //最小值，只可能出现在左子树。
    if (left!=null){
        min= left.min;
    }
    //最大值只可能出现在右子树上
    if (right!=null){
        max= right.max;
    }
    //如果出现根节点比左子树的最大值小的话说明不是二叉搜索树
    if (left!=null&&left.max>=head.value){
        isBST=false;
    }
    //如果出现根节点比右子树的最大值大的话说明不是二叉搜索树
    if (right!=null&&right.min<=head.value){
        isBST=false;
    }
    //如果左右子树中有其中一个不是二叉搜索树则整棵树都不是二叉搜索树
    if ((right!=null&& right.isBST==false)||(left!=null&& left.isBST==false)){
        isBST= false;
    }
    return new Info(isBST,max,min);
}
```

## 判断是否是完全二叉树

按照层序遍历。条件1：中间的任意结点如果有右无左那么直接返回false。条件2：在不违反条件1的情况下如果遇到了左右孩子不**双**全的情况，那么接下来的每一个结点都是叶子结点。

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

/**
 * 对层序遍历进行修改，如果发现某一个入队结点不是左右孩子健全的，那么接下来入队的结点都是叶子结点。
 * 入队的结点不能有左没右，否则就不是完全二叉树
 * @param head
 * @return
 */
public static boolean isCBT1(Node head) {
    if (head==null)
        return true;

    LinkedList<Node>list=new LinkedList<>();//队列
    list.add(head);
    boolean thing=false;//标记是否出现过左右儿子不双全的情况
    while(!list.isEmpty()){
        head= list.poll();
        if ((thing&&(head.left!=null||head.right!=null)) ||
                (head.right!=null && head.left==null)){
            return false;
        }
        if (head.left!=null){
            list.add(head.left);
        }
        if (head.right!=null){
            list.add(head.right);
        }
        if (head.left==null|| head.right==null){
            thing=true;
        }
    }
    return true;
}

public static boolean isCBT2(Node head) {
    return  process(head).isCom;
}

// 对每一棵子树，是否是满二叉树、是否是完全二叉树、高度
public static class Info {
    public boolean isCom;
    public boolean isFull;
    public int height;

    public Info(boolean isCom,boolean isFull,int height){
        this.height=height;
        this.isCom=isCom;
        this.isFull=isFull;
    }
}

public static Info process(Node head) {
    if (head==null){
        return new Info(true,true,0);
    }

    Info left=process(head.left);
    Info right=process(head.right);

    boolean isCom=false;
    boolean isFull=false;
    int height=0;

    if (left.isFull&& right.isFull&& left.height== right.height){
        isFull=true;
    }

    height=Math.max(left.height, right.height)+1;

    if (isFull){
        isCom=true;
    }else{
        if (left.isFull&& right.isFull&& left.height==right.height+1){
            isCom=true;
        }
        if (left.isFull&& right.isCom&& left.height== right.height){
            isCom=true;
        }
        if (left.isCom&& right.isFull&& left.height== right.height+1){
            isCom=true;
        }
    }
    return new Info(isCom,isFull,height);
}
```



## 判断平衡二叉树

```JAVA
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

/**
 * 利用后序遍历的递归序，在第三次返回结点的时候演算左右两边的高度是否差别小于等于1来判断是否为平衡二叉树。
 * 在这一整个过程中需要一个全局变量，这里我们使用一个数组来达到C语音中传进一个指针的效果，在上述的递归过程如果
 * 不是平衡二叉树就修改了指针的值。
 * @param head
 * @return
 */
public static boolean isBalanced1(Node head) {
    boolean[] ans=new boolean[1];
    ans[0]=true;//如果调用process过程中检测出不是平衡的就修改为false
    process1(head,ans);
    return ans[0];
}

public static int process1(Node head, boolean[] ans) {
    if (head==null)
        return 0;//空树默认高度为0
    int left=process1(head.left,ans);
    int right=process1(head.right,ans);
    if ((Math.abs(left-right))>1){
        ans[0]=false;
    }
    return Math.max(left,right)+1;
}

public static boolean isBalanced2(Node head) {
    return process(head).isBalance;
}

public static class Info{
    boolean isBalance;
    int height;

    public Info(boolean isBalance,int height){
        this.height=height;
        this.isBalance=isBalance;
    }
}

public static Info process(Node x) {
    if (x==null){//base case
        return new Info(true,0);
    }

    boolean isBalance=true;
    int height=0;

    Info left=process(x.left);
    Info right=process(x.right);

    if (!left.isBalance|| !right.isBalance){
        isBalance=false;
    }

    if (Math.abs(left.height- right.height)>1){
        isBalance=false;
    }

    height=Math.max(left.height, right.height)+1;

    return new Info(isBalance,height);

}
```



## 判断满二叉树

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

// 第一种方法
// 收集整棵树的高度h，和节点数n
// 只有满二叉树满足 : 2 ^ h - 1 == n
public static boolean isFull1(Node head) {
    Info1 res=process1(head);
    return (1<<res.height)-1== res.nodeNum;
}

public static class Info1 {
    public int nodeNum;
    public int height;

    public Info1(int nodeNum,int height){
        this.height=height;
        this.nodeNum=nodeNum;
    }
}

public static Info1 process1(Node head) {
    if (head==null){
        return new Info1(0,0);
    }

    int height=0;
    int nodeNUm=0;

    Info1 left=process1(head.left);
    Info1 right=process1(head.right);

    height= Math.max(left.height, right.height)+1;
    nodeNUm= left.nodeNum+ right.nodeNum+1;

    return new Info1(nodeNUm,height);
}

// 第二种方法
// 收集子树是否是满二叉树
// 收集子树的高度
// 左树满 && 右树满 && 左右树高度一样 -> 整棵树是满的
public static boolean isFull2(Node head) {
    return process2(head).isFull;
}

public static class Info2{
    boolean isFull;
    int height;

    public Info2(boolean isFull,int height){
        this.height=height;
        this.isFull=isFull;
    }
}

public static Info2 process2(Node head) {
    if (head==null){
        return new Info2(true,0);
    }

    boolean isFull=true;
    int height=0;

    Info2 left=process2(head.left);
    Info2 right=process2(head.right);

    height=Math.max(left.height, right.height)+1;
    isFull= left.isFull&& right.isFull&& left.height== right.height;

    return new Info2(isFull,height);
}
```



## 设计一棵树的打印函数

箭头是父函数调用给的

中间部分就是说明当前结点是如何打印的

打印的时候前面要留多少个空格是由层数决定的。

打印出来的值我们用一个String类型来表示。例如我们可以让String的长度永远是17，这样就不用担心值差距悬殊的时候会乱掉。

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

public static void printTree(Node head) {
    System.out.println("Binary Tree:");
    printInOrder(head, 0, "H", 17);
    System.out.println();
}

/**
 *我们将树逆时针旋转90°，这样一来就变成了右根左的递归序。然后我们要根据高度打印前面的空格，为了保持美观，我们将输出的值固定为
 * len长度的String，这样避免结点的值大小差距悬殊的时候破坏的了树的打印结构
 * @param head:打印以head为头的树
 * @param height:根据高度来决定行前打印的空格数
 * @param to:父亲结点调用传下来的参数，调用右子树传递"v"，调用左子树传递"^"
 * @param len:除了前面的空格，后面的打印的部分我固定为长度为len长度的String
 */
public static void printInOrder(Node head, int height, String to, int len) {
    if (head==null){
        return;
    }
    printInOrder(head.right, height+1, "v", len);

    String value=new String(to+head.value+to);
    int len1=(len-value.length())>>1;//左边的空格
    int len2=len-len1-value.length();//右边的空格
    String space1=getSpace(len1);//左边的空格
    String space2=getSpace(len2);//右边的空格
    String space3=getSpace(10*height);//和高度有关的空格
    System.out.println(space3+space1+value+space2);

    printInOrder(head.left, height+1, "^", len);

}

/**
 *
 * @param num:生成一个有num个空格的字符串
 * @return
 */
public static String getSpace(int num) {
    String space=new String(" ");
    StringBuffer buf=new StringBuffer();
    for (int i=0;i<num;i++){
        buf.append(space);
    }
    return buf.toString();
}
```



## 找最低公共祖先节点

- 给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点

就看node1往上和node2往上哪一个是最初汇聚的点。

一种方法就是我们把所有结点的父节点都记录到一个hashmap里面。然后把node1往上的祖先全部放到一个hashset里面，然后node2往上翻，第一个发现在hashset里面重复的点就是第一个相遇的结点。为什么要一个hashmap，因为这是我能够往上翻的前提。

有一个很精简的代码但是很难理解。node1和node2的所有情况就两大类。o1或者o2是另一个的公共祖先。还有一种情况就是o1o2不互为公共祖先，是通过汇聚的方式找到的。

## 找后继节点（特殊结构Node）

<img src="./image\image-20220409151732187.png" alt="image-20220409151732187" style="zoom:150%;" />

```
public static class Node {
    public int value;
    public Node left;
    public Node right;
    public Node parent;

    public Node(int data) {
        this.value = data;
    }
}

/**
 * 函数功能为找到任意一个结点x的后继结点。一种很显而易见的方法就是利用parent一直向上找，一直找到头节点，然后中序遍历找到x
 * 进而找到x的后继。但是这个一种递归序，复杂度一定是N。有一种想法就是我们能不能直接利用parent直接找到它的后继。
 * 注意到中序遍历的打印顺序是左中右。1. 如果一个结点有右孩子，那么打印完了这个结点一定是去打印右树的最左的结点。
 * 2.如果一个结点没有右孩子，那么打印完它之后就得往上找它的后继结点了，此时它是某一个结点的左子树的最后一个结点。也就是说
 * 我们要一直向上找，如果一个结点是父亲结点的右孩子就一直向上找，知道一个结点是父亲结点的左孩子就停，这个时候这个父亲节点
 * 就是之前结点的后继结点。因为这个结点是这个父亲结点的左树的最右的位置，也就是最后一个打印的位置。
 * @param node:返回node结点的后继节点
 * @return
 */
public static Node getSuccessorNode(Node node) {
    if (node==null)
        return null;
    if (node.right!=null){
        return getLeftMost(node.right);
    }else{
        while(node.parent!=null&&node.parent.right==node){//除了循环说明当前的node是它父亲的左孩子
            node=node.parent;
        }
        return node.parent;
    }
}

public static Node getLeftMost(Node node) {
    if (node==null)
        return null;
    while(node.left!=null){
        node= node.left;
    }
    return node;
}
```

## 序列化与反序列化

![image-20220409151745924](./image\image-20220409151745924.png)

```JAVA
/*
 * 二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化，
 * 以下代码全部实现了。
 * 但是，二叉树无法通过中序遍历的方式实现序列化和反序列化
 * 因为不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样。
 * 比如如下两棵树
 *         __2
 *        /
 *       1
 *       和
 *       1__
 *          \
 *           2
 * 补足空位置的中序遍历结果都是{ null, 1, null, 2, null}
 *
 * */
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

public static Queue<String> preSerial(Node head) {
    if (head==null){
        return null;
    }

    Queue<String> answer=new LinkedList<>();
    pres(head,answer);
    return answer;
}

public static void pres(Node head, Queue<String> answer) {
    if (head==null){
        answer.add(null);
    }else {
        answer.add(String.valueOf(head.value));
        pres(head.left,answer);
        pres(head.right,answer);
    }
}

public static Queue<String> inSerial(Node head){
    if (head==null){
        return null;
    }

    Queue<String> answer=new LinkedList<>();
    ins(head,answer);
    return answer;
}

public static void ins(Node head, Queue<String> answer){
    if (head==null){
        answer.add(null);
    }else {
        ins(head.left,answer);
        answer.add(String.valueOf(head.value));
        ins(head.right,answer);
    }
}

public static Queue<String> posSerial(Node head){
    if (head==null){
        return null;
    }

    Queue<String> answer=new LinkedList<>();
    poss(head,answer);
    return answer;
}

public static void poss(Node head, Queue<String> answer){
    if (head==null){
        answer.add(null);
    }else {
        poss(head.left,answer);
        poss(head.right,answer);
        answer.add(String.valueOf(head.value));
    }
}

public static Node buildByPreQueue(Queue<String> prelist){
    if (prelist==null||prelist.isEmpty()){
        return null;
    }

    return preb(prelist);
}

public static Node preb(Queue<String> prelist){
    String value=prelist.poll();//Node根据String的值来创建，只有String非空的时候才创建Node，否则Node就是空
    if (value==null){
        return null;
    }
    Node head=new Node(Integer.valueOf(value));
    head.left=preb(prelist);
    head.right=preb(prelist);
    return head;
}

public static Node buildByPosQueue(Queue<String> poslist){
    if (poslist==null||poslist.isEmpty()){
        return null;
    }
    Stack<String> stack=new Stack<>();
    while(!poslist.isEmpty()){//从栈中弹出的顺序是头右左
        stack.push(poslist.poll());
    }
    return posb(stack);
}

public static Node posb(Stack<String> posstack){
    String value=posstack.pop();
    if (value==null){
        return null;
    }
    Node head=new Node(Integer.valueOf(value));
    head.right=posb(posstack);
    head.left=posb(posstack);
    return head;

}

public static Queue<String> levelSerial(Node head){
    Queue<Node>queue=new LinkedList<>();//放结点
    Queue<String>res=new LinkedList<>();//放序列
    if (head==null){
        res.add(null);
    }else{
        res.add(String.valueOf(head.value));
        queue.add(head);
        Node p=null;
        while(!queue.isEmpty()){
            p=queue.poll();
            if (p.left!=null){
                res.add(String.valueOf(p.left.value));
                queue.add(p.left);
            }else {
                res.add(null);
            }
            if (p.right!=null){
                res.add(String.valueOf(p.right.value));
                queue.add(p.right);
            }else{
                res.add(null);
            }
        }
    }
    return res;
}

public static Node buildByLevelQueue(Queue<String> levelList){
    if (levelList==null||levelList.isEmpty()){
        return null;
    }
    Queue<Node> queue=new LinkedList<>();//装非空的Node，作用和层序遍历的队列一样
    Node head=generateNode(levelList.poll());
    if (head!=null){
        queue.add(head);
        Node p=null;
        while(!queue.isEmpty()){
            p= queue.poll();
            p.left=generateNode(levelList.poll());
            p.right=generateNode(levelList.poll());
            if (p.left!=null){
                queue.add(p.left);
            }
            if (p.right!=null){
                queue.add(p.right);
            }
        }
    }
    return head;
}

public static Node generateNode(String val){
    if (val==null)
        return null;
    return new Node(Integer.valueOf(val));
}
```



## 折纸问题

![image-20220409151751641](./image\image-20220409151751641.png)

```JAVA
public static void printAllFolds(int N) {
    process(1, N, true);
    System.out.println();
}

// 当前你来了一个节点，脑海中想象的！
// 这个节点在第i层，一共有N层，N固定不变的
// 这个节点如果是凹的话，down = T
// 这个节点如果是凸的话，down = F
// 函数的功能：中序打印以你想象的节点为头的整棵树！
public static void process(int i, int N, boolean down) {
    if (i > N) {
        return;
    }
    process(i + 1, N, true);
    System.out.print(down ? "凹 " : "凸 ");
    process(i + 1, N, false);
}
```

## 树的最大距离

- 题目：返回整棵树的最大距离。一个结点到另一个结点的最大距离就是中间要经过的节点数（算上自己）

```JAVA
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

public static int maxDistance1(Node head) {
    if (head == null) {
        return 0;
    }
    ArrayList<Node> arr = getPrelist(head);
    HashMap<Node, Node> parentMap = getParentMap(head);
    int max = 0;
    for (int i = 0; i < arr.size(); i++) {
        for (int j = i; j < arr.size(); j++) {
            max = Math.max(max, distance(parentMap, arr.get(i), arr.get(j)));
        }
    }
    return max;
}

public static ArrayList<Node> getPrelist(Node head) {
    ArrayList<Node> arr = new ArrayList<>();
    fillPrelist(head, arr);
    return arr;
}

public static void fillPrelist(Node head, ArrayList<Node> arr) {
    if (head == null) {
        return;
    }
    arr.add(head);
    fillPrelist(head.left, arr);
    fillPrelist(head.right, arr);
}

public static HashMap<Node, Node> getParentMap(Node head) {
    HashMap<Node, Node> map = new HashMap<>();
    map.put(head, null);
    fillParentMap(head, map);
    return map;
}

public static void fillParentMap(Node head, HashMap<Node, Node> parentMap) {
    if (head.left != null) {
        parentMap.put(head.left, head);
        fillParentMap(head.left, parentMap);
    }
    if (head.right != null) {
        parentMap.put(head.right, head);
        fillParentMap(head.right, parentMap);
    }
}

public static int distance(HashMap<Node, Node> parentMap, Node o1, Node o2) {
    HashSet<Node> o1Set = new HashSet<>();
    Node cur = o1;
    o1Set.add(cur);
    while (parentMap.get(cur) != null) {
        cur = parentMap.get(cur);
        o1Set.add(cur);
    }
    cur = o2;
    while (!o1Set.contains(cur)) {
        cur = parentMap.get(cur);
    }
    Node lowestAncestor = cur;
    cur = o1;
    int distance1 = 1;
    while (cur != lowestAncestor) {
        cur = parentMap.get(cur);
        distance1++;
    }
    cur = o2;
    int distance2 = 1;
    while (cur != lowestAncestor) {
        cur = parentMap.get(cur);
        distance2++;
    }
    return distance1 + distance2 - 1;
}

public static int maxDistance2(Node head) {
    return process(head).maxDistance;
}

public static class Info {
    public int maxDistance;
    public int height;

    public Info(int m, int h) {
        maxDistance = m;
        height = h;
    }

}

/**
 * 可能性分析：1. 如果最大距离经过了x，那么最大距离就是左树的高度和右树的高度之和+1
 * 2. 如果最大距离没有经过x，那么最大距离就是左右子树中最大距离中较大的那个
 * 这样我们就列出了全部的最大距离的可能性,最大距离就是1和2两种情况中最大的那个
 *
 * 高度没有可能性可言，就是左右子树中的高度较大者+1
 * @param x
 * @return
 */
public static Info process(Node x) {
    if (x==null){
        return new Info(0,0);
    }

    Info left=process(x.left);
    Info right=process(x.right);

    int maxDistance=0;
    int height=0;

    maxDistance= Math.max(Math.max(left.maxDistance,right.maxDistance), left.height+right.height+1);
    height= Math.max(left.height, right.height)+1;

    return new Info(maxDistance,height);

}
```



## 最大二叉搜索子树

```JAVA
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

public static int getBSTSize(Node head) {
    if (head == null) {
        return 0;
    }
    ArrayList<Node> arr = new ArrayList<>();
    in(head, arr);
    for (int i = 1; i < arr.size(); i++) {
        if (arr.get(i).value <= arr.get(i - 1).value) {
            return 0;
        }
    }
    return arr.size();
}

public static void in(Node head, ArrayList<Node> arr) {
    if (head == null) {
        return;
    }
    in(head.left, arr);
    arr.add(head);
    in(head.right, arr);
}

public static int maxSubBSTSize1(Node head) {
    if (head == null) {
        return 0;
    }
    int h = getBSTSize(head);
    if (h != 0) {
        return h;
    }
    return Math.max(maxSubBSTSize1(head.left), maxSubBSTSize1(head.right));
}

public static int maxSubBSTSize2(Node head) {
    if(head == null) {
        return 0;
    }
    return process(head).maxBSTSubtreeSize;
}

//递归套路需要的信息
public static class Info {
    public int maxBSTSubtreeSize;
    public boolean isAllBst;
    public int max;
    public int min;

    public Info(int maxBSTSubtreeSize, boolean isAllBst, int max, int min) {
        this.maxBSTSubtreeSize = maxBSTSubtreeSize;
        this.isAllBst = isAllBst;
        this.max = max;
        this.min = min;
    }
}

/**
 * 方法就是向左右子树要信息。
 * 可能性1.信息和x结点无关。也就是说明左右子树有至少一个为不是二叉搜索树。此时最大的二叉搜索子树大小就是左右子树的最大二插子树大小中较大的那个
 * 可能性2.信息和x结点有关。这时候就说明左右子树都是二叉搜索树。最大的二叉搜索子树就变成了以x为头的树的大小。
 *
 * @param x:返回以x为头的树的相关信息，包括了以x为头的子树是不是二叉搜索树、x为头的子树的最大值、x为头的子树的最小值、
 *         x为头的最大子搜索树的大小（结点个数）。
 * @return
 */
public static Info process(Node x) {
    if (x==null){
        return null;//返回空是因为min和max返回什么都不是很合适
    }

    Info left=process(x.left);
    Info right=process(x.right);

    int maxBSTSubtreeSize=0;
    boolean isAllBst=true;
    int max=x.value;
    int min=x.value;

    if (right!=null){
        max=Math.max(right.min,x.value);
    }
    if (left!=null){
        min=Math.min(left.max,x.value);
    }

    isAllBst= left.isAllBst&&right.isAllBst&&x.value> left.max&&x.value< right.min;

    maxBSTSubtreeSize=isAllBst? left.maxBSTSubtreeSize+ right.maxBSTSubtreeSize+1:
            Math.max(left.maxBSTSubtreeSize,right.maxBSTSubtreeSize);

    return new Info(maxBSTSubtreeSize,isAllBst,max,min);



}
```



## 派对的最大快乐值

 * 题目：派对的最大快乐值

   公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。树的头节点是公司唯一的老板。

   除老板之外的每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工(subordinates列表为空)，

   除基层员工外，每个员工都有一个或多个直接下级。

```java

public class Code15_MaxHappy {
    public static class Employee {
        public int happy;
        public List<Employee> nexts;

        public Employee(int h) {
            happy = h;
            nexts = new ArrayList<>();
        }
    }

    public static int maxHappy1(Employee boss) {
        if (boss == null) {
            return 0;
        }
        return process1(boss, false);
    }

    // 当前来到的节点叫cur，
    // up表示cur的上级是否来，
    // 该函数含义：
    // 如果up为true，表示在cur上级已经确定来，的情况下，cur整棵树能够提供最大的快乐值是多少？
    // 如果up为false，表示在cur上级已经确定不来，的情况下，cur整棵树能够提供最大的快乐值是多少？
    public static int process1(Employee cur, boolean up) {
        if (up) { // 如果cur的上级来的话，cur没得选，只能不来
            int ans = 0;
            for (Employee next : cur.nexts) {
                ans += process1(next, false);
            }
            return ans;
        } else { // 如果cur的上级不来的话，cur可以选，可以来也可以不来
            int p1 = cur.happy;
            int p2 = 0;
            for (Employee next : cur.nexts) {
                p1 += process1(next, true);
                p2 += process1(next, false);
            }
            return Math.max(p1, p2);
        }
    }

    public static int maxHappy2(Employee head) {
        Info allInfo = process(head);
        return Math.max(allInfo.no, allInfo.yes);
    }

    public static class Info {
        public int no;//x不来时候的最大快乐值
        public int yes;//x来时候的最大快乐值

        public Info(int n, int y) {
            no = n;
            yes = y;
        }
    }

    public static Info process(Employee x) {
        if(x==null){
            return new Info(0,0);
        }
        if (x.nexts.isEmpty()){
            return new Info(0,x.happy);
        }

        int no=0;
        int yes=x.happy;

        for (Employee employee:x.nexts){
            no+=Math.max(process(employee).no,process(employee).yes);
            yes+=process(employee).no;
        }

        return new Info(no,yes);
    }
```

## 前缀树

1)单个字符串中，字符从前到后的加到一棵多叉树上
2）字符放在路上，节点上有专属的数据项（常见的是pass和end值)

3）所有样本都这样添加，如果没有路就新建，如有路就复用
4)沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1
可以完成前缀相关的查询

- 每一个结点都有两个字段：pass 和 end。

  pass：如果有一个字符经过了这个结点，那么这个结点的pass值就加一

  end：如果一个字符是一个字符串的结尾，那么当前停在的结点的end值加一

- 流程：每一次添加一个字符串都从头节点开始。如果有通往某一个字符的路那么就复用。如果没有就新建。

- 作用：

  1. 可以确定一个字符串是否有被记录过，和记录过几次---end值
  2. 可以知道有多少字符串以另一个字符串作为前缀---pass值。只要你通过了我，那么你就是以我之前的路径作为前缀的。
  3. 可以在特殊题目上再前缀树的节点上增加额外的信息支持解决问题。



```java
public static class Node{
    public int pass;
    public int end;
    public Node[] next;//指路

    public Node(){
        pass=0;
        end=0;
        next=new Node[26];//假设我们只放26个字母的小写，那么我们就有26条路
    }


}

public static class Trie1 {
    public Node head;

    public Trie1(){
        head=new Node();
    }

    public void insert(String val){
        if (val==null) {
            return;
        }

        char[] arr=val.toCharArray();
        Node p=head;
        p.pass++;
        for (char a:arr){
            if (p.next[a-'a']==null){
                p.next[a-'a']=new Node();
            }
            p=p.next[a-'a'];
            p.pass++;
        }
        p.end++;
    }

    /**
     * 找val在前缀树中存入了几次。
     * 思路很简单，就是怎么加的就怎么找。
     * @param val
     * @return
     */
    public int search(String val){
        if (val==null) {
            return 0;
        }

        char[] arr=val.toCharArray();
        Node p=head;
        for(char a:arr){
            if (p.next[a-'a']==null){
                return 0;
            }
            p=p.next[a-'a'];
        }
        return p.end;
    }

    public int prefixNumber(String val){
        if (val==null){
            return 0;
        }

        char[] arr=val.toCharArray();
        Node p=head;
        for (char a:arr){
            if (p.next[a-'a']==null){
                return 0;
            }
            p=p.next[a-'a'];
        }
        return p.pass;
    }

    public void delete(String val){
        if (search(val)==0){
            return;
        }

        char[] arr=val.toCharArray();
        Node p=head;
        p.pass--;
        for (char a:arr){
            if (--p.next[a-'a'].pass==0){
                p.next[a-'a']=null;
                return;
            }
            p=p.next[a-'a'];
        }
        p.end--;
    }
}

public static class Node2 {
    public int pass;
    public int end;
    public HashMap<Integer, Node2> nexts;//26个大小的空间不够就用这个，Integer表示这条路的ASCII码值

    public Node2() {
        pass = 0;
        end = 0;
        nexts = new HashMap<>();
    }
}

public static class Trie2 {
    private Node2 root;

    public Trie2() {
        root = new Node2();
    }

    public void insert(String word) {
        if (word == null) {
            return;
        }
        char[] chs = word.toCharArray();
        Node2 node = root;
        node.pass++;
        int index = 0;
        for (int i = 0; i < chs.length; i++) {
            index = (int) chs[i];
            if (!node.nexts.containsKey(index)) {
                node.nexts.put(index, new Node2());
            }
            node = node.nexts.get(index);
            node.pass++;
        }
        node.end++;
    }

    public void delete(String word) {
        if (search(word) != 0) {
            char[] chs = word.toCharArray();
            Node2 node = root;
            node.pass--;
            int index = 0;
            for (int i = 0; i < chs.length; i++) {
                index = (int) chs[i];
                if (--node.nexts.get(index).pass == 0) {
                    node.nexts.remove(index);
                    return;
                }
                node = node.nexts.get(index);
            }
            node.end--;
        }
    }

    // word这个单词之前加入过几次
    public int search(String word) {
        if (word == null) {
            return 0;
        }
        char[] chs = word.toCharArray();
        Node2 node = root;
        int index = 0;
        for (int i = 0; i < chs.length; i++) {
            index = (int) chs[i];
            if (!node.nexts.containsKey(index)) {
                return 0;
            }
            node = node.nexts.get(index);
        }
        return node.end;
    }

    // 所有加入的字符串中，有几个是以pre这个字符串作为前缀的
    public int prefixNumber(String pre) {
        if (pre == null) {
            return 0;
        }
        char[] chs = pre.toCharArray();
        Node2 node = root;
        int index = 0;
        for (int i = 0; i < chs.length; i++) {
            index = (int) chs[i];
            if (!node.nexts.containsKey(index)) {
                return 0;
            }
            node = node.nexts.get(index);
        }
        return node.pass;
    }
}

public static class Right {

    private HashMap<String, Integer> box;

    public Right() {
        box = new HashMap<>();
    }

    public void insert(String word) {
        if (!box.containsKey(word)) {
            box.put(word, 1);
        } else {
            box.put(word, box.get(word) + 1);
        }
    }

    public void delete(String word) {
        if (box.containsKey(word)) {
            if (box.get(word) == 1) {
                box.remove(word);
            } else {
                box.put(word, box.get(word) - 1);
            }
        }
    }

    public int search(String word) {
        if (!box.containsKey(word)) {
            return 0;
        } else {
            return box.get(word);
        }
    }

    public int prefixNumber(String pre) {
        int count = 0;
        for (String cur : box.keySet()) {
            if (cur.startsWith(pre)) {
                count += box.get(cur);
            }
        }
        return count;
    }
}
```
