# 贪心算法

**贪心算法求解的标准过程**

- 1，分析业务
  2，根据业务逻辑找到不同的贪心策略
  3，对于能举出反例的策略直接跳过，不能举出反例的策略要证明有效性
- 这往往是特别困难的，要求数学能力很高且不具有统一的技巧性

**贪心算法的解题套路**

- 1，实现一个不依靠贪心策略的解法×，可以用最暴力的尝试
  2，脑补出贪心策略A、贪心策略B、贪心策略C...
  3，用解法X和对数器，用实验的方式得知哪个贪心策略正确
  4，不要去纠结贪心策略的证明

**贪心算法**

- 1)最自然智慧的算法
  2)用一种局部最功利的标准，总是做出在当前看来是最好的选择
  3)难点在于证明局部最功利的标准可以得到全局最优解
  4)对于贪心算法的学习主要以增加阅历和经验为主

## 会议室宣讲

- 一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。

  给你每一个项目开始的时间和结束的时间。

  你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回最多的宣讲场次。

发现这一题我们按照会议最短的时间来安排或者按照会议最早的时间来安排都不能得到最优解，因为我们可以找出反例。

![image-20220516144321879](./image\image-20220516144321879.png)

- 这一题的正确的贪心是按照谁最早结束就安排谁

### 代码

```java
public static class Program {
    int start;
    int end;

    public Program(int start, int end) {
        this.start = start;
        this.end = end;
    }
}

public static int bestArrange1(Program[] arr) {
    if (arr==null||arr.length==0){
        return 0;
    }
    return process1(arr,0,0);
}

/**
 *
 * @param arr:还剩下的没安排的会议
 * @param done:已经安排了几个会议
 * @param timeLine:现在来到的时间点
 * @return
 */
public static int process1(Program[] arr,int done,int timeLine){
    if (arr==null||arr.length==0){
        return 0;
    }
    int best=done;
    for (int i=0;i<arr.length;i++){
        if (arr[i].start>=timeLine){
            Program[] p=copyButExcept(arr,i);
            best=Math.max(best,process1(arr,done+1,arr[i].end));//利用递归for，让best一直更新
        }
    }
    return best;
}

public static Program[] copyButExcept(Program[] arr,int index){
    int i=0;//给p用
    Program[] p=new Program[arr.length-1];
    for (int j=0;j<arr.length;j++){//遍历arr
        if (j!=index){
            p[i++]=arr[j];
        }
    }
    return p;
}

public static int bestArrange2(Program[] arr){
    int timeLine=0;
    int best=0;
    Arrays.sort(arr,new ProgramComparator());//按照结束时间先后来排序
    for (int i=0;i<arr.length;i++){
        if (arr[i].start>=timeLine){
            best++;
            timeLine=arr[i].end;
        }
    }
    return best;
}

public static class ProgramComparator implements Comparator<Program>{
    public int compare(Program o1,Program o2){
        return o1.end-o2.end;
    }
}
```



## 放灯

- 题目：给定一个字符串str,“只由×'和∵'两种字符构成。‘×'表示墙，不能放灯，也不需要点亮
  ".'表示居民点，可以放灯，需要点亮
  如果灯放在i位置，可以让i-1， i和i+1三个位置被点亮返回如果点亮str中所有需要点亮的位置，至少需要几盏灯

- 代码技巧：如果递归公用老的数组就需要恢复现场，如果每次都复制出一个新的就不需要恢复现场。

- 如何贪心：

  第一个分支：如果i位置是一个x，那么直接跳到i+1位置做决定

  第二个分支：

  - 如果i位置是一个点，i+1位置是一个x，那么就在i位置放灯，跳到I+2位置做决定。
  - 如果i位置是一个点，i+1位置也是一个点，那么就在i+1的位置放灯，跳到I+3位置做决定。i+2位置不用管了，因为不管是不是墙都是满足的。
  - 如果i位置是一个点，i+1位置没有字符了，那么就在i位置放一个灯，结束。



### 代码--暴力递归

```java
/**
 * 利用暴力递归来实现
 *
 * @param road:只带有叉和点的字符串
 * @return
 */
public static int minLight1(String road) {
    if (road==null||road.length()==0){
        return Integer.MAX_VALUE;
    }
    return process1(road.toCharArray(),0,new HashSet<Integer>());
}

/**
 * 因为index之前的位置已经决定好了，我们只需要决定index之后的位置是否放灯即可，最后lights中的元素个数就是灯的总数。
 * 每到一个'点'都有两种情况,放灯或者不放灯，我们让它递归下去。然后判断‘点’自己有没有被点亮，点亮说明左右两边或者自己位置有灯
 * 注意：在递归的时候不要把叉和点区别对待，不然不好递归
 * @param road:只带有叉和点的字符数组
 * @param index:在index之前的位置已经做好了是否放灯的决定---不包括index自己
 * @param lights:决定放灯的位置记录在light中
 * @return :返回能够照亮所有居民点的最少灯数
 */
public static int process1(char[] road, int index, HashSet<Integer> lights) {
    if (index == road.length) {//结束--base case//说明[0,road.length-1]做完决定
        for (int i = 0; i < road.length; i++) {//对于数组里面的每一个点都进行判断
            if (road[i]=='.'&&!lights.contains(i - 1) && !lights.contains(i) && !lights.contains(i + 1)) {
                return Integer.MAX_VALUE;//说明没有照亮所有的居民区
            }
        }
        return lights.size();
    } else {//还未结束
        int no=process1(road,index+1,lights);//index位置不放灯
        int yes=Integer.MAX_VALUE;//index位置放灯,如果index位置是x那么将一直保持MAX_VALUE
        if (road[index]=='.'){//只有index位置是'点'这个yes才有意义。因为墙不能放灯
            lights.add(index);
            yes=process1(road,index+1,lights);
            lights.remove(index);
        }
        return Math.min(no,yes);

    }
}
```



- 可能出错的地方：no或者yes不能多加lights，因为process本身就是一个全局的最小值。

  int no=process1(road,index+1,lights)+lights.size();

- 由于这里有递归方法，所以样本的大小要小一点，否则一直压栈速度慢，甚至可能溢出。



### 代码--贪心

```java
public static int minLights2(String road) {
    if (road == null || road.length() == 0) {
        return 0;
    }
    return process2(road.toCharArray());
}

/**
 * 潜台词：index前面的影响不到index
 *
 * @param road:数组空不空在minLights2控制，这里默认是非空
 * @return
 */
public static int process2(char[] road) {
    int index = 0;
    int res = 0;
    while (index < road.length) {//因为index后跳的距离不规律所以不用for循环
        if (road[index] == 'x') {
            index++;
        } else {//index是点
            if (index + 1 == road.length) {//index后面没有了，那么只能在index放灯
                res++;
                break;
            } else {//index后面还有
                if (road[index + 1] == 'x') {//index+1是x
                    res++;
                    index += 2;
                } else {//index+1是点,不管index+2是x还是‘点’我们都要在index+1的位置放灯，然后跳到index+3
                    res++;
                    index += 3;
                }
            }
        }
    }
    return res;
}
```

## 切金条

- 一块金条切成两半，是需要花费和长度数值一样的铜板的。
  比如长度为20的金条，不管怎么切，都要花费20个铜板。一群人想整分整块金条，怎么分最省铜板?
  例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。
  如果先把长度60的金条分成10和50，花费60;再把长度50的金条分成20和30，花费50;—共花费110铜板。但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20，花费30;—共花费90铜板。

  输入一个数组，返回分割的最小代价。



### 代码

```java
public static int lessMoney1(int[]arr){
    if (arr==null||arr.length==0){
        return 0;
    }
    return process1(arr,0);
}

/**
 *暴力的思路就是不断的去更新这个less。和安排会议思路差不多
 * @param arr:现在需要合并的金条，逆向思维寻求最小金额。
 * @param preMoney:因为是递归函数，子调用需要从父调用中得知之前已经累计了多少金额
 * @return
 */
public static int process1(int []arr,int preMoney){
    if (arr.length==1){
        return preMoney;
    }
    int less=Integer.MAX_VALUE;
    for (int i=0;i<arr.length;i++){
        for (int j=i+1;j<arr.length;j++){
            int []p=mergeTwoNum(arr,i,j);
            less=Math.min(less,process1(p,preMoney+arr[i]+arr[j]));
        }
    }
    return less;
}

public static int[] mergeTwoNum(int[]arr,int i,int j){
    int[] p=new int[arr.length-1];
    int index=0;//p
    for (int k=0;k<arr.length;k++){
        if (k!=i&&k!=j){
            p[index++]=arr[k];
        }
    }
    p[index]=arr[i]+arr[j];
    return p;
}

public static int lessMoney2(int[] arr){
    PriorityQueue<Integer> heap=new PriorityQueue<>();
    for (int a:arr){
        heap.add(a);
    }
    int sum=0;
    int cur=0;
    while (heap.size()>=2){
        cur=heap.poll()+heap.poll();//产生这次要付的钱
        sum+=cur;
        heap.add(cur);
    }
    return sum;
}
```



## 获得最大钱数

- 题目：输入:正数数组costs、正数数组profits、正数K、正数M
  costs[i]表示i号项目的花费
  profits[们]表示i号项目在扣除花费之后还能挣到的钱(利润)

  K表示你只能串行的最多做k个项目
  M表示你初始的资金
  说明:每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。输出:你最后获得的最大钱数。

![image-20220517225709367](./image\image-20220517225709367.png)

### 代码

```java
public static class Program {
    public int cost;
    public int capital;

    public Program(int cost, int capital) {
        this.cost = cost;
        this.capital = capital;
    }
}

public static class LessCostComparator implements Comparator<Program>{
    @Override
    public int compare(Program o1, Program o2) {
        return o1.cost-o2.cost;
    }
}

public static class MoreCostComparator implements Comparator<Program>{
    @Override
    public int compare(Program o1, Program o2) {
        return o2.capital-o1.capital;
    }
}

/**
 * cost数组一定和capital数组等长
 * @param k:最多接收k个项目
 * @param w:是初始资金
 * @param cost:数组下标i代表第i个项目的花费
 * @param capital:第i个项目的净利润
 * @return
 */
public static int findMax(int k, int w, int[] cost, int[] capital) {
    PriorityQueue<Program> costHeap=new PriorityQueue<>(new LessCostComparator());
    PriorityQueue<Program> capitalHeap=new PriorityQueue<>(new MoreCostComparator());
    for (int i=0;i<cost.length;i++){//全部放入costHeap等待解锁
        costHeap.add(new Program(cost[i],capital[i]));
    }
    for (int i=0;i<k;i++){
        while(!costHeap.isEmpty()&&w>=costHeap.peek().cost){//有有待解锁的项目，并且我有能力启动
            capitalHeap.add(costHeap.poll());
        }
        if (capitalHeap.isEmpty()){
            return w;
        }
        w+=capitalHeap.poll().capital;
    }
    return w;
}
```



# 并查集

- 1)有若干个样本a、b、c、d…类型假设是V
  2)在并查集中一开始认为每个样本都在单独的集合里

  3)用户可以在任何时候调用如下两个方法:

  ​		boolean isSameSet(V x,V y):查询样本x和样本y是否属于一个集合

  ​		void union(V x,V y):把x和y各自所在集合的所有样本合并成一个集合

  4)isSameSet和union方法的代价越低越好

![image-20220516190459154](./image\image-20220516190459154.png)

- 并查集的大致思路就是如上。但是实现的方法有很多。

- 这里的并查集是用链表来实现的。这里有两个可以优化的地方，一个是在找父亲的时候，要沿途中要把链变成扁平的，就是全部都指向他们的最终父亲。还有一个就是小的集合挂在大的集合下面。
- 虽然我们这里把沿途的链变成扁平有额外的开销，但是分摊到每一次上，总体的时间复杂度就是O(1)的。

```java
/**
 * nodes表用来记录每一个结点
 * parents表用来记录每一个结点的代表结点,用于实现向上指
 * size表只有当一个结点是代表结点的时候才会有记录
 *所以方法中的V v，默认都是在并查集里面的
 * @param <V>
 */
public static class UnionFind<V> {

    public static class Node<V> {
        V value;

        public Node(V value) {
            this.value = value;
        }
    }

    public HashMap<V, Node> nodes;
    public HashMap<Node, Node> parents;
    public HashMap<Node, Integer> size;

    public UnionFind(List<V> values) {
        nodes = new HashMap<>();
        parents = new HashMap<>();
        size = new HashMap<>();

        for (V v : values) {
            Node node = new Node<>(v);
            nodes.put(v, node);
            parents.put(node, node);
            size.put(node, 1);
        }
    }

    /**
     *
     * @param node:如果node不在nodes表里面，那么会返回自己
     * @return
     */
    public Node findFather(Node node) {
        Stack<Node> stack = new Stack<>();
        while (node != parents.get(node)) {
            stack.add(node);
            node = parents.get(node);
        }
        while (!stack.isEmpty()) {//扁平化
            parents.put(stack.pop(), node);
        }
        return node;
    }

    public boolean isSameSet(V a, V b) throws Exception {
            return findFather(nodes.get(a)) == findFather(nodes.get(b));
    }

    /**
     * 小挂大，所以第一步是确认不是一个集合后找大小
     *
     * @param a
     * @param b
     */
    public void union(V a, V b) {
        Node head1 = findFather(nodes.get(a));
        Node head2 = findFather(nodes.get(b));
        if (head1 == head2) {
            return;
        }
        int size1 = size.get(head1);
        int size2 = size.get(head2);
        Node big = size1 >= size2 ? head1 : head2;
        Node small = big == head1 ? head2 : head1;
        parents.put(small, big);
        size.put(big, size1 + size2);
        size.remove(small);
    }

    public int sets() {
        return size.size();
    }

}
```

## 合并用户

![image-20220518130736662](./image\image-20220518130736662.png)

### 代码

```java
public static int HowManyPeople(List<Person> arr) {
    UnionFind<Person> unionFind = new UnionFind<Person>(arr);
    HashMap<String,Person> mapA=new HashMap<>();
    HashMap<String,Person> mapB=new HashMap<>();
    HashMap<String,Person> mapC=new HashMap<>();
    for (Person p:arr){
        if (mapA.containsKey(p.a)){
            unionFind.union(p,mapA.get(p.a));
        }else {
            mapA.put(p.a,p);
        }
        if (mapB.containsKey(p.b)){
            unionFind.union(p,mapB.get(p.b));
        }else {
            mapB.put(p.b,p);
        }
        if (mapC.containsKey(p.c)){
            unionFind.union(p,mapC.get(p.c));
        }else {
            mapC.put(p.c,p);
        }
    }
    return unionFind.sets();
}
```

# 图

## 图的介绍和两种遍历方式

![image-20220518234200825](./image\image-20220518234200825.png)

![image-20220518234248371](./image\image-20220518234248371.png)

![image-20220518234317403](./image\image-20220518234317403.png)

### 代码--BFS

```java
public static void bfs(Node node){
    if (node==null){
        return;
    }
    LinkedList<Node> queue=new LinkedList<>();//实现层序遍历的功能
    HashSet<Node> set=new HashSet<>();//保证结点不重复入队
    queue.add(node);
    set.add(node);//入队和入集合一定是绑定在一起发生
    while(!queue.isEmpty()){
        node=queue.poll();
        System.out.print(node.value+" ");
        for (Node p:node.nexts){//让node周围一圈没有入过队的结点入队
            if (!set.contains(p)){
                queue.add(p);
                set.add(p);
            }
        }
    }
}
```

### 代码--DFS

```java
public static void dfs(Node start){
    if (start == null) {
        return;
    }
    Stack<Node> stack=new Stack<>();
    HashSet<Node> set=new HashSet<>();
    stack.push(start);
    set.add(start);
    System.out.print(start.value+" ");//入栈就打印

    while (!stack.isEmpty()) {
        Node cur=stack.pop();
        for (Node node:cur.nexts){
            if (!set.contains(node)){
                stack.push(cur);//cur压回去
                stack.push(node);
                set.add(node);
                System.out.print(node.value+" ");//入栈就打印
                break;//回到while循环从刚刚加进去的这个最深的结点node重新开始
            }
        }
    }
}
```

## 拓扑排序



![image-20220518234352021](./image\image-20220518234352021.png)

### 代码

```java
public static List<Node> sortedTopology(Gragh gragh){
    HashMap<Node,Integer> inMap=new HashMap<>();
    Queue<Node> zeroQueue=new LinkedList<>();
    for (Node node:gragh.nodes.values()){
        inMap.put(node,node.in);
        if (node.in==0){
            zeroQueue.add(node);
        }
    }
    List<Node> result=new ArrayList<>();
    while(!zeroQueue.isEmpty()){
        Node cur=zeroQueue.poll();
        result.add(cur);
        for (Node next:cur.nexts){
            inMap.put(next,inMap.get(next)-1);
            if (inMap.get(next)==0){
                zeroQueue.add(next);
            }
        }
    }
    return result;

}
```

# 最小生成树

## kruskal

![image-20220518234515902](./image\image-20220518234515902.png)

### 代码

```java
public static class UnionFind{

    HashMap<Node,Node> parents=new HashMap<>();//向上找到父亲
    HashMap<Node,Integer> sizeMap=new HashMap<>();//只有是一个集合的代表结点才在这个表里

    public UnionFind() {
        parents=new HashMap<>();
        sizeMap=new HashMap<>();
    }

    public void makeSets(Collection<Node> collection){
        parents.clear();
        sizeMap.clear();//先清空老的并查集
        for (Node cur:collection){
            parents.put(cur,cur);
            sizeMap.put(cur,1);
        }
    }

    public Node findFather(Node node){
        Stack<Node> stack=new Stack<>();
        while(node!=parents.get(node)){//出while的时候node就是代表结点
            stack.push(node);
            node=parents.get(node);
        }
        while(!stack.isEmpty()){
            parents.put(stack.pop(),node);
        }
        return node;
    }

    public boolean isSameSet(Node node1,Node node2){
        return findFather(node1)==findFather(node2);
    }

    public void union(Node node1,Node node2){
        Node head1=findFather(node1);
        Node head2=findFather(node2);
        if (head1!=head2){
            int size1=sizeMap.get(head1);
            int size2=sizeMap.get(head2);
            Node big=size1>=size2?head1:head2;
            Node small=big==head1?head2:head1;
            parents.put(small,big);
            sizeMap.remove(small);
            sizeMap.put(big,size1+size2);
        }
    }
}

public static class EdgeComparator implements Comparator<Edge>{//从小到大的比较器
    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.weight-o2.weight;
    }
}

public static Set<Edge> Kruskal(Gragh gragh){
    UnionFind unionFind=new UnionFind();
    unionFind.makeSets(gragh.nodes.values());//传来一个容器，初始化并查集
    PriorityQueue<Edge> heap=new PriorityQueue<>();
    HashSet<Edge> res=new HashSet<>();
    for (Edge edge:gragh.edges){
        heap.add(edge);
    }
    while (!heap.isEmpty()) {
        Edge edge= heap.poll();
        if (!unionFind.isSameSet(edge.from,edge.to)){
            unionFind.union(edge.from, edge.to);
            res.add(edge);
        }
    }
    return res;
}
```

## prim



![image-20220518234953448](./image\image-20220518234953448.png)

### 代码

```java
public static class EdgeComparator implements Comparator<Edge> {
    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.weight - o2.weight;
    }
}

public static Set<Edge> Prim(Gragh gragh) {
    HashSet<Edge> res = new HashSet<>();
    PriorityQueue<Edge> heap = new PriorityQueue<>(new EdgeComparator());//存解锁的边
    HashSet<Node> set = new HashSet<>();//存解锁的点
    for (Node node : gragh.nodes.values()) {//for循环是为了防止森林，如果不是森林那么随便选一个就行

        if (!set.contains(node)) {
            set.add(node);
            for (Edge edge : node.edges) {
                heap.add(edge);
            }
            while(!heap.isEmpty()){
                Edge edge= heap.poll();
                if (!set.contains(edge.to)){
                    set.add(edge.to);
                    res.add(edge);
                    for (Edge e:edge.to.edges){
                        heap.add(edge);
                    }
                }
            }
        }
    }
    return res;
}
```



## Dijkstra

![image-20220522163203373](./image\image-20220522163203373.png)

### 代码--1版本

```java
/**
 * 从distanceMap中选一个距离最小的结点，并且这个结点不在set里面。
 * @param distanceMap
 * @param set
 * @return
 */
public static Node find(HashMap<Node,Integer> distanceMap, HashSet<Node> set){
    int distance=Integer.MAX_VALUE;
    Node minNode=null;//如果distanceMap中的结点都已经被选过了，那么就返回null
    for (Node node:distanceMap.keySet()){
        if (!set.contains(node)&&node.value<distance){
            minNode=node;
            distance= node.value;
        }
    }
    return minNode;
}

public static HashMap<Node,Integer> Dijkstra(Node from){
    HashMap<Node,Integer> distanceMap=new HashMap<>();
    HashSet<Node> set=new HashSet<>();
    distanceMap.put(from,0);
    Node cur=from;
    while(cur!=null){//开始一个一个选最小距离的结点
        int distance=distanceMap.get(cur);
        for (Edge edge:cur.edges){
            if (!distanceMap.containsKey(edge.to)){//这个点本来到达不了
                distanceMap.put(edge.to,distance+edge.weight);
            }else {//如果可以到达，就更新原本map里面的值
                distanceMap.put(edge.to,Math.min(distanceMap.get(edge.to),distance+ edge.weight));
            }
        }
        set.add(cur);
        cur=find(distanceMap,set);
    }
    return distanceMap;
}
```

### 代码-2版本

小根堆里面存的是一条一条记录，记录里面有两个字段，一个是目的结点，一个是从源节点到目的结点的距离。小根堆需要更新并且调整结构，因为距离是会更新的。由于我们需要更新位置，所以我们的小根堆需要一个额外的结构来记住每一个记录放在了哪一个位置。还需要一个一个忽略方法，让我弹出过的记录不能再一次加进来，也就是这个结点我们不会再对它做操作了，所以我们还需要另一个结构set来记录我们加入过的结点。

```java
public static class Record{
    public int distance;
    public Node node;

    public Record(int distance, Node node) {
        this.distance = distance;
        this.node = node;
    }
}

public static class Heap{
    public Node[] nodes;
    public HashMap<Node,Integer> distanceMap;//用来实现Node之间的映射比较
    public HashMap<Node,Integer> indexMap;//用来实现更新调整
    public int size;

    public Heap(int size) {
        this.size = size;
        nodes=new Node[size];
        distanceMap=new HashMap<>();
        indexMap=new HashMap<>();
    }

    /**
     * @param index:从index这个位置开始，向上调整为小根堆结构
     */
    private void upHeapify(int index){
        int child=index;
        Node temp=nodes[child];
        for(;distanceMap.get(nodes[child-1>>1])>distanceMap.get(temp)&&child>0;child=child-1>>1){
            indexMap.put(nodes[child-1>>1],child);
            nodes[child]=nodes[child-1>>1];
        }
        indexMap.put(temp,child);
        nodes[child]=temp;
    }

    /**
     *
     * @param index:从index开始向下调整成最小堆
     * @param maxIndex:nodes数组的最大下标为maxIndex
     */
    private void downHeapify(int index, int maxIndex){
        Node temp=nodes[index];
        int parent=index;
        int child;
        for (;parent*2+1<=maxIndex;parent=child){
            child=parent*2+2<=maxIndex
                    &&distanceMap.get(nodes[parent*2+2])<distanceMap.get(nodes[parent*2+1])?parent*2+2:parent*2+1;
            if (distanceMap.get(nodes[child])<distanceMap.get(temp)){
                indexMap.put(nodes[child],parent);
                nodes[parent]=nodes[child];
            }else {
                break;//写在for循环的（）里面太长了。换成写在for循环里面需要break
            }
        }
        indexMap.put(temp,parent);
        nodes[parent]=temp;
    }

    private Record pop(){
        Record record=new Record(distanceMap.get(nodes[0]),nodes[0]);
        indexMap.put(nodes[0],-1);//改成曾经来过，现在不在的状态
        distanceMap.remove(nodes[0]);//出去了，并且以后也回不来，彻底的不要了
        swap(0,size-1);
        nodes[size-1]=null;//释放
        downHeapify(0,--size-1);
        return record;
    }

    private void addOrUpdateOrIgnore(Node node,int distance){
        if (isInHeap(node)&&distance<distanceMap.get(node)){
            distanceMap.put(node,distance);
        }else if (!isEntered(node)){
            distanceMap.put(node,distance);
            indexMap.put(node,size);
            nodes[size++]=node;
            upHeapify(size-1);
        }
    }


    private boolean isEmpty(){
        return size==0;
    }

    private boolean isEntered(Node node){
        return indexMap.containsKey(node);
    }

    private boolean isInHeap(Node node){
        return isEntered(node)&&indexMap.get(node)!=-1;
    }

    private void swap(int index1,int index2){
        indexMap.put(nodes[index1],index2);
        indexMap.put(nodes[index2],index1);
        Node temp=nodes[index1];
        nodes[index1]=nodes[index2];
        nodes[index2]=temp;
    }

}

public static HashMap<Node,Integer> Dijkstra2(Node from,int size){
    HashMap<Node,Integer> res=new HashMap<>();
    Heap heap=new Heap(size);
    heap.addOrUpdateOrIgnore(from,0);
    while(!heap.isEmpty()){
        Record record=heap.pop();
        int distance=record.distance;
        Node node=record.node;
        for (Edge edge:node.edges){
            heap.addOrUpdateOrIgnore(edge.to,distance+edge.weight);
        }
        res.put(node,distance);
    }
    return res;
}
```
